//                  CVM Class Library
//                  http://cvmlib.com
//
//          Copyright Sergei Nikolaev 1992-2022
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)
/**
 * @mainpage CVM Class Library Documentation
 * @version 9.0
 * @author Sergei Nikolaev (c) 1992-2022
 * @date May 17th, 2022
 *
 * This C++ class library encapsulates concepts of vector and different matrices
 * including square, band, symmetric and Hermitian ones in Euclidean space
 * of real and complex numbers. It utilizes BLAS and LAPACK Fortran libraries
 * in order to achieve the best numerical performance possible.
 * Along with basic vector and matrix arithmetic it implements different algorithms
 * including norm computations, elementary transformations, solving linear systems
 * of kind Ax=b and AX=B, singular value decomposition, matrix rank and determinant
 * computation, non-symmetric and symmetric eigenvalue problem (including Cholesky
 * and Bunch-Kaufman factorization), LU factorization, QR, RQ, LQ and QL factorizations,
 * different linear least square problems, square matrix polynomials,
 * square matrix inversion, pseudo (generalized) inversion and square matrix exponent.
 * All these algorithms are implemented for real and complex numbers.
 * Distributed under the Boost Software License, Version 1.0.
 * Functional classes, vectors anf matrices are later addition to the library (since ver. 7.0)
 * Since version 8.0 the library uses new C++11 features for improved performance.
 * @file cvm.h
 */

#ifndef _CVM_H
#define _CVM_H

#include <cstdint>

// 5.7 ILP64 support
#if defined(CVM_ILP64)
    using tint = int64_t;  //!< Either 32 of 64 bit (when \c CVM_ILP64 is defined) signed integer
#   define CVM_TINT_FORMAT "%lld"
#else
    using tint = int32_t;  //!< Either 32 of 64 bit (when \c CVM_ILP64 is defined) signed integer
#   define CVM_TINT_FORMAT "%d"
#endif

#if !defined(CVM_NO_MT)  // as of 5.7 it's by default
#   define CVM_MT
#   if !defined(_PTHREADS)
#       define _PTHREADS  // NOLINT
#   endif
#endif

//#if(_MSC_VER >= 1800) && defined(__INTEL_COMPILER)
//#   pragma warning(disable:4267)
//#endif

#include <cmath>
#include <array>
#include <vector>
#include <map>
#include <iostream>

// MSVC++ 6.0 and higher settings
#if defined(_MSC_VER)
#   pragma once
#   define WIN32_LEAN_AND_MEAN  // Exclude rarely-used stuff from Windows headers
#   ifndef _WIN32_WINNT
#       define _WIN32_WINNT 0x500  // at least Win2000 is required for 
                                   // InitializeCriticalSectionAndSpinCount
#   endif
#   include <windows.h>
#   include <process.h>
// 6.0 TR1 dependency added
#   include <memory>

#   if (_MSC_VER < 1400)
#       error "Please use version 5.2 for older MSVC compilers"
#   endif
#   if (_MSC_VER >= 1700)  // since VC11 aka MS Visual Studio 2012
#       define CVM_STD_MUTEX
#       include <mutex>
#       include <thread>
#   endif
#   if (_MSC_VER >= 1800)  // since VC12 aka MS Visual Studio 2013
#       define CVM_USE_VARIADIC_TEMPLATES
#       define CVM_USE_INITIALIZER_LISTS
#       define CVM_USE_DELEGATING_CONSTRUCTORS
#       include <initializer_list>
#   endif
#   if (_MSC_VER >= 1900)  // since VC14 aka MS Visual Studio 2015
#       define CVM_USE_USER_LITERALS
#   endif

#   if (_MSC_VER < 1900)  // before VC14 aka MS Visual Studio 2015
#       define constexpr
#   endif

#   if (!defined(__INTEL_COMPILER) || !defined(_WIN64)) && !(_MSC_VER >= 1500 && defined(_WIN64))
#       define CVM_PASS_STRING_LENGTH_TO_FTN_SUBROUTINES
#   endif
#   if (defined(__INTEL_COMPILER) && (_MSC_VER == 1900))  // Intel's glitch
#       define CVM_USE_MALLOC
#   endif
//#   pragma warning(disable:4290)
#   if defined(CVM_FLOAT)
//#       pragma warning(disable:4244)
#   endif
#   if defined(SRC_EXPORTS) && !defined(CVM_EXPORTS)
#       define CVM_EXPORTS
#   endif

#   if (_MSC_VER >= 1700)
#       include <unordered_map>
#   endif

#   define CVM_BLOCKS_MAP std::unordered_map
#   ifdef CVM_STATIC
#       define CVM_API
#   else
#       ifdef CVM_EXPORTS
#           define CVM_API __declspec(dllexport)
#       else
#           define CVM_API __declspec(dllimport)
#       endif
#   endif

using CVM_LONGEST_INT = int64_t;  //!< Longest integer possible on this platform

#   if defined(_WIN64)
using CVM_PTR_WRAPPER = unsigned long long;
#   else
#       if defined(CVM_ILP64)
#           error "CVM_ILP64 is incompatible with 32 bit mode"
#       endif
using CVM_PTR_WRAPPER = unsigned long;
#   endif

#   define CVM_VSNPRINTF vsnprintf_s
#   define CVM_VSNPRINTF_S_DEFINED
#   define CVM_STRCPY_S_DEFINED

// GCC settings
#elif defined(__GNUC__)
#   ifdef __stdcall
#       undef __stdcall
#   endif
#   define __stdcall  // NOLINT
#   include <semaphore.h>  // Unix

// 8.0 - since 4.7.0 we use new std::mutex features
#   if !defined(__INTEL_COMPILER) && \
        (__GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 7)
#       define CVM_USE_DELEGATING_CONSTRUCTORS
#       define CVM_USE_USER_LITERALS
#       define CVM_STD_MUTEX
#       include <mutex>
#       include <thread>
#   else
#       define override
#   endif

// 8.1 - more C++11 features, see also http://gcc.gnu.org/projects/cxx0x.html
#   if __GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 4
#       define CVM_USE_VARIADIC_TEMPLATES
#       define CVM_USE_INITIALIZER_LISTS
#       include <initializer_list>
#   endif

// 6.0 TR1 dependency added
#   include <memory>

#   define CVM_API
#   define CVM_BLOCKS_MAP std::map

using CVM_LONGEST_INT = int64_t;

#   if defined(__AMD64__) || defined(_WIN64) || defined(__x86_64__)
using CVM_PTR_WRAPPER = unsigned long long;
#   else
#       if defined(CVM_ILP64)
#           error "CVM_ILP64 is incompatible with 32 bit mode"
#       endif
using CVM_PTR_WRAPPER = unsigned long;
#   endif

#   define CVM_VSNPRINTF vsnprintf

// 5.7 - looking for memset
#   include <cstring>
// gcc 4.6.1 fix for ptrdiff_t
#   include <cstddef>

//clang -dM -E -x c /dev/null
#   if defined(__clang__) && __clang_major__ <= 5
#       define CVM_NO_DEFAULT_RANDOM_ENGINE_SUPPORTED 1
#   endif
#   if defined(__clang__) && __clang_major__ >= 5
#       define CVM_USE_VARIADIC_TEMPLATES
#       define CVM_USE_INITIALIZER_LISTS
#       define CVM_USE_USER_LITERALS
#       define CVM_USE_DELEGATING_CONSTRUCTORS
#   endif
#endif

#include <cstdio>
#include <cstdarg>
#include <cmath>
#include <cfloat>
#include <ctime>

// fix for missing __builtin_clog functions
//#if defined(__INTEL_COMPILER)
//#   if defined(_GLIBCXX_USE_C99_COMPLEX)
//#       undef _GLIBCXX_USE_C99_COMPLEX
//#       define _GLIBCXX_USE_C99_COMPLEX 0
//#   endif
//#endif

#include <complex>
using namespace std::complex_literals;

#if !defined(CVM_NO_DEFAULT_RANDOM_ENGINE_SUPPORTED)
#   include <random>
#endif

#if defined(STLPORT)
#   define CVM_USES_STLPORT
#endif

#if defined(_DEBUG) || defined(DEBUG)
#   define CVM_DEBUG
#   include <assert.h>
#   define CVM_ASSERT(p,n) _cvm_assert(p,n);
#else
#   define CVM_ASSERT(p,n)
#endif

#define CVM_OK                           0  //!< Error code for No error
#define CVM_OUTOFMEMORY                  1  //!< Error code for "Failed to allocate %u bytes of memory"
#define CVM_WRONGSIZE                    5  //!< Error code for "Wrong size %d"
#define CVM_SIZESMISMATCH                6  //!< Error code for "Sizes mismatch: %d!=%d"
#define CVM_WRONGMKLARG                  7  //!< Error code for "Wrong argument %d passed to BLAS or LAPACK subroutine" - this one never gets called, XERBLA does the job
#define CVM_WRONGMKLARG2                 8  //!< Error code for "Wrong argument %d passed to BLAS or LAPACK subroutine %s"
#define CVM_SINGULARMATRIX               9  //!< Error code for "The diagonal element (or main minor) %d of the matrix is zero (or singular)"
#define CVM_NOTPOSITIVEDEFINITE          10 //!< Error code for "The leading minor of order %d (and hence the matrix itself) is not positive-definite"
#define CVM_WRONGCHOLESKYFACTOR          11 //!< Error code for "The diagonal element %d of the Cholesky factor (and hence the factor itself) is zero"
#define CVM_WRONGBUNCHKAUFMANFACTOR      12 //!< Error code for "The diagonal element %d of the Bunch-Kaufman factor (and hence the factor itself) is zero"
#define CVM_NOTPOSITIVEDIAG              13 //!< Error code for "The diagonal element %d of the matrix is nonpositive. Equilibration failed"
#define CVM_CONVERGENCE_ERROR            14 //!< Error code for "Method failed to converge: %s at %s:%d"
#define CVM_DIVISIONBYZERO               15 //!< Error code for "Attempt to divide by zero"
#define CVM_SEMAPHOREERROR               16 //!< Error code for "Critical Section access error" (Windows) or "Semaphore access error" (Unix)
#define CVM_READ_ONLY_ACCESS             17 //!< Error code for "Attempt to change read-only element"
#define CVM_SUBMATRIXACCESSERROR         18 //!< Error code for "Attempt to access non-continuous submatrix as a continuous array, see programmer's reference for details"
#define CVM_SUBMATRIXNOTAVAILABLE        19 //!< Error code for "Submatrix instantiation is not available for class '%s', see programmer's reference for details"
#define CVM_MATRIXNOTSYMMETRIC           20 //!< Error code for "The matrix passed doesn't appear to be symmetric"
#define CVM_MATRIXNOTHERMITIAN           21 //!< Error code for "The matrix passed doesn't appear to be Hermitian (%g vs. tolerance %g)"
#define CVM_BREAKS_HERMITIANITY          22 //!< Error code for "This operation could make the matrix non-Hermitian. Use %s instead"
#define CVM_METHODNOTAVAILABLE           23 //!< Error code for "Function '%s' is not available for class '%s'. See programmer's reference for details"
#define CVM_NOTIMPLEMENTED               24 //!< Error code for "Function '%s' is not implemented"
#define CVM_CANT_RESIZE_SHARED_MEM       25 //!< Error code for "Can't resize shared memory"
#define CVM_NOT_CONJUGATED               26 //!< Error code for "Complex numbers are not conjugated: (%g,%g) vs. (%g,%g) with tolerance %g"
// 8.1
#define CVM_WRONGSIZE_LT                 27 //!< Error code for "Wrong size: %d < %d"
#define CVM_WRONGSIZE_LE                 28 //!< Error code for "Wrong size: %d <= %d"
#define CVM_INDEX_GT                     29 //!< Error code for "Index value %d > %d"
#define CVM_INDEX_GE                     30 //!< Error code for "Index value %d >= %d"
#define CVM_OUTOFRANGE_LTGT              31 //!< Error code for "Index value %d is out of [%d,%d] range"
#define CVM_OUTOFRANGE_LTGE              32 //!< Error code for "Index value %d is out of [%d,%d) range"
#define CVM_OUTOFRANGE_LTGE1             33 //!< Error code for "Index value %d is out of [%d,%d) range"
#define CVM_OUTOFRANGE_LTGE2             34 //!< Error code for "Index value %d is out of [%d,%d) range"
#define CVM_SIZESMISMATCH_GT             35 //!< Error code for "Sizes mismatch: %d > %d"
#define CVM_SIZESMISMATCH_LT             36 //!< Error code for "Sizes mismatch: %d > %d"

#define CVM_THE_LAST_ERROR_CODE          37 //!< Error code to be used it in derived classes while defining user error codes
#define CVM_MATRIX_ELEMENT_SEPARATOR     " "
#define CVM_EOL                          std::endl

using tbyte = unsigned char;  //!< memory allocation quantum

#ifdef CVM_NO_NAMESPACE
#   define CVM_NAMESPACE
#   define CVM_NAMESPACE_BEG
#   define CVM_NAMESPACE_END
#else
#   define CVM_NAMESPACE cvm
#   define CVM_NAMESPACE_BEG namespace CVM_NAMESPACE {
#   define CVM_NAMESPACE_END }
#endif


CVM_NAMESPACE_BEG

//! %Array deleter helper class
template<typename T>
class ArrayDeleter {
public:
    void operator () (T* p) const {
        if (p != nullptr) {  // NOLINT
#if defined(CVM_USE_MALLOC)
            free(p);
#else
            ::delete[] p;
#endif
        }
    }
};

template<typename TR, typename T>  class basic_array;
template<typename TR, typename TC> class Matrix;
template<typename TR, typename TC> class SqMatrix;
template<typename TR, typename TC> class BandMatrix;
template<typename TR>              class basic_rvector;
template<typename TR>              class basic_rmatrix;
template<typename TR>              class basic_srmatrix;
template<typename TR, typename TC> class basic_cvector;
template<typename TR, typename TC> class basic_cmatrix;
template<typename TR, typename TC> class basic_scmatrix;
template<typename TR>              class basic_srbmatrix;
template<typename TR, typename TC> class basic_scbmatrix;
template<typename TR>              class basic_srsmatrix;
template<typename TR, typename TC> class basic_schmatrix;
template<typename T,  typename TR> class type_proxy;

//! Internal error messages holder.
class ErrMessages
{
    // message string maps
    using map_Msg = std::map<int,std::string,std::less<>>;
    using itr_Msg = map_Msg::iterator;
    using citr_Msg = map_Msg::const_iterator;
    using pair_Msg = std::pair<int,std::string>;

private:
    std::string msUnknown;
    map_Msg mmMsg;
    CVM_API ErrMessages();

public:
    const std::string& _get(int nException) {
        auto i = mmMsg.find(nException);
        return i == mmMsg.end() ? msUnknown : i->second;
    }

    CVM_API bool _add(int nNewCause, const char* szNewMessage);

    static CVM_API ErrMessages& ErrMessagesInstance();
    ~ErrMessages() = default;
};


/**
 * @brief Library exception class
 *
 * Exception class used in the library. Inherited from std::exception.
 */
class cvmexception : public std::exception
{
protected:
    int mnCause;  //!< Exception code
    mutable char mszMsg[256];  //!< Formatted message

//! @cond INTERNAL
    virtual const char* _get_message(int nCause) const {
        return ErrMessages::ErrMessagesInstance()._get(nCause).c_str();
    }
//! @endcond

public:
    /**
     * @brief Default constructor
     *
     * Default constructor (not an error by default).
     */
    cvmexception()  // NOLINT
      : mnCause(CVM_OK) {
        mszMsg[0] = '\0';
    }

    /**
     * @brief Exception constructor
     *
     * Exception constructor with error code and optional error string (might be formatted for printf).
     * @param[in] nCause Error code (might be user-defined).
     * @see add()
     */
    CVM_API explicit cvmexception(int nCause, ...);

    /**
     * @brief Exception copy constructor
     */
    CVM_API cvmexception(const cvmexception& e) noexcept;

    /**
     * @brief Exception move constructor
     */
    CVM_API cvmexception(cvmexception&& e) noexcept;

    /**
     * @brief Exception destructor, inherited from std::exception
     */
    ~cvmexception() override noexcept = default;

    /**
     * @brief Exception Code
     *
     * Returns numerical code for exception thrown.
     * @see CVM_OUTOFMEMORY
     * @see what()
     * @return Exception Code
     */
    int cause() const {
        return mnCause;
    }

    /**
     * @brief Exception message
     *
     * Returns formatted exception message.
     * @see cause()
     * @return Exception message
     */
    const char* what() const noexcept override {  // NOLINT
        return mszMsg;
    }

    /**
     * @brief Next available error code
     *
     * Next available error code to create user-defined ones.
     * @see add()
     * @return Error code
     */
    static int getNextCause() {  // NOLINT
        return CVM_THE_LAST_ERROR_CODE;
    }

    /**
     * @brief Add new user-defined exception
     *
     * Creates user-defined exception for library extensions, see programmer's reference for detailes.
     * @see getNextCause()
     * @param[in] nNewCause New code.
     * @param[in] szNewMessage New message.
     * @return bool - true if succeeded, false otherwise
     */
    static bool add(int nNewCause, const char* szNewMessage) {
        return ErrMessages::ErrMessagesInstance()._add(nNewCause, szNewMessage);
    }
};

//! @cond INTERNAL
template<typename T>
// NOLINTNEXTLINE
CVM_API void __copy(tint nSize, const T* pFrom, tint nFromIncr, T* pTo, tint nToIncr);
template<typename T>
// NOLINTNEXTLINE
CVM_API void __swap(tint nSize, T* p1, tint n1Incr, T* p2, tint n2Incr);

template<typename TC, typename TR>
CVM_API TR _real(const TC& mT);
template<typename TC, typename TR>
CVM_API TR _imag(const TC& mT);

template<typename TR>
// NOLINTNEXTLINE
CVM_API TR __dot(const TR* pDm, tint mnSize, tint mnIncr, const TR* pd, tint nIncr);
template<typename TC>
// NOLINTNEXTLINE
CVM_API TC __dotu(const TC* pDm, tint mnSize, tint mnIncr, const TC* pd, tint nIncr);
template<typename TC>
// NOLINTNEXTLINE
CVM_API TC __dotc(const TC* pDm, tint mnSize, tint mnIncr, const TC* pd, tint nIncr);

template<typename TR, typename TC>
// NOLINTNEXTLINE
CVM_API TR __norm(const TC* pd, tint nSize, tint nIncr);

template<typename TC>
// NOLINTNEXTLINE
CVM_API tint __idamax(const TC* pd, tint nSize, tint nIncr);
template<typename TC>
// NOLINTNEXTLINE
CVM_API tint __idamin(const TC* pd, tint nSize, tint nIncr);

template<typename TC>
// NOLINTNEXTLINE
CVM_API void __add(TC* pDm, tint mnSize, tint mnIncr, const TC* pv, tint nIncr);
template<typename TC>
// NOLINTNEXTLINE
CVM_API void __subtract(TC* pDm, tint mnSize, tint mnIncr, const TC* pv, tint nIncr);
//! @internal
template<typename TR, typename TC>
// NOLINTNEXTLINE
CVM_API void __scal(TC* pDm, tint mnSize, tint mnIncr, TR dScal);
template<typename TC>
// NOLINTNEXTLINE
CVM_API void __conj(TC* pDm, tint mnSize, tint mnIncr);

template<typename TR, typename TC>
// NOLINTNEXTLINE
CVM_API void __copy_real(TC* pDm, tint mnSize, tint mnIncr, const TR* pRe, tint nReIncr);
template<typename TR, typename TC>
// NOLINTNEXTLINE
CVM_API void __copy_imag(TC* pDm, tint mnSize, tint mnIncr, const TR* pRe, tint nReIncr);
template<typename TR, typename TC>
// NOLINTNEXTLINE
CVM_API void __copy2(TC* pDm, tint mnSize, tint mnIncr, const TR* pRe, const TR* pIm,
                     tint nReIncr = 1, tint nImIncr = 1);

template<typename TC, typename TM, typename TV>
// NOLINTNEXTLINE
CVM_API void __gemv(bool bLeft, const TM& m, TC dAlpha, const TV& v, TC dBeta, TV& vRes);
template<typename TC, typename TM, typename TV>
// NOLINTNEXTLINE
CVM_API void __gbmv(bool bLeft, const TM& m, TC dAlpha, const TV& v, TC dBeta, TV& vRes);
template<typename TR, typename TM, typename TV>
// NOLINTNEXTLINE
CVM_API void __symv(const TM& m, TR dAlpha, const TV& v, TR dBeta, TV& vRes);
template<typename TC, typename TM, typename TV>
// NOLINTNEXTLINE
CVM_API void __shmv(const TM& m, TC dAlpha, const TV& v, TC dBeta, TV& vRes);
template<typename TC, typename TM>
// NOLINTNEXTLINE
CVM_API void __gemm(const TM& ml, bool bTrans1, const TM& mr, bool bTrans2, TC dAlpha,
                    TM& mRes, TC dBeta);
template<typename TR, typename TSM, typename TM>
// NOLINTNEXTLINE
CVM_API void __symm(bool bLeft, const TSM& ml, const TM& mr, TR dAlpha, TM& mRes, TR dBeta);
template<typename TC, typename TSM, typename TM>
// NOLINTNEXTLINE
CVM_API void __hemm(bool bLeft, const TSM& ml, const TM& mr, TC dAlpha, TM& mRes, TC dBeta);

template<typename TC, typename TV>
// NOLINTNEXTLINE
CVM_API void __polynom(TC* pDm, tint ldP, tint mnM, const TC* pd, tint ldA, const TV& v);
template<typename T>
// NOLINTNEXTLINE
CVM_API void __inv(T& m, const T& mArg);
template<typename T, typename TR>
// NOLINTNEXTLINE
CVM_API void __exp(T& m, const T& mArg, TR tol);
template<typename T, typename TR>
// NOLINTNEXTLINE
CVM_API void __exp_symm(T& m, const T& mArg, TR tol);
template<typename TR, typename TC, typename TRM>
// NOLINTNEXTLINE
CVM_API void __solve(const TRM& m, tint nrhs, const TC* pB, tint ldB, TC* pX, tint ldX, TR& dErr,
                     const TC* pLU, const tint* pPivots, int transp_mode);
template<typename TC, typename TM, typename TSM>
// NOLINTNEXTLINE
CVM_API void __svd(TC* pd, tint nSize, tint nIncr, const TM& mArg,
                   TSM* mU, TSM* mVH);
template<typename TR, typename TM, typename TX>
// NOLINTNEXTLINE
CVM_API void __pinv(TX& mX, const TM& mArg, TR threshold);
template<typename TV, typename TSM, typename TSCM>
// NOLINTNEXTLINE
CVM_API void __eig(TV& vRes, const TSM& mArg, TSCM* mEigVect, bool bRightVect);
template<typename TR, typename TM>
// NOLINTNEXTLINE
CVM_API void __cond_num(const TM& mArg, TR& dCondNum);
template<typename TM>
// NOLINTNEXTLINE
void __low_up(TM& m, tint* nPivots);

template<typename TR>
// NOLINTNEXTLINE
CVM_API void __randomize(TR* pDm, tint mnSize, tint mnIncr, TR dFrom, TR dTo);
template<typename TC, typename TR>
// NOLINTNEXTLINE
CVM_API void __randomize_real(TC* pDm, tint mnSize, tint mnIncr, TR dFrom, TR dTo);
template<typename TC, typename TR>
// NOLINTNEXTLINE
CVM_API void __randomize_imag(TC* pDm, tint mnSize, tint mnIncr, TR dFrom, TR dTo);

template<typename TR, typename TM, typename TV>
// NOLINTNEXTLINE
CVM_API void __ger(TM& m, const TV& vCol, const TV& vRow, TR dAlpha);
template<typename TC, typename TM, typename TV>
// NOLINTNEXTLINE
CVM_API void __geru(TM& m, const TV& vCol, const TV& vRow, TC cAlpha);
template<typename TC, typename TM, typename TV>
// NOLINTNEXTLINE
CVM_API void __gerc(TM& m, const TV& vCol, const TV& vRow, TC cAlpha);

template<typename TC, typename TSM>
// NOLINTNEXTLINE
CVM_API void __syrk(bool bTransp, TC alpha, tint k, const TC* pA, tint ldA, TC beta, TSM& m);
template<typename TC, typename TSM>
// NOLINTNEXTLINE
CVM_API void __syr2k(bool bTransp, TC alpha, tint k, const TC* pA, tint ldA,
                     const TC* pB, tint ldB, TC beta, TSM& m);
template<typename TR, typename TC, typename TSM>
// NOLINTNEXTLINE
CVM_API void __herk(bool bTransp, TR alpha, tint k, const TC* pA, tint ldA, TR beta, TSM& m);
template<typename TR, typename TC, typename TSM>
// NOLINTNEXTLINE
CVM_API void __her2k(bool bTransp, TC alpha, tint k, const TC* pA, tint ldA,
                     const TC* pB, tint ldB, TR beta, TSM& m);

template<typename TM>
// NOLINTNEXTLINE
CVM_API tint __cholesky(TM& m);
template<typename TM>
// NOLINTNEXTLINE
CVM_API void __bunch_kaufman(TM& m, tint* nPivots);
template<typename TR, typename TM, typename TV>
// NOLINTNEXTLINE
CVM_API void __poequ(const TM& m, TV& vScalings, TR& dCond, TR& dMax);

template<typename TM, typename TSM>
// NOLINTNEXTLINE
CVM_API void __qre(const TM& mA, TM& mQ, TSM& mR);
template<typename TM, typename TSM>
// NOLINTNEXTLINE
CVM_API void __qrf(const TM& mA, TSM& mQ, TM& mR);
template<typename TM, typename TSM>
// NOLINTNEXTLINE
CVM_API void __rqe(const TM& mA, TSM& mR, TM& mQ);
template<typename TM, typename TSM>
// NOLINTNEXTLINE
CVM_API void __rqf(const TM& mA, TM& mR, TSM& mQ);

template<typename TM, typename TSM>
// NOLINTNEXTLINE
CVM_API void __lqe(const TM& mA, TSM& mL, TM& mQ);
template<typename TM, typename TSM>
// NOLINTNEXTLINE
CVM_API void __lqf(const TM& mA, TM& mL, TSM& mQ);
template<typename TM, typename TSM>
// NOLINTNEXTLINE
CVM_API void __qle(const TM& mA, TM& mQ, TSM& mL);
template<typename TM, typename TSM>
// NOLINTNEXTLINE
CVM_API void __qlf(const TM& mA, TSM& mQ, TM& mL);

// Linear Least Squares problems
template<typename TM, typename TV>
// NOLINTNEXTLINE
CVM_API void __gels(bool transpose, TM& mA, const TM& mB, TM& mX, TV& vErr);
template<typename TR, typename TM>
// NOLINTNEXTLINE
CVM_API void __gelsy(TM& mA, const TM& mB, TM& mX, TR tol, tint& rank);
template<typename TR, typename TV, typename TM>
// NOLINTNEXTLINE
CVM_API void __gelss(TM& mA, const TM& mB, TM& mX, TR rcond, TV& vSV, tint& rank);
template<typename TR, typename TV, typename TM>
// NOLINTNEXTLINE
CVM_API void __gelsd(TM& mA, const TM& mB, TM& mX, TR rcond, TV& vSV, tint& rank);

// 8.1 Generalized Eigenvalue Problem
template<typename TSRM, typename TSCM, typename TRV, typename TCV>
// NOLINTNEXTLINE
CVM_API void __ggev(TSRM& mA, TSRM& mB, TCV& vAlpha, TRV& vBeta,
                    TSCM* mEigVectLeft, TSCM* mEigVectRight);


template<typename T>
inline const T& _cvm_min(const T& x, const T& y) {
    return x < y ? x : y;
}

template<typename T>
inline const T& _cvm_max(const T& x, const T& y) {
    return x > y ? x : y;
}

template<class TR>
// NOLINTNEXTLINE
inline const TR* __get_real_p(const std::complex<TR>* c) {
#if defined(CVM_USES_STLPORT)
    return &c->_M_re;
#else
    return reinterpret_cast<const TR*>(c);
#endif
}

template<class TR>
// NOLINTNEXTLINE
inline const TR* __get_imag_p(const std::complex<TR>* c) {
#if defined(CVM_USES_STLPORT)
    return &c->_M_im;
#else
    return reinterpret_cast<const TR*>(c) + 1;
#endif
}

template<class TR>
// NOLINTNEXTLINE
inline TR* __get_real_p(std::complex<TR>* c) {
#if defined(CVM_USES_STLPORT)
    return &c->_M_re;
#else
    return reinterpret_cast<TR*>(c);
#endif
}

template<class TR>
// NOLINTNEXTLINE
inline TR* __get_imag_p(std::complex<TR>* c) {
#if defined(CVM_USES_STLPORT)
    return &c->_M_im;
#else
    return reinterpret_cast<TR*>(c) + 1;
#endif
}

// NOLINTNEXTLINE
template<class TR> inline const TR* __get_real_p(const TR* d) { return d; }
// NOLINTNEXTLINE
template<class TR> inline const TR* __get_imag_p(const TR* d) { return d; }
// NOLINTNEXTLINE
template<class TR> inline       TR* __get_real_p(TR* d) { return d; }
// NOLINTNEXTLINE
template<class TR> inline       TR* __get_imag_p(TR* d) { return d; }

//! Characters for fortran subroutines
class Chars
{
protected:
    static const char chars_[15];

public:
    static const char* pT() { return chars_;}
    static const char* pN() { return chars_ + 1;}
    static const char* pU() { return chars_ + 2;}
    static const char* pL() { return chars_ + 3;}
    static const char* pP() { return chars_ + 4;}
    static const char* pQ() { return chars_ + 5;}
    static const char* pB() { return chars_ + 6;}
    static const char* pE() { return chars_ + 7;}
    static const char* pR() { return chars_ + 8;}
    static const char* pA() { return chars_ + 9;}
    static const char* pS() { return chars_ + 10;}
    static const char* pV() { return chars_ + 11;}
    static const char* pO() { return chars_ + 12;}
    static const char* pI() { return chars_ + 13;}
    static const char* pC() { return chars_ + 14;}
};

template<class TR>
inline TR basic_cvmMachMin() {
    const TR _min = (std::numeric_limits<TR>::min)();
    return _min;
}

template<class TR>
inline TR basic_cvmMachSp() {
    const TR _eps = (std::numeric_limits<TR>::epsilon)();
    return _eps;
}

template<typename TR>
inline TR basic_cvmMachMax() {
    const TR _max((std::numeric_limits<TR>::max)());
    return _max;
}

template<typename TR>
inline TR basic_cvmLogMachMax() {
    const TR _log_max(::log(basic_cvmMachMax<TR>()));
    return _log_max;
}

// range and index checkers
template<typename T>
inline void _check_negative(int err_code, T val) {
    if (val < T()) {
        throw cvmexception(err_code, val);
    }
}

template<typename T>
inline void _check_positive(int err_code, T val) {
    if (val > T()) {
        throw cvmexception(err_code, val);
    }
}

template<typename T>
inline void _check_positive(int err_code, T val, const char* func,
                            const char* file, int line) {
    if (val > T()) {
        throw cvmexception(err_code, func, file, line);
    }
}

template<typename T>
inline void _check_lt(int err_code, T idx, T limit) {
    if (idx < limit) {
        throw cvmexception(err_code, idx, limit);
    }
}

template<typename T>
inline void _check_le(int err_code, T idx, T limit) {
    if (idx <= limit) {
        throw cvmexception(err_code, idx, limit);
    }
}

template<typename T>
inline void _check_ge(int err_code, T idx, T limit) {
    if (idx >= limit) {
        throw cvmexception(err_code, idx, limit);
    }
}

template<typename T>
inline void _check_gt(int err_code, T idx, T limit) {
    if (idx > limit) {
        throw cvmexception(err_code, idx, limit);
    }
}

template<typename T>
inline void _check_ne(int err_code, T idx, T limit) {
    if (idx != limit) {
        throw cvmexception(err_code, idx, limit);
    }
}

template<typename T>
inline void _check_lt_gt(int err_code, T idx, T low_limit, T up_limit) {
    if (idx < low_limit || idx > up_limit) {
        throw cvmexception(err_code, idx, low_limit, up_limit);
    }
}

template<typename T>
inline void _check_lt_ge(int err_code, T idx, T low_limit, T up_limit) {
    if (idx < low_limit || idx >= up_limit) {
        throw cvmexception(err_code, idx, low_limit, up_limit);
    }
}

template<typename TR>
inline bool _conjugated(const std::complex<TR>& v1,
                        const std::complex<TR>& v2, TR tol) {
    return std::abs(v1.real() - v2.real()) <= tol &&
           std::abs(v1.imag() + v2.imag()) <= tol;
}


//! define this to use Memory Pool Manager (not used by default sinse version 6.0)
#ifdef CVM_USE_POOL_MANAGER

//! Internal class of memory blocks
class MemoryBlocks
{
    struct BlockProperty {
        size_t mnSize;
        tint mnRefCount;
        BlockProperty(size_t nSize, tint nRefCount) : mnSize(nSize), mnRefCount(nRefCount) { }
    };

    using map_Blocks = std::map<tbyte*,BlockProperty,std::less<tbyte*>>;  //!< pointer -> {size, refcount}
    using itr_Blocks = map_Blocks::iterator;

    using map_FreeBs = std::multimap<size_t,tbyte*>;  //!< size -> pointer
    using itr_FreeBs = map_FreeBs::iterator;

    using map_FreeIt = std::map<tbyte*,itr_FreeBs,std::less<tbyte*>>;  //!< pointer -> iterator to FreeBs
    using itr_FreeIt = map_FreeIt::iterator;

    map_FreeBs mFreeBs;  //!< currently free blocks by sizes
    map_FreeIt mFreeIt;  //!< currently free blocks iterators by pointers
    map_Blocks mBlocks;  //!< currently occupied or freed blocks by pointers

public:
    void    AddBlock(tbyte* pBlock, size_t nBytes, bool bOccupied);
    tbyte*  GetFreeBlock(size_t nBytes);
    void    AddPair(tbyte* pBlock, size_t nBytes, size_t nRest);
#ifdef CVM_DEBUG
    void    Assert(const void* pvBlock, size_t nBytes);
#endif
    void    AddNew(tbyte* pBlock, size_t nBytes);  //!< for just allocated only, i.e. non-const
    tbyte*  AddRef(const tbyte* pBlock);
    tint    FreeBlock(tbyte* pBlock);
};


//! Internal memory pool class
class MemoryPool
{
    using list_blocks = std::list<tbyte*>;

    struct DeletePtr {
        template<class T>
        void operator () (T* p) const {
            ::delete[] p;
        }
    };

    list_blocks  mOutBlocks;  //!< outer memory blocks
    MemoryBlocks mMemoryBlocks;  //!< currently existing blocks and their statuses

public:
    MemoryPool();
    ~MemoryPool();

    tbyte* Malloc(size_t nBytes);
    tbyte* AddRef(const tbyte* pd);  //!< increases reference counter
    //!< decreases reference counter and returns memory back to the pool if the counter sets to zero
    tint   Free(tbyte*& pToFree);
#ifdef CVM_DEBUG
    void Assert(const void* pvBlock, size_t nBytes) {  //!< synchronized outside
        mMemoryBlocks.Assert(pvBlock, nBytes);
    }
#endif
    void Clear();  //!< destroys all outer blocks in reverse order
};

CVM_API tbyte* _cvmMalloc(size_t nBytes);
CVM_API tbyte* _cvmAddRef(const tbyte* pd);
CVM_API tint   _cvmFree(tbyte*& pd);
//! @endcond

/**
 * @brief Memory allocator
 *
 * To be used with Pool Manager only.
 * @see CVM_USE_POOL_MANAGER
 */
template<typename T>
inline T* cvmMalloc(size_t nEls) {
    return reinterpret_cast<T*>(_cvmMalloc(nEls * sizeof(T)));
}

/**
 * @brief Reference incrementer
 *
 * To be used with Pool Manager only.
 * @see CVM_USE_POOL_MANAGER
 */
template<typename T>
inline T* cvmAddRef(const T* pd) {
    return reinterpret_cast<T*>(_cvmAddRef(reinterpret_cast<const tbyte*>(pd)));
}

/**
 * @brief Memory deallocator
 *
 * To be used with Pool Manager only.
 * @see CVM_USE_POOL_MANAGER
 * @param[in] pd Pointer to memory to deallocate.
 */
template<typename T>
inline tint cvmFree(T*& pd) {
    return _cvmFree(reinterpret_cast<tbyte*&>(pd));
}

#else  // CVM_USE_POOL_MANAGER

/**
 * @brief Memory allocator
 *
 * Calls "::new[]" by default.
 * @see CVM_USE_POOL_MANAGER
 * @param[in] nEls Number of elements of type T to allocate.
 */
template<typename T>
inline T* cvmMalloc(tint nEls) {
    _check_lt(CVM_WRONGSIZE_LT, nEls, tint());
    if (nEls > tint()) {
#if defined(CVM_USE_MALLOC)
        return static_cast<T*>(malloc(nEls * sizeof(T)));
#else
        return ::new T[nEls];
#endif
    }
    return nullptr;
}

/**
 * @brief Memory deallocator
 *
 * Calls "::delete[]" by default.
 * @see CVM_USE_POOL_MANAGER
 */
template<typename T>
inline tint cvmFree(T*& pd) {
    if (pd != nullptr) {
#if defined(CVM_USE_MALLOC)
        free(pd);
#else
        ::delete[] pd;
#endif
        pd = nullptr;
    }
    return 0;
}

#endif  // !CVM_USE_POOL_MANAGER

/**
 * @brief Memory pool destroyer
 *
 * To be used with Pool Manager only. Does nothing otherwise.
 * @see CVM_USE_POOL_MANAGER
 */
CVM_API void cvmExit();

/**
 * @brief Memory cleaner
 *
 * Fills memory array with zeros.
 * @param[in] p Pointer to memory array.
 * @param[in] nEls Number of elements to clean.
 * @see tint
 */
template<typename T>
inline void cvmZeroMemory(T* p, tint nEls) {
    memset(p, 0, nEls * sizeof(T));
}

//! @cond INTERNAL
CVM_API void _cvm_assert(const void* pvBlock, size_t nBytes);
//! @endcond


//! Sends proxy value to output stream
template<typename T, typename TR>
inline std::ostream& operator << (std::ostream& os, const type_proxy<T,TR>& mOut) {
#if defined(_MSC_VER) && !defined(CVM_USES_STLPORT)
    os.imbue(std::locale::empty());
#endif
    os << static_cast<T>(mOut);
    return os;
}

//! Reads proxy value from input stream
template<typename T, typename TR>
inline std::istream& operator >> (std::istream& is, type_proxy<T,TR>& v) {
#if defined(_MSC_VER) && !defined(CVM_USES_STLPORT)
    is.imbue(std::locale::empty());
#endif
    T t;
    is >> t;
    v = t;
    return is;
}

/**
 @brief Reads basic_array from input stream

\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
std::ofstream os;
os.open("in.txt");
os << 1.2 << " " << 2.3 << std::endl << 3.4;
os.close();

std::ifstream is("in.txt");
rvector v(5);
is >> v;

std::cout << v;
}
catch(std::exception& e) {
std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.20e+000 2.30e+000 3.40e+000 0.00e+000 0.00e+000
\endcode
 @param[in] is Stream to read from.
 @param[out] aIn basic_array to write to.
 @return Reference to stream for further reading.
 */
template<typename TR, typename TC>
std::istream& operator >> (std::istream& is, basic_array<TR,TC>& aIn) {
#if !defined(CVM_USES_STLPORT) && defined(_MSC_VER)
    is.imbue(std::locale::empty());
#endif
    const tint nSize = aIn.size() * aIn.incr();
    CVM_ASSERT(aIn.get(), ((aIn.size() - 1) * aIn.incr() + 1) * sizeof(TC))
    for (tint i = 0; i < nSize && is.good(); i += aIn.incr()) {
        is >> aIn.get()[i];
    }
    return is;
}

/**
 @brief Writes basic_array to output stream

\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector v(3);
v(1) = tcomplex(1., 2.);
v(2) = tcomplex(3., 4.);

std::cout << v;
\endcode
prints
\code
(1.00e+000,2.00e+000) (3.00e+000,4.00e+000) (0.00e+000,0.00e+000)
\endcode
 @param[out] os Stream to write to.
 @param[in] aOut basic_array to write from.
 @return Reference to stream for further writing.
 */
template<typename TR, typename TC>
std::ostream& operator << (std::ostream& os, const basic_array<TR,TC>& aOut) {
#if !defined(CVM_USES_STLPORT) && defined(_MSC_VER)
    os.imbue(std::locale::empty());
#endif
    const tint nSize = aOut.size() * aOut.incr();
    CVM_ASSERT(aOut.get(), ((aOut.size() - 1) * aOut.incr() + 1) * sizeof(TC))
    for (tint i = 0; i < nSize && os.good(); i += aOut.incr()) {
        os << aOut.get()[i] << CVM_MATRIX_ELEMENT_SEPARATOR;
    }
    os << CVM_EOL;
    return os;
}

/**
  @brief Reads Matrix from input stream

Operator fills calling Matrix (row by row) referenced by parameter \c mIn with numbers from
\c is stream.

\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    std::ofstream os;
    os.open("in.txt");
    os << 1.2 << " " << 2.3 << std::endl << 3.4;
    os.close();

    std::ifstream is("in.txt");
    rmatrix m(3,2);
    is >> m;

    std::cout << m;
}
catch (std::exception& e) {
 std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.20e+000 2.30e+000
3.40e+000 0.00e+000
0.00e+000 0.00e+000
\endcode
  @param[in] is Stream to read from.
  @param[out] mIn Matrix to write to.
  @return Reference to stream for further reading.
  */
template<typename TR, typename TC>
std::istream& operator >> (std::istream& is, Matrix<TR,TC>& mIn) {
#if defined(_MSC_VER) && !defined(CVM_USES_STLPORT)
    is.imbue(std::locale::empty());
#endif
    TC v;
    for (tint i = 0; i < mIn.msize(); ++i) {
        for (tint j = 0; j < mIn.nsize() && is.good(); ++j) {
            is >> v;
            mIn._ij_proxy_val(i, j) = v;
        }
    }
    return is;
}

/**
 @brief Writes Matrix to output stream

Operator writes matrix (row by row) referenced by parameter \c mOut into
\c os stream.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

srmatrix m(3);
m(1,1) = 1.;
m(2,3) = 3.;

std::cout << m;
\endcode
prints
\code
1.00e+00 0.00e+00 0.00e+00
0.00e+00 0.00e+00 3.00e+00
0.00e+00 0.00e+00 0.00e+00
\endcode
 @param[out] os Stream to write to.
 @param[in] mOut Matrix to write from.
 @return Reference to stream for further writing.
 */
template<typename TR, typename TC>
std::ostream& operator << (std::ostream& os, const Matrix<TR,TC>& mOut) {
#if defined(_MSC_VER) && !defined(CVM_USES_STLPORT)
    os.imbue(std::locale::empty());
#endif
    for (tint i = 0; i < mOut.msize(); ++i) {
        for (tint j = 0; j < mOut.nsize() && os.good(); ++j) {
            os << mOut._ij_val(i, j) << CVM_MATRIX_ELEMENT_SEPARATOR;
        }
        os << CVM_EOL;
    }
    return os;
}

//! @cond INTERNAL
template<typename TR, typename TC, typename RM, typename RBM>
inline void _copy_b_matrix(RM& m, RBM& mb, bool bLeftToRight) {
    const tint nM = mb.msize();
    const tint nN = mb.nsize();
    const tint nKL = mb.lsize();
    const tint nKU = mb.usize();
    const tint nCol = 1 + nKL + nKU;
    tint nS, nShiftL, nShiftR;
    TC* pL;
    TC* pR;

    for (tint i = 0; i < nN; ++i) {
        nS = nCol;
        nShiftL = 0;
        nShiftR = 0;
        if (i < nKU) {
            nShiftR = nKU - i;
            nS -= nShiftR;
        } else {
            nShiftL = i - nKU;
        }
        if (nN - i <= nKL) {
            nS -= nKL + 1 - (nN - i);
        }

        pL = m.get() + i * nM + nShiftL;
        pR = mb._pb() + i * nCol + nShiftR;

        __copy<TC>(nS,
                   bLeftToRight ? pL : pR,
                   1,
                   bLeftToRight ? pR : pL,
                   1);
    }
}

// pd = p1 + p2
template<typename TR, typename TC>
inline void _sum(TC* pd, tint nSize, tint nIncr,
                 const TC* p1, tint nIncr1, const TC* p2, tint nIncr2) {
    if (pd == p1) {
        if (pd == p2) {
            const TR two(2.);
            __scal<TR,TC>(pd, nSize, nIncr, two);
        } else {
            __add<TC>(pd, nSize, nIncr, p2, nIncr2);
        }
    } else {
        if (pd == p2) {
            __add<TC>(pd, nSize, nIncr, p1, nIncr1);
        } else {
            __copy<TC>(nSize, p1, nIncr1, pd, nIncr);
            __add<TC>(pd, nSize, nIncr, p2, nIncr2);
        }
    }
}

// pd = p1 - p2
template<typename TR, typename TC>
inline void _diff(TC* pd, tint nSize, tint nIncr,
                  const TC* p1, tint nIncr1, const TC* p2, tint nIncr2) {
    if (pd == p1) {
        if (pd == p2) {
            const TR zero(0.);
            __scal<TR,TC>(pd, nSize, nIncr, zero);
        } else {
            __subtract<TC>(pd, nSize, nIncr, p2, nIncr2);
        }
    } else {
        if (pd == p2) {
            const TR mone(-1.);
            __subtract<TC>(pd, nSize, nIncr, p1, nIncr1);
            __scal<TR,TC>(pd, nSize, nIncr, mone);
        } else {
            __copy<TC>(nSize, p1, nIncr1, pd, nIncr);
            __subtract<TC>(pd, nSize, nIncr, p2, nIncr2);
        }
    }
}

// pDm = pDm + pd
template<typename TR, typename TC>
inline void _incr(TC* pDm, tint mnSize, tint mnIncr, const TC* pd, tint nIncr) {
    if (pDm == pd) {
        const TR two(2.);
        __scal<TR,TC>(pDm, mnSize, mnIncr, two);
    } else {
        __add<TC>(pDm, mnSize, mnIncr, pd, nIncr);
    }
}

// pDm = pDm - pd
template<typename TR, typename TC>
inline void _decr(TC* pDm, tint mnSize, tint mnIncr, const TC* pd, tint nIncr) {
    if (pDm == pd) {
        const TR zero(0.);
        __scal<TR,TC>(pDm, mnSize, mnIncr, zero);
    } else {
        __subtract<TC>(pDm, mnSize, mnIncr, pd, nIncr);
    }
}

// fills real part
template<typename TR, typename TC>
void _set_real(TC* pDm, tint mnSize, tint mnIncr, TR d) {
    const tint nIncr2 = 2 * mnIncr;
    const tint nSize = mnSize * nIncr2;
    TR* pd = __get_real_p<TR>(pDm);
    for (tint i = 0; i < nSize; i += nIncr2) {
        CVM_ASSERT(pd, (i + 1) * sizeof(TR))
        pd[i] = d;
    }
}

// fills imaginary part
template<typename TR, typename TC>
void _set_imag(TC* pDm, tint mnSize, tint mnIncr, TR d) {
    const tint nIncr2 = 2 * mnIncr;
    const tint nSize = mnSize * nIncr2;
    TR* pd = __get_imag_p<TR>(pDm);
    for (tint i = 0; i < nSize; i += nIncr2) {
        CVM_ASSERT(pd, (i + 1) * sizeof(TR))
        pd[i] = d;
    }
}
//! @endcond


/**
 * @brief Read-write access for a particular value
 *
 * This class is used to resctict access to elements of specific matrices
 * like symmetric, Hermitian and band ones.
 */
template<typename T, typename TR>
class type_proxy
{
protected:
    T& mT;  //!< reference to value
    T mV;  //! value for read-only
    bool mbReadOnly;  //!< read-only flag

public:
    /**
     * @brief Proxy constructor
     *
     * Creates instance of type proxy by non-const reference to a value.
     * @param[in] ref Reference to a value.
     * @param[in] read_only True for read-only proxy.
     */
    type_proxy(T& ref, bool read_only)
      : mT(ref),
        mV(ref),
        mbReadOnly(read_only) {}

    /**
     * @brief Proxy constructor
     *
     * Creates instance of type proxy by const reference to a value.
     * @param[in] ref Reference to a value.
     * @param[in] read_only True by default.
     */
    type_proxy(const T& ref)
      : mT(const_cast<T&>(ref)),
        mV(ref),
        mbReadOnly(true) {}

    /**
     * @brief Proxy copy constructor
     *
     * Creates instance of type proxy by another one.
     * @param[in] p Const reference to another proxy.
     */
    type_proxy(const type_proxy& p)
      : mT(p.mT),
        mV(p.mV),
        mbReadOnly(p.mbReadOnly) {}

    /**
     * @brief Type cast to value
     *
     * Returns value.
     * @return Value
     */
    operator T() const {
        return mV;
    }

/*
    doesn't work - masks the operator above
    operator const T& () const {
        return mT;
    }

    operator T& () {
        if (mbReadOnly) throw cvmexception(CVM_READ_ONLY_ACCESS);
        return mT;
    }
*/

    /**
     * @brief Value
     *
     * Returns value.
     * @return Value
     */
    [[nodiscard]] T val() const {
        return mV;
    }

    /**
     * @brief Reference to value
     *
     * Returns a reference to a value. Throws \ref cvmexception if proxy is read-only.
     * @return Reference to value
     */
    T& get() {
        if (mbReadOnly) throw cvmexception(CVM_READ_ONLY_ACCESS);
        return mT;
    }

    /**
     * @brief Const reference to value
     *
     * Returns const reference to a value.
     * @return Reference to value
     */
    const T& get() const {
        return mT;
    }

    /**
     * @brief Assignment operator
     * @return type_proxy&
     *
     * Assigns type_proxy. Returns a reference to \c *this.
     * @param[in] p Const reference to another proxy.
     */
    type_proxy& operator = (const type_proxy& p) {
        mT = p.mT;
        mV = p.mV;
        mbReadOnly = p.mbReadOnly;
        return *this;
    }

    /**
     * @brief Assignment operator
     * @return type_proxy&
     *
     * Assigns value. Returns a reference to \c *this. Throws \ref cvmexception if proxy is read-only.
     * @param[in] val Const reference to another value.
     */
    type_proxy& operator = (const T& val) {
        if (mbReadOnly) throw cvmexception(CVM_READ_ONLY_ACCESS);
        mT = val;
        mV = val;
        return *this;
    }

    /**
     * @brief Address operator
     * @return T*
     *
     * Returns pointer to a value. Throws \ref cvmexception if proxy is read-only.
     */
    T* operator & () {  // NOLINT
        if (mbReadOnly) throw cvmexception(CVM_READ_ONLY_ACCESS);
        return &mT;
    }

    /**
     * @brief Address operator
     * @return const T*
     *
     * Returns const pointer to a value.
     */
    const T* operator & () const {  // NOLINT
        return &mT;
    }

    /**
     * @brief Increment by
     * @return T&
     *
     * Returns a reference to a value changed. Throws \ref cvmexception if proxy is read-only.
     * @param[in] u Const reference to a value to be incremented by.
     */
    template<typename U>
    T& operator += (const U& u) {
        if (mbReadOnly) throw cvmexception(CVM_READ_ONLY_ACCESS);
        mT += T(u);
        mV += T(u);
        return mT;
    }

    /**
     * @brief Decrement by
     * @return T&
     *
     * Returns a reference to a value changed. Throws \ref cvmexception if proxy is read-only.
     * @param[in] u Const reference to a value to be decremented by.
     */
    template<typename U>
    T& operator -= (const U& u) {
        if (mbReadOnly) throw cvmexception(CVM_READ_ONLY_ACCESS);
        mT -= T(u);
        mV -= T(u);
        return mT;
    }

    /**
     * @brief Multiply by
     * @return T&
     *
     * Returns a reference to a value changed. Throws \ref cvmexception if proxy is read-only.
     * @param[in] u Const reference to a value to be multiplied by.
     */
    template<typename U>
    T& operator *= (const U& u) {
        if (mbReadOnly) throw cvmexception(CVM_READ_ONLY_ACCESS);
        mT *= T(u);
        mV *= T(u);
        return mT;
    }

    /**
     * @brief Divide by
     * @return T&
     *
     * Returns a reference to a value changed. Throws \ref cvmexception if proxy is read-only.
     * @param[in] u Const reference to a value to be divided by.
     */
    template<typename U>
    T& operator /= (const U& u) {
        if (mbReadOnly) throw cvmexception(CVM_READ_ONLY_ACCESS);
        mT /= T(u);
        mV /= T(u);
        return mT;
    }

    /**
     * @brief Addition operator
     * @return T
     *
     * Returns result of addition as value.
     * @param[in] u Const reference to a value to be added.
     */
    template<typename U>
    T operator + (const U& u) const {
        return mT + T(u);
    }

    /**
     * @brief Subtraction operator
     * @return T
     *
     * Returns result of subtraction as value.
     * @param[in] u Const reference to a value to be subtracted.
     */
    template<typename U>
    T operator - (const U& u) const {
        return mT - T(u);
    }

    /**
     * @brief Multiplication operator
     * @return T
     *
     * Returns result of mutliplication as value.
     * @param[in] u Const reference to a value to be multiplied by.
     */
    template<typename U>
    T operator * (const U& u) const {
        return mT * T(u);
    }

    /**
     * @brief Division operator
     * @return T
     *
     * Returns result of division as value.
     * @param[in] u Const reference to a value to be divided by.
     */
    template<typename U>
    T operator / (const U& u) const {
        return mT / T(u);
    }

    /**
     * @brief Addition operator
     * @return T
     *
     * Returns result of addition as value.
     * @param[in] u Const reference to proxy to be added.
     */
    T operator + (const type_proxy<T,TR>& u) const {
        return mT + u.mT;
    }

    /**
     * @brief Subtraction operator
     * @return T
     *
     * Returns result of subtraction as value.
     * @param[in] u Const reference to proxy to be subtracted.
     */
    T operator - (const type_proxy<T,TR>& u) const {
        return mT - u.mT;
    }

    /**
     * @brief Multiplication operator
     * @return T
     *
     * Returns result of mutliplication as value.
     * @param[in] u Const reference to proxy to be multiplied.
     */
    T operator * (const type_proxy<T,TR>& u) const {
        return mT * u.mT;
    }

    /**
     * @brief Division operator
     * @return T
     *
     * Returns result of division as value.
     * @param[in] u Const reference to proxy to be divided.
     */
    T operator / (const type_proxy<T,TR>& u) const {
        return mT / u.mT;
    }

    /**
     * @brief Unary minus operator
     * @return T
     *
     * Returns result of sign change as value.
     */
    T operator - () const {
        return -mT;
    }

    /**
     * @brief Equality operator
     * @return bool
     *
     * Returns true if value is equal to t, false otherwise.
     * @param[in] u Value to compare with.
     */
    template<typename U>
    bool operator == (const U& u) const {
        return mT == u;
    }

    /**
     * @brief Nonequality operator
     * @return bool
     *
     * Returns true if value is not equal to t, false otherwise.
     * @param[in] u Value to compare with.
     */
    template<typename U>
    bool operator != (const U& u) const {
        return mT != u;
    }

    /**
     * @brief Equality operator
     * @return bool
     *
     * Returns true if value is equal to t, false otherwise.
     * @param[in] t Value to compare with.
     */
    bool operator == (const type_proxy<T,TR>& t) const {
        return mT == t.mT;
    }

    /**
     * @brief Nonequality operator
     * @return bool
     *
     * Returns true if value is not equal to t, false otherwise.
     * @param[in] t Value to compare with.
     */
    bool operator != (const type_proxy<T,TR>& t) const {
        return mT != t.mT;
    }

    /**
     * @brief Real part
     * @return TR
     *
     * Returns real part of complex value as value.
     * Specialized for \c std::complex<treal> only. Link error would be received otherwise.
     */
    [[nodiscard]] TR real() const {
        return _real<T,TR>(mV);
    }

    /**
     * @brief Imaginary part
     * @return TR
     *
     * Returns imaginary part of complex value as value.
     * Specialized for \c std::complex<treal> only. Link error would be received otherwise.
     */
    [[nodiscard]] TR imag() const {
        return _imag<T,TR>(mV);
    }
};

//! Prefix version for proxy
template<typename U, typename T, typename TR>
bool operator == (const U& u, const type_proxy<T,TR>& t) {
    return u == t.val();
}

//! Prefix version for proxy
template<typename U, typename T, typename TR>
bool operator != (const U& u, const type_proxy<T,TR>& t) {
    return u != t.val();
}

//! Prefix version for proxy
template<typename T, typename TR>
inline std::complex<TR> operator + (const std::complex<TR>& u, const type_proxy<T,TR>& p) {
    return u + p.val();
}

//! Prefix version for proxy
template<typename T, typename TR>
inline std::complex<TR> operator - (const std::complex<TR>& u, const type_proxy<T,TR>& p) {
    return u - p.val();
}

//! Prefix version for proxy
template<typename T, typename TR>
inline std::complex<TR> operator * (const std::complex<TR>& u, const type_proxy<T,TR>& p) {
    return u * p.val();
}

//! Prefix version for proxy
template<typename T, typename TR>
inline std::complex<TR> operator / (const std::complex<TR>& u, const type_proxy<T,TR>& p) {
    return u / p.val();
}

//! Prefix version for proxy
template<typename U, typename T, typename TR>
inline T operator + (U u, const type_proxy<T,TR>& p) {
    return T(u) + p.val();
}

//! Prefix version for proxy
template<typename U, typename T, typename TR>
inline T operator - (U u, const type_proxy<T,TR>& p) {
    return T(u) - p.val();
}

//! Prefix version for proxy
template<typename U, typename T, typename TR>
inline T operator * (U u, const type_proxy<T,TR>& p) {
    return T(u) * p.val();
}

//! Prefix version for proxy
template<typename U, typename T, typename TR>
inline T operator / (U u, const type_proxy<T,TR>& p) {
    return T(u) / p.val();
}


//! Random numbers generator
template<typename T>
class Randomizer
{
    T mMax;  //!< maximum possible value
#if !defined(CVM_NO_DEFAULT_RANDOM_ENGINE_SUPPORTED)
    std::random_device mre;  //!< standard engine
    std::uniform_int_distribution<int> mDist;  //!< standard generator
#endif

    /**
     * @brief Private constructor
     * @see get()
     */
    Randomizer() noexcept
#if defined(CVM_NO_DEFAULT_RANDOM_ENGINE_SUPPORTED)
        : mMax(static_cast<T>(RAND_MAX)) {
        srand(static_cast<unsigned int>(time(nullptr)));
    }
#else
        : mMax(static_cast<T>((std::numeric_limits<int>::max)())),
          mre(),
          mDist(0, (std::numeric_limits<int>::max)()) {}
#endif

    /**
     * @brief Internal private routine
     * @see get()
     */
    T _get(T dFrom, T dTo) noexcept {
        const T dMin = _cvm_min<T>(dFrom, dTo);
        const T dMax = _cvm_max<T>(dFrom, dTo);
#if defined(CVM_NO_DEFAULT_RANDOM_ENGINE_SUPPORTED)
        unsigned int nr = static_cast<unsigned int>(rand());
        return dMin + static_cast<T>(nr) * (dMax - dMin) / mMax;
#else
        return dMin + static_cast<T>(mDist(mre)) * (dMax - dMin) / mMax;
#endif
    }

public:
    /**
     * @brief Destructor
     * @see get()
     */
    ~Randomizer() noexcept = default;

    /**
     * @brief Random number
     *
     * Returns random number between \c dFrom and \c dTo.
     * @param[in] dFrom Lower limit for random number to generate.
     * @param[in] dTo Upper limit for random number to generate.
     * @return T Random number as value.
     */
    static T get(T dFrom, T dTo) noexcept {
        static Randomizer r;
        return r._get(dFrom, dTo);
    }
};


/**
@brief Abstract array of numbers with increment between them. Root object for all library classes.

This abstract class encapsulates BLAS/LAPACK aware array of numbers.
It implements increment (stride) bewteen elements (default increment is 1, i.e. elements
follow each other). \c TR type stands for \ref treal and \c TC stands for
\ref tcomplex for complex number classes and \ref treal otherwise.

This class contains array-specific member
functions inherited in other classes. It can be used
as a standalone class too. It also provides STL-compatible
functions and type definitions, so itself and derived classes
can be used in the same way as \c std::vector<T>.
*/
template<typename TR, typename TC>
class basic_array
{
protected:
    tint msz;  //!< Number of elements of type TC allocated
    tint mincr;  //!< Increment (stride) between elements (default is 1, i.e. elements follow each other)

#ifdef CVM_USE_POOL_MANAGER
    TC* mpd;  //!< Data pointer
#else
    // Think of mp as a pointer to chunk (or blob) of memory. Sure, this would be nice to use
    // std::vector here but I need to align mp usage with foreign pointer fp_.
    std::shared_ptr<TC> mp;  //!< Native data pointer
    TC* mpf;  //!< Foreign data pointer
#endif

public:
    using value_type = TC;  //!< STL-specific value type definition
    using iterator = value_type*;  //!< STL-specific iterator definition
    using pointer = value_type*;  //!< STL-specific value pointer definition
    using const_iterator = const value_type*;  //!< STL-specific const iterator definition
    using const_pointer = const value_type*;  //!< STL-specific const pointer definition
    using reference = value_type&;  //!< STL-specific reference definition
    using const_reference = const value_type&;  //!< STL-specific const reference definition
    using size_type = std::size_t;  //!< STL-specific size type definition
    using difference_type = ptrdiff_t;  //!< STL-specific difference type definition
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;  //!< STL-specific const reverse iterator definition
    using reverse_iterator = std::reverse_iterator<iterator>;  //!< STL-specific reverse iterator definition

/**
@brief Default constructor

Creates zero length array. Allocates no memory.
\par Example:
\code
using namespace cvm;

iarray a;
std::cout << a.size() << std::endl;
a.resize(10);
std::cout << a.size() << std::endl;
\endcode
prints
\code
0
10
\endcode
*/
    basic_array()
      : msz(0),
        mincr(0),
#ifdef CVM_USE_POOL_MANAGER
        mpd(nullptr)
#else
        mp(),
        mpf(nullptr)
#endif
    {}

/**
@brief Constructor

Creates array of \c nSize elements of type \c TC.
Assigns zero to all elements if \c bZeroMemory is \c true.
Constructor throws \ref cvmexception
in case of non-positive size passed or memory allocation failure.
\par Example:
\code
using namespace cvm;

iarray a(5);
std::cout << a.size() << " " << a[1] << std::endl;
\endcode
prints
\code
5 0
\endcode
@param[in] nSize Number of an array  elements.
@param[in] bZeroMemory True (default) if all elements should be set to zero.
*/
    explicit basic_array(tint nSize, bool bZeroMemory = true)
      : msz(nSize), mincr(1),
#ifdef CVM_USE_POOL_MANAGER
        mpd(cvmMalloc<TC>(static_cast<size_t>(msz)))
#else
        mp(cvmMalloc<TC>(msz), ArrayDeleter<TC>()),
        mpf(nullptr)
#endif
    {
        CVM_ASSERT(this->get(), msz * sizeof(TC))
        if (bZeroMemory) cvmZeroMemory<TC>(this->get(), msz);
    }

/**
@brief Constructor

Creates array of \c nSize elements of type \c TC. This is
non-const version, it shares memory (shallow copy) with array
pointed to by \c pd parameter. Constructor throws  \ref
cvmexception in case of non-positive size passed.
@see http://cvmlib.com/faq.htm
\par Example:
\code
using namespace cvm;

int a[] = {1, 2, 3, 4};
iarray v(a, 3);
std::cout << v;
a[0] = 77;
std::cout << v;
\endcode
prints
\code
1 2 3
77 2 3
\endcode
@param[in] pd Non-const pointer to external array.
@param[in] nSize Number of an array  elements.
@param[in] nIncr Increment (distance) between elements (default is 1, i.e. elements follow each other).
*/
    basic_array(TC* pd, tint nSize, tint nIncr = 1)
      : msz(nSize), mincr(nIncr),
#ifdef CVM_USE_POOL_MANAGER
        mpd(cvmAddRef<TC>(pd))
#else
        mp(),
        mpf(pd)
#endif
    {
        _check_le(CVM_WRONGSIZE_LE, msz, tint());
        CVM_ASSERT(this->get(), msz * sizeof(TC))
    }

/**
@brief Constructor

Creates array of \c nSize elements of type \c TC. This is const version,
it allocates memory and copies elements (deep copy) from external array pointed to by \c pd parameter.
Constructor throws  \ref cvmexception
in case of non-positive size passed or memory allocation failure.
@see http://cvmlib.com/faq.htm
\par Example:
\code
using namespace cvm;

const int a[] = {1, 2, 3, 4};
iarray v(a, 3);
std::cout << v;
\endcode
prints
\code
1 2 3
\endcode
@param[in] pd Const pointer to external array.
@param[in] nSize Number of an array  elements.
@param[in] nIncr Increment (distance) between elements (default is 1, i.e. elements follow each other).
*/
    basic_array(const TC* pd, tint nSize, tint nIncr = 1)
      : msz(nSize), mincr(1),
#ifdef CVM_USE_POOL_MANAGER
        mpd(cvmMalloc<TC>(static_cast<size_t>(msz)))
#else
        mp(cvmMalloc<TC>(msz), ArrayDeleter<TC>()),
        mpf(nullptr)
#endif
    {
        _check_le(CVM_WRONGSIZE_LE, msz, tint());
        CVM_ASSERT(this->get(), msz * sizeof(TC))
        __copy<TC>(msz, pd, nIncr, this->get(), this->incr());
    }

/**
@brief Constructor

STL-style constructor accepting pointers to begin and end iterator.
Creates array of \c end-begin elements of type \c TC.
Allocates memory and copies elemets (deep copy) from external array pointed to by \c begin parameter.
Constructor throws \ref cvmexception
in case of wrong range passed or memory allocation failure.
\par Example:
\code
using namespace cvm;

const int a[] = {1, 2, 3, 4};
const iarray v(a+1, a+3);
std::cout << v << std::endl;
\endcode
prints
\code
2 3
\endcode
@param[in] begin Const pointer to external array (begin iterator).
@param[in] end Const pointer to last element of external array (end iterator). Element pointed to by \c end is \e not copied.
*/
    basic_array(const TC* begin, const TC* end)
      : msz(tint(end - begin)), mincr(1),
#ifdef CVM_USE_POOL_MANAGER
        mpd(cvmMalloc<TC>(static_cast<size_t>(msz)))
#else
        mp(cvmMalloc<TC>(msz), ArrayDeleter<TC>()),
        mpf(nullptr)
#endif
    {
        CVM_ASSERT(this->get(), msz * sizeof(TC))
        __copy<TC>(msz, begin, 1, this->get(), this->incr());
    }

/**
@brief Copy constructor

Creates deep copy of other array
\par Example:
\code
using namespace cvm;

iarray a(5);
a.set(3);
iarray b(a);
std::cout << b;
\endcode
prints
\code
3 3 3 3 3
\endcode
@param[in] a Const reference to array.
*/
    basic_array(const basic_array& a)
      : msz(a.msz), mincr(1),
#ifdef CVM_USE_POOL_MANAGER
        mpd(cvmMalloc<TC>(msz))
#else
        mp(cvmMalloc<TC>(msz), ArrayDeleter<TC>()),
        mpf(nullptr)
#endif
    {
        this->_assign(a.get(), a.incr());
        CVM_ASSERT(this->get(), msz * sizeof(TC))
    }

/**
@brief Move constructor

Implements move semantics introduced in new C++ standard.
Moves data ownership from other array to newly created object.
It's usually executed implicitly in cases like this:
\code
rvector a(b + c);
\endcode
or this
\code
rvector a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to newly created object <tt>a</tt>.
@param[in] a rvalue reference to other array.
*/
    basic_array(basic_array&& a) noexcept
      : msz(a.msz), mincr(a.mincr),
#ifdef CVM_USE_POOL_MANAGER
        mpd(nullptr)
#else
        mp(),
        mpf(nullptr)
#endif
    {
        _move(std::move(a));
        CVM_ASSERT(this->get(), msz * sizeof(TC))
    }

/**
@brief Assignment operator

Assigns array to array. Throws \ref cvmexception if sizes are different.
\par Example:
\code
using namespace cvm;

iarray a(5), b(5);
a.set(3);
b = a;
std::cout << b;
\endcode
prints
\code
3 3 3 3 3
\endcode
@param[in] a Reference to an array to be assigned.
@see assign()
@return Reference to changed calling array.
*/
    basic_array& operator = (const basic_array& a) {  // NOLINT
        if (this->_pd() != a._pd()) {
            _check_ne(CVM_SIZESMISMATCH, a.size(), this->size());
            this->_assign(a.get(), a.incr());
        }
        return *this;
    }

/**
@brief Move assignment operator

Implements move semantics introduced in new C++ standard.
Moves data ownership from other array to a calling object.
It's usually executed implicitly in cases like this:
\code
a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to a calling object <tt>a</tt>.
@param[in] a rvalue reference to other array.
*/
    basic_array& operator = (basic_array&& a) noexcept {
        _check_ne(CVM_SIZESMISMATCH, a.size(), this->size());
        _move(std::move(a));
        CVM_ASSERT(this->get(), msz * sizeof(TC))
        return *this;
    }

/**
 * @brief Destructor
 *
 * Virtual destructor to be inherited by other classes of the library.
 */
    virtual ~basic_array() {  // NOLINT
#ifdef CVM_USE_POOL_MANAGER
        cvmFree<TC>(mpd);
#endif
    }

/**
@brief Size (length) of array

Number of elements in array.
\par Example:
\code
using namespace cvm;

rvector v(3);
cmatrix m(10,20);
cout << v.size() << " " << m.size() << endl;
\endcode
prints
\code
3 200
\endcode
@return \ref tint Number of elements.
*/
    [[nodiscard]] tint size() const {
        return msz;
    }

/**
@brief Pointer to data

Returns pointer to internal data array.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

void cprint(const std::complex<double>* p, int size) { 
    for (int i = 0; i < size; ++i)
        std::cout << p[i] << " ";
    std::cout << std::endl;
}
...
iarray a(10);
scmatrix m(3);
a[2] = 1;
m(3,1) = std::complex<double>(1., 2.);
std::cout << a.get()[1] << std::endl;
cprint(m, 3);
\endcode
prints
\code
1
(0.00e+00,0.00e+00) (0.00e+00,0.00e+00) (1.00e+00,2.00e+00)
\endcode
@see basic_array::operator TC*()
@return TC* Pointer to internal data array.
*/
    TC* get() {
#ifdef CVM_USE_POOL_MANAGER
        return this->mpd;
#else
        // if foreign pointer is set, this is it, shared one otherwise
        return this->mpf == nullptr ? this->mp.get() : this->mpf;
#endif
    }

/**
@brief Const pointer to data

Returns pointer to internal data array.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

void cprint(const std::complex<double>* p, int size) { 
    for (int i = 0; i < size; ++i)
        std::cout << p[i] << " ";
    std::cout << std::endl;
}
...
iarray a(10);
scmatrix m(3);
a[2] = 1;
m(3,1) = std::complex<double>(1., 2.);
std::cout << a.get()[1] << std::endl;
cprint(m, 3);
\endcode
prints
\code
1
(0.00e+00,0.00e+00) (0.00e+00,0.00e+00) (1.00e+00,2.00e+00)
\endcode
@see basic_array::operator const TC*() const
@return const TC*
*/
    [[nodiscard]] const TC* get() const {
#ifdef CVM_USE_POOL_MANAGER
        return this->mpd;
#else
        // if foreign pointer is set, this is it, shared one otherwise
        return this->mpf == nullptr ? this->mp.get() : this->mpf;
#endif
    }

/**
@fn operator TC*()
@brief Type cast to pointer to data

Returns pointer to internal data array.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

void cprint(const std::complex<double>* p, int size) { 
    for (int i = 0; i < size; ++i)
        std::cout << p[i] << " ";
    std::cout << std::endl;
}
...
iarray a(10);
scmatrix m(3);
a[2] = 1;
m(3,1) = std::complex<double>(1., 2.);
std::cout << a.get()[1] << std::endl;
cprint(m, 3);
\endcode
prints
\code
1
(0.00e+00,0.00e+00) (0.00e+00,0.00e+00) (1.00e+00,2.00e+00)
\endcode
@see get()
@return TC* Pointer to internal data array.
*/
    operator TC* () {
        return this->get();
    }

/**
@fn operator const TC*() const
@brief Type cast to constant pointer to data

Returns constant pointer to internal data array.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

void cprint(const std::complex<double>* p, int size) { 
    for (int i = 0; i < size; ++i)
        std::cout << p[i] << " ";
    std::cout << std::endl;
}
...
iarray a(10);
scmatrix m(3);
a[2] = 1;
m(3,1) = std::complex<double>(1., 2.);
std::cout << a.get()[1] << std::endl;
cprint(m, 3);
\endcode
prints
\code
1
(0.00e+00,0.00e+00) (0.00e+00,0.00e+00) (1.00e+00,2.00e+00)
\endcode
@see get() const
@return const TC*
*/
    operator const TC* () const {
        return this->get();
    }

/**
@brief Reference to element (l-value)

Returns a reference to array's element by its index.
\par Example:
\code
using namespace cvm;

try {
    rvector v(10);
    v[1] = 1.;
    v(2) = 2.;
    std::cout << v;

    double a[] = {1., 2., 3., 4.};
    const rvector vc(a, 4);
    std::cout << vc(1) << " " << vc[2] << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1 2 0 0 0 0 0 0 0 0
1 2
\endcode
@param[in] n Index of element to return reference to.
@return TC&
*/
    TC& operator () (tint n) {
        return this->at(static_cast<size_type>(n));
    }

/**
@brief Value of element (\e not l-value)

Returns value of array's element by its index.
\par Example:
\code
using namespace cvm;

try {
    rvector v(10);
    v[1] = 1.;
    v(2) = 2.;
    std::cout << v;

    double a[] = {1., 2., 3., 4.};
    const rvector vc(a, 4);
    std::cout << vc(1) << " " << vc[2] << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1 2 0 0 0 0 0 0 0 0
1 2
\endcode
@param[in] n Index of element to return value for.
@return TC
*/
    TC operator () (tint n) const {
        return this->at(static_cast<size_type>(n));
    }

/**
@brief Reference to element (l-value)

Returns a reference to array's element by its index.
\par Example:
\code
using namespace cvm;

try {
    rvector v(10);
    v[1] = 1.;
    v(2) = 2.;
    std::cout << v;

    double a[] = {1., 2., 3., 4.};
    const rvector vc(a, 4);
    std::cout << vc(1) << " " << vc[2] << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1 2 0 0 0 0 0 0 0 0
1 2
\endcode
@param[in] n Index of element to return reference to.
@return TC&
*/
    TC& operator [] (tint n) {
        return this->at(static_cast<size_type>(n));
    }

/**
@brief Value of element (\e not l-value)

Returns value of array's element by its index.
\par Example:
\code
using namespace cvm;

try {
    rvector v(10);
    v[1] = 1.;
    v(2) = 2.;
    std::cout << v;

    double a[] = {1., 2., 3., 4.};
    const rvector vc(a, 4);
    std::cout << vc(1) << " " << vc[2] << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1 2 0 0 0 0 0 0 0 0
1 2
\endcode
@param[in] n Index of element to return value for.
@return TC&
*/
    TC operator [] (tint n) const {
        return this->at(static_cast<size_type>(n));
    }

/**
@brief Assignment from external array

Assigns \ref size() elements of external array to array.
\par Example:
\code
using namespace cvm;

const int a[] = {1, 2, 3, 4, 5, 6, 7};
iarray v(5);

v.assign(a);
std::cout << v;
\endcode
prints
\code
1 2 3 4 5
\endcode
@param[in] p Const pointer to external array to be assigned.
@see operator=()
@return Reference to changed calling array.
*/
    basic_array& assign(const TC* p) {
        this->_assign(p, 1);
        return *this;
    }

/**
@brief Sets all elements to one value

Sets all elements of an array  to be equal to given value.
\par Example:
\code
using namespace cvm;

iarray a(5);
a.set(3);
std::cout << a;
\endcode
prints
\code
3 3 3 3 3
\endcode
@param[in] x Value to set to.
@return Reference to changed calling array.
*/
    basic_array& set(TC x) {
        this->_set(x);
        return *this;
    }

/**
@brief Changes size of array

In case of size increase fills new elements with zeros.
\par Example:
\code
using namespace cvm;

try {
    const int a[] = {1, 2, 3, 4};
    iarray v(a, 3);
    std::cout << v;
    v.resize(2);
    std::cout << v;
    v.resize(4);
    std::cout << v;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1 2 3
1 2
1 2 0 0
\endcode
@param[in] nNewSize New size.
@return Reference to changed calling array.
*/
    basic_array& resize(tint nNewSize) {
        this->_resize(nNewSize);
        return *this;
    }


/**
@brief Increment between elements

Returns increment (usually 1).
\par Example:
\code
using namespace cvm;

double a[] = {1., 2., 3., 4., 5., 6.};
rvector v1 (a, 3, 2);
rvector v2(10);

std::cout << v1 << v1.incr() << std::endl;
std::cout << v2.incr() << std::endl;
\endcode
prints
\code
1 3 5
2
1
\endcode
@return \ref tint Increment value
*/
    [[nodiscard]] tint incr() const {
        return mincr;
    }

/**
@brief Index of element with the maximum module

Index of element with the maximum module. Doesn't make much sense for matrices.
\par Example:
\code
using namespace cvm;

double a[] = {3., 2., -5., -4., 5., -6.};
const rvector v(a, 4);
const rmatrix m(a, 2, 3);

std::cout << v << v.indofmax() << std::endl << std::endl;
std::cout << m << m.indofmax() << std::endl;
\endcode
prints
\code
3 2 -5 -4
3

3 -5 5
2 -4 -6
6
\endcode
@return \ref tint Increment value
*/
    [[nodiscard]] tint indofmax() const {
        return this->_indofmax();
    }

/**
@brief Index of element with the minimum module

Index of element with the minimum module. Doesn't make much sense for matrices.
\par Example:
\code
using namespace cvm;

double a[] = {3., 2., -5., 0., 0., -6.};
const rvector v(a, 4);
const rmatrix m(a, 2, 3);

std::cout << v << v.indofmin() << std::endl << std::endl;
std::cout << m << m.indofmin() << std::endl;
\endcode
prints
\code
3 2 -5 0
4

3 -5 0
2 0 -6
4
\endcode
@return \ref tint Increment value
*/
    [[nodiscard]] tint indofmin() const {
        return this->_indofmin();
    }

/**
@brief Euclidean norm

Euclidean norm of a calling array that for vectors is defined as
\f[
{\|x\|}_E=\left(\sum_{i=1}^{n} |x_i|^2\right)^{1/2}
\f]
and for matrices as
\f[
{\|A\|}_E=\left(\sum_{i=1}^{m}\sum_{j=1}^{n} |a_{ij}|^2\right)^{1/2},
\f]
\par Example:
\code
using namespace cvm;
std::cout.setf(ios::scientific | ios::showpos);
std::cout.precision(12);

double a[] = {1., 2., 3., -4., 5., -6.};
const rvector v(a, 3);
const rmatrix m(a, 2, 3);

std::cout << v << v.norm() << std::endl << std::endl;
std::cout << m << m.norm() << std::endl;
\endcode
prints
\code
+1.000000000000e+000 +2.000000000000e+000 +3.000000000000e+000
+3.741657386774e+000

+1.000000000000e+000 +3.000000000000e+000 +5.000000000000e+000
+2.000000000000e+000 -4.000000000000e+000 -6.000000000000e+000
+9.539392014169e+000
\endcode
@return \ref treal Norm value
*/
    [[nodiscard]] virtual TR norm() const {
        return __norm<TR,TC>(this->get(), this->size(), this->incr());
    }

/**
@brief Infinity norm

Infinity norm of a calling array that for vectors is defined as
\f[
{\|x\|}_\infty=\max_{i=1,\dots,n} |x_i|
\f]
and for matrices as
\f[
{\|A\|}_\infty=\max_{i=1,\dots,m} \sum_{j=1}^{n} |a_{ij}|,
\f]
\par Example:
\code
using namespace cvm;

double a[] = {1., 2., 3., -4., 5., -6.};
const rvector v(a, 3);
const rmatrix m(a, 2, 3);

std::cout << v << v.norminf() << std::endl;
std::cout << m << m.norminf() << std::endl;
\endcode
prints
\code
1 2 3
3

1 3 5
2 -4 -6
12
\endcode
@return \ref treal Norm value
*/
    [[nodiscard]] virtual TR norminf() const {
        CVM_ASSERT(this->get(), this->_indofmax() * this->incr() * sizeof(TC))
        return std::abs(this->get()[this->_indofmax() * this->incr()]);
    }

/**
@brief 1-norm

1-norm of a calling array that for vectors is defined as
\f[
   {\|x\|}_1=\sum_{i=1}^{n} |x_i|
\f]
and for matrices as
\f[
   {\|A\|}_{1}=\max_{j=1,\dots,n} \sum_{i=1}^{m} |a_{ij}|,
\f]
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(12);

double a[] = {1., 2., 3., -4., 5., -6.};
const rvector v(a, 3);
const rmatrix m(a, 2, 3);

std::cout << v << v.norm1 () << std::endl << std::endl;
std::cout << m << m.norm1 () << std::endl;
\endcode
prints
\code
+1.000000000000e+000 +2.000000000000e+000 +3.000000000000e+000
+6.000000000000e+000

+1.000000000000e+000 +3.000000000000e+000 +5.000000000000e+000
+2.000000000000e+000 -4.000000000000e+000 -6.000000000000e+000
+1.100000000000e+001
\endcode
@return \ref treal Norm value
*/
    [[nodiscard]] virtual TR norm1() const {
        TR dNorm(0);
        const tint nSize = this->size() * this->incr();
        for (tint i = 0; i < nSize; i += this->incr()) {
            dNorm += std::abs(this->get()[i]);
        }
        return dNorm;
    }

/**
@brief 2-norm

2-norm of a calling array that for vectors is defined as
\f[
   {\|x\|}_2={\|x\|}_E=\left(\sum_{i=1}^{n} |x_i|^2\right)^{1/2}
\f]
and for matrices as
\f[
   {\|A\|}_2=\max_i\sigma_i = \left(\max_{|x|=1}\,
   (Ax\cdot Ax)\right)^{1/2},
\f]
where \f$\sigma_i\f$ is \f$i\f$-th singular value
of \f$m\times n\f$ matrix \f$A,\ i=1,\dots,\min(m,n)\f$.
\par Example:
\code
using namespace cvm;
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(12);

double a[] = {1., 2., 3., -4., 5., -6.};
const rvector v(a, 3);
const rmatrix m(a, 2, 3);

std::cout << v << v.norm2 () << std::endl << std::endl;
std::cout << m << m.norm2 () << std::endl;
\endcode
prints
\code
+1.000000000000e+000 +2.000000000000e+000 +3.000000000000e+000
+3.741657386774e+000

+1.000000000000e+000 +3.000000000000e+000 +5.000000000000e+000
+2.000000000000e+000 -4.000000000000e+000 -6.000000000000e+000
+9.319612060784e+000
\endcode
@return \ref treal Norm value
*/
    [[nodiscard]] virtual TR norm2() const {
        return this->norm();
    }

//! @cond INTERNAL
    [[nodiscard]] const tint* _pincr() const {
        return &this->mincr;
    }

    [[nodiscard]] const tint* _psize() const {
        return &this->msz;
    }

    // this = this / d for real only
    void _div(TR d) {
        const TR one(1.);
        if (std::abs(d) <= basic_cvmMachMin<TR>()) {
            throw cvmexception(CVM_DIVISIONBYZERO);
        }
        this->_scalr(one / d);
    }

    // "native pointer": to be redefined in classes with non-traditional storage, like band matrices etc.
    virtual TC* _pd() {
        return this->get();
    }

    // "native pointer": to be redefined in classes with non-traditional storage, like band matrices etc.
    [[nodiscard]] virtual const TC* _pd() const {
        return this->get();
    }
//! @endcond

    //! (STL) iterator to begin
    iterator       begin()        { return this->get();}
    //! (STL) const iterator to begin
    [[nodiscard]] const_iterator begin() const  { return this->get();}
    //! (STL) iterator to end
    iterator       end()          { return this->get() + this->size();}
    //! (STL) const iterator to end
    [[nodiscard]] const_iterator end()   const  { return this->get() + this->size();}

    //! (STL) iterator to begin reversed
    reverse_iterator rbegin()             { return reverse_iterator(end());}
    //! (STL) const iterator to begin reversed
    [[nodiscard]] const_reverse_iterator rbegin() const { return const_reverse_iterator(end());}
    //! (STL) iterator to end reversed
    reverse_iterator rend()               { return reverse_iterator(begin());}
    //! (STL) const iterator to end reversed
    [[nodiscard]] const_reverse_iterator rend()   const { return const_reverse_iterator(begin());}

    //! (STL) maximum possible size of array
    [[nodiscard]] size_type max_size() const    { return size_type(-1) / sizeof(TC);}
    //! (STL) current capacity of array, equal to \ref size()
    [[nodiscard]] size_type capacity() const    { return static_cast<size_type>(this->size());}
    //! (STL) is array empty
    [[nodiscard]] bool empty() const            { return this->size() > 0;}

    //! (STL) reference to first element
    reference front()             { return *begin();}
    //! (STL) const reference to first element
    [[nodiscard]] const_reference front() const { return *begin();}
    //! (STL) reference to last element
    reference back()              { return *(end() - 1);}
    //! (STL) const reference to last element
    [[nodiscard]] const_reference back()  const { return *(end() - 1);}

    //! (STL) assigns given value to n-th element (0-based)
    void assign(size_type n, const TC& val) {
        _check_gt(CVM_INDEX_GT, n, static_cast<size_type>(this->size()));
        CVM_ASSERT(this->get(), this->size() * sizeof(TC))
        for (tint i = 0; i < (tint)n; ++i) {
            this->get()[i] = val;
        }
    }

    //! (STL) assigns begin-end iteartor range to array
    void assign(const_iterator begin, const_iterator end) {
        const tint n = end - begin;
        _check_gt(CVM_INDEX_GT, n, this->size());
        CVM_ASSERT(this->get(), this->size() * sizeof(TC))
        for (tint i = 0; i < n; ++i) {
            this->get()[i] = *(begin + i);
        }
    }

    //! (STL) clears array, deallocates memory and sets \ref size() to zero
    void clear() {
        this->_resize(0);
    }

    //! (STL) swaps array values, throws \ref cvmexception if sizes are different
    void swap(basic_array& v) {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        __swap<TC>(this->size(), this->get(), this->incr(), v.get(), v.incr());
    }

    //! (STL) returns a reference to n-th element of an array (0-based), throws \ref cvmexception if n is out of boundaries
    reference at(size_type n) {
        _check_ge(CVM_INDEX_GE, n, static_cast<size_type>(this->size()));
        CVM_ASSERT(this->get(), (n + 1) * sizeof(TC))
        return this->get()[n * this->incr()];
    }

    //! (STL) returns const reference to n-th element of an array (0-based), throws \ref cvmexception if n is out of boundaries
    [[nodiscard]] const_reference at(size_type n) const {
        _check_ge(CVM_INDEX_GE, n, static_cast<size_type>(this->size()));
        CVM_ASSERT(this->get(), (n + 1) * sizeof(TC))
        return this->get()[n * this->incr()];
    }

/**
@brief (STL) pushes new value to the end of array

Increases array's \ref size() by one,
throws \ref cvmexception in case of memory allocation failure.
It's provided for every class of the library to be compatible
with STL algorithms and methods. Since CVM doesn't
pre-allocate  memory for extra storage, these functions
<em>will require memory reallocation every time they are being executed</em>
and may slow down your application.
\par Example:
\code
using namespace cvm;

iarray a(5);
a.push_back(77);
std::cout << a;
a.pop_back();
std::cout << a;
\endcode
prints
\code
0 0 0 0 0 77
0 0 0 0 0
\endcode
@param[in] x Const reference to a value to push.
*/
    void push_back(const TC& x) {
        this->_resize(this->size() + 1);
        this->get()[this->size() - 1] = x;
    }

/**
@brief (STL) removes last element from array

Decreases array's \ref size() by one,
throws \ref cvmexception in case of memory allocation failure.
It's provided for every class of the library to be compatible
with STL algorithms and methods. Since CVM doesn't
pre-allocate  memory for extra storage, these functions
<em>will require memory reallocation every time they are being executed</em>
and may slow down your application.
\par Example:
\code
using namespace cvm;

iarray a(5);
a.push_back(77);
std::cout << a;
a.pop_back();
std::cout << a;
\endcode
prints
\code
0 0 0 0 0 77
0 0 0 0 0
\endcode
*/
    void pop_back() {
        if (this->size() > 0) this->_resize(this->size() - 1);
    }

/**
@brief (STL) inserts element to given position in array

Increases array's \ref size() by one,
throws \ref cvmexception if position is out of boundaries or in case of memory allocation failure.
Returns iterator to new element.
\b Attention - function is provided for compatibility
with STL algorithms and methods. Since CVM doesn't
pre-allocate  memory for extra storage, this function
<em>will require memory reallocation every time it's executed</em>
and may slow down your application.
@see http://www.sgi.com/tech/stl/
@see erase()
@param[in] position Where to insert
@param[in] x Reference to a value to insert
\par Example:
\code
using namespace cvm;

iarray a(5);
iarray::iterator pos = a.begin() + 2;
a.insert(pos, 77);
std::cout << a;
pos = a.begin() + 1;
a.erase(pos);
std::cout << a;
\endcode
prints
\code
0 0 77 0 0 0
0 77 0 0 0
\endcode
@return iterator
*/
    iterator insert(iterator position, const TC& x) {
        const tint n = tint(position - this->begin());
        _check_lt_gt(CVM_OUTOFRANGE_LTGT, n, tint(), this->size());
        CVM_ASSERT(this->get(), this->size() * sizeof(TC))
        this->_resize(this->size() + 1);
        for (tint i = this->size() - 1; i > n; --i) {
            this->get()[i] = this->get()[i - 1];
        }
        this->get()[n] = x;
        return iterator(this->get() + n);
    }

/**
@brief (STL) removes element from given position in array

Decreases array's \ref size() by one,
throws \ref cvmexception if position is out of boundaries or in case of memory allocation failure.
Returns iterator to removed element.
\b Attention - function is provided for compatibility
with STL algorithms and methods. Since CVM doesn't
pre-allocate  memory for extra storage, this function
<em>will require memory reallocation every time it's executed</em>
and may slow down your application.
@see http://www.sgi.com/tech/stl/
@see insert()
@param[in] position Where to erase
\par Example:
\code
using namespace cvm;

iarray a(5);
iarray::iterator pos = a.begin() + 2;
a.insert(pos, 77);
std::cout << a;
pos = a.begin() + 1;
a.erase(pos);
std::cout << a;
\endcode
prints
\code
0 0 77 0 0 0
0 77 0 0 0
\endcode
@return iterator
*/
    iterator erase(iterator position) {
        const tint n = tint(position - this->begin());
        _check_lt_gt(CVM_OUTOFRANGE_LTGT, n, tint(), this->size());

        CVM_ASSERT(this->get(), this->size() * sizeof(TC))
        for (tint i = n; i < this->size() - 1; ++i) {
            this->get()[i] = this->get()[i + 1];
        }
        if (this->size() > 0) this->_resize(this->size() - 1);
        return iterator(this->get() + n);
    }

protected:
//! @cond INTERNAL
    // internal protected constructor to be used in Matrix
    basic_array(tint sz, tint incr) noexcept
      : msz(sz), mincr(incr),
#ifdef CVM_USE_POOL_MANAGER
        mpd(nullptr)
#else
        mp(),
        mpf(nullptr)
#endif
    {}

    //! move semantics implementation for continuous arrays
    void _move(basic_array&& a) noexcept {
#ifdef CVM_USE_POOL_MANAGER
        this->_resize(a.size());
        this->_assign(a.mpd, a.incr());
#else
        if (a.mpf == nullptr) {
            if (mpf == nullptr) {
                mp = std::move(a.mp);
                a.msz = 0;
            } else {
                // *this has foreign array inside, no place to move to
                // so, this is the case where we don't even touch a, just copy its content
                this->_assign(a.mp.get(), a.incr());
            }
        } else {
            // and here we have no clue about foreign poiter life cycle, thus copying
            this->_resize(a.size());
            this->_assign(a.mpf, a.incr());
        }
#endif
    }

    // compares array elements
    bool _equals(const basic_array& a) const {  // NOLINT
        bool bRes = false;
        if (this->size() == a.size()) {
            bRes = true;
            if (this->get() != a.get()) {
                for (tint i = 0; i < this->size(); ++i) {
                    if (std::abs(this->get()[i * this->incr()] - a.get()[i * a.incr()]) > basic_cvmMachMin<TR>()) {
                        bRes = false;
                        break;
                    }
                }
            }
        }
        return bRes;
    }

    // array normalizing
    void _normalize() {
        const TR dNorm = this->norm();
        if (dNorm > basic_cvmMachMin<TR>()) {
            const TR one(1.);
            this->_scalr(one / dNorm);
        }
    }

    // this = a (no matter what)
    void _replace(const basic_array& a) {
#ifdef CVM_USE_POOL_MANAGER
        cvmFree<TC>(this->mpd);
        this->mpd = cvmMalloc<TC>(a.size());
#else
        this->mp.reset(cvmMalloc<TC>(a.size()), ArrayDeleter<TC>());
        this->mpf = nullptr;
#endif
        this->msz = a.size();
        this->mincr = 1;
        CVM_ASSERT(this->get(), ((this->size() - 1) * this->incr() + 1) * sizeof(TC))
    }

    void _resize(tint nNewSize) {
        _check_lt(CVM_WRONGSIZE_LT, nNewSize, tint());
        const bool is_empty = this->_is_empty();
        if (nNewSize != this->size() || is_empty) {
            TC* pd = cvmMalloc<TC>(nNewSize);
            if (nNewSize > this->size()) cvmZeroMemory<TC>(pd, nNewSize);
            const tint nMinSize = _cvm_min<tint>(nNewSize, this->size());
            if (nMinSize > 0 && !is_empty) {
                __copy<TC>(nMinSize, this->get(), this->incr(), pd, 1);
            }
#ifdef CVM_USE_POOL_MANAGER
            cvmFree<TC>(this->mpd);
            this->mpd = pd;
#else
            this->mp.reset(pd, ArrayDeleter<TC>());
            this->mpf = nullptr;
#endif
            this->msz = nNewSize;
            this->mincr = 1;
            CVM_ASSERT(this->get(), ((this->size() - 1) * this->incr() + 1) * sizeof(TC))
        }
    }

    [[nodiscard]] bool _is_empty() const {
#ifdef CVM_USE_POOL_MANAGER
            return this->mpd == nullptr;
#else
            return this->mpf == nullptr && this->mp.get() == nullptr;
#endif
    }

    virtual void _scalr(TR d) {
        __scal<TR,TC>(this->get(), this->size(), this->incr(), d);
    }

    // index of max module, undefined for matrices
    [[nodiscard]] virtual tint _indofmax() const {
        return __idamax<TC>(this->get(), this->size(), this->incr());
    }

    // index of min module, undefined for matrices
    [[nodiscard]] virtual tint _indofmin() const {
        return __idamin<TC>(this->get(), this->size(), this->incr());
    }

    // fills the content
    virtual void _set(TC d) {
        CVM_ASSERT(this->get(), ((this->size() - 1) * this->incr() + 1) * sizeof(TC))
        const tint nSize = this->size() * this->incr();
        for (tint i = 0; i < nSize; i += this->incr()) {
            this->get()[i] = d;
        }
    }

    virtual void _assign(const TC* pd, tint nIncr) {
        if (this->get() != pd) {
            __copy<TC>(this->size(), pd, nIncr, this->get(), this->incr());
        }
    }

    virtual void _assign_shifted(TC* pDshifted, const TC* pd, tint nSize, tint nIncr, tint) {
        if (pDshifted != pd) {
            __copy<TC>(nSize, pd, nIncr, pDshifted, this->incr());
        }
    }
//! @endcond

/**
@brief Inserts elements from input stream to array

\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    std::ofstream os;
    os.open("in.txt");
    os << 1.2 << " " << 2.3 << std::endl << 3.4;
    os.close();

    std::ifstream is("in.txt");
    rvector v(5);
    is >> v;

    std::cout << v;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.20e+000 2.30e+000 3.40e+000 0.00e+000 0.00e+000
\endcode
@param[in] is Input stream.
@param[in] aIn basic_array to fill.
@return Input stream
*/
    friend std::istream& operator >> <> (std::istream& is, basic_array& aIn);

/**
@brief Inserts elements of an array  to output stream

\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector v(3);
v(1) = tcomplex(1., 2.);
v(2) = tcomplex(3., 4.);

std::cout << v;
\endcode
prints
\code
(1.00e+000,2.00e+000) (3.00e+000,4.00e+000) (0.00e+000,0.00e+000)
\endcode
@param[in] os Output stream.
@param[in] aOut basic_array to send.
@return Output stream
*/
    friend std::ostream& operator << <> (std::ostream& os, const basic_array& aOut);
};


/**
@brief End-user class encapsulating vector of real numbers

\c TR type stands for \ref treal. Please use predefined \ref rvector class in your applications.
@see basic_array
*/
template<typename TR>
class basic_rvector : public basic_array<TR,TR>
{
    using TC = std::complex<TR>;  //!< complex number type
    using BaseArray = basic_array<TR,TR>;  //!< base class

public:
    
/**
@brief Default constructor

Creates zero size \ref rvector. No memory gets allocated.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

rvector v;
std::cout << v.size() << std::endl;

v.resize(5);
v(1) = 1.5;
std::cout << v;
\endcode
prints
\code
0
1.50e+000 0.00e+000 0.00e+000 0.00e+000 0.00e+0000
\endcode
@see resize()
*/
    basic_rvector() = default;

/**
@brief Constructor

Creates \ref rvector object of given size.
It throws \ref cvmexception in case of non-positive size passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

rvector v(5);
std::cout << v;
\endcode
prints
\code
0.00e+000 0.00e+000 0.00e+000 0.00e+000 0.00e+000
\endcode
@param[in] nSize Size of \ref rvector (must be positive).
*/
    explicit basic_rvector(tint nSize)
      : BaseArray(nSize)
    {}

#if defined(CVM_USE_INITIALIZER_LISTS)
/**
@brief Constructor

Creates \ref rvector object and fills it with values provided in the initializer list.
This constructor is available only if your compiler supports initializer lists
(GCC 4.4 and higher, MS Visual Studio 2013 and higher, Apple LLVM 5.0 and higher).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);

rvector v = { 1, -2, 3.456, 99.99 };
std::cout << v;
\endcode
prints
\code
1.000e+000 - 2.000e+000 3.456e+000 9.999e+001
\endcode
@param[in] list Initializer list as shown above.
*/
    basic_rvector(const std::initializer_list<TR>& list)
      : BaseArray(static_cast<tint>(list.size())) {
        tint i = 0;
#ifdef CVM_USE_POOL_MANAGER
        TR* p = this->mpd;
#else
        TR* p = this->mp.get();
#endif
        for (auto it = list.begin(); it != list.end(); ++it) {
            p[i++] = *it;
        }
    }
#endif

/**
@brief Constructor

Creates \ref rvector object of given size and fills it with given number.
It throws \ref cvmexception in case of non-positive size passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

rvector v(5, 1.5);
std::cout << v;
\endcode
prints
\code
1.50e+00 1.50e+00 1.50e+00 1.50e+00 1.50e+00
\endcode
@param[in] nSize Size of \ref rvector (must be positive).
@param[in] d Number to fill \ref rvector in.
*/
    basic_rvector(tint nSize, TR d)
      : BaseArray(nSize, false) {
        this->_set(d);
    }

/**
@brief Constructor

Creates \ref rvector object of given size with given increment between elements (default is 1).
It throws \ref cvmexception in case of non-positive size passed.
Unlike others, this constructor <b>does not allocate memory</b>.
It just shares memory with an array pointed to by \c pd using
distance between elements equal to \c nIncr.
It is intented to make possible the following syntax:
\code
rmatrix m(10, 20);
rvector v(20);

m[1] = v;  // assigns v to the 1st row of m
\endcode
     And for example this code...
\code
rmatrix m(10,20);
rvector vRow = m[1];
\endcode
will also call this constructor and <em>memory will be shared</em>.

If you need the code like this with memory allocation, use the following:
\code
rmatrix m(10,20);
rvector vRow(m.msize());
vRow = m[1];
\endcode

\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {7., 7., 7., 7., 7., 7., 7.,};

rvector v1 (a, 4, 2);

std::cout << v1;
v1(2) = 1.23;
std::cout << v1 << std::endl;

for (int i = 0; i < 3; i++) {
    std::cout << a[i] << " ";
}
std::cout << std::endl;

rvector v2 (a, 5);
std::cout << v2;
\endcode
prints
\code
7.00e+000 7.00e+000 7.00e+000 7.00e+000
7.00e+000 1.23e+000 7.00e+000 7.00e+000

7.00e+000 7.00e+000 1.23e+000
7.00e+000 7.00e+000 1.23e+000 7.00e+000 7.00e+000
\endcode
@see http://cvmlib.com/faq.htm
@param[in] pd Pointer to an array to share memory with.
@param[in] nSize Size of \ref rvector (must be positive).
@param[in] nIncr Increment between elements, default is 1 (one after another).
*/
    basic_rvector(TR* pd, tint nSize, tint nIncr = 1)
      : BaseArray(pd, nSize, nIncr)
    {}

/**
@brief Constructor

Creates \ref rvector of \c nSize elements with increment 1 in between. This is const version,
it allocates memory and copies every \c nIncr-th element (deep copy) from external array pointed to by \c pd parameter.
It copies \c nSize elements total.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

const double a[] = {7., 7., 7., 7., 7., 7., 7.,};

rvector v1 (a, 4, 2);

std::cout << v1;
v1(2) = 1.23;
std::cout << v1 << std::endl;

for (int i = 0; i < 3; i++) {
    std::cout << a[i] << " ";
}
std::cout << std::endl;

rvector v2 (a, 5);
std::cout << v2;
\endcode
prints
\code
7.00e+000 7.00e+000 7.00e+000 7.00e+000
7.00e+000 1.23e+000 7.00e+000 7.00e+000

7.00e+000 7.00e+000 7.00e+000
7.00e+000 7.00e+000 7.00e+000 7.00e+000 7.00e+000
\endcode
@see http://cvmlib.com/faq.htm
@param[in] pd Const pointer to external array.
@param[in] nSize Number of an array  elements.
@param[in] nIncr Increment between external array elements.
*/
    basic_rvector(const TR* pd, tint nSize, tint nIncr = 1)
      : BaseArray(pd, nSize, nIncr)
    {}


/**
@brief Copy constructor

Creates \ref rvector object of size equal to size of
vector \c v and sets every element of created vector to be equal to
appropriate element of \c v.
Constructor throws  \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4., 5., 6., 7.,};
const rvector v(a, 4, 2);
rvector vc(v);

vc(1) = 77.;
std::cout << vc;
std::cout << v;
\endcode
prints
\code
7.70e+001 3.00e+000 5.00e+000 7.00e+000
1.00e+000 3.00e+000 5.00e+000 7.00e+000
\endcode
@param[in] v Vector to copy from.
*/
    basic_rvector(const basic_rvector& v)
      : BaseArray(v.size(), false) {
        __copy<TR>(this->size(), v, v.incr(), this->get(), this->incr());
    }

/**
\copydoc basic_array::basic_array(basic_array&& a)
*/
    basic_rvector(basic_rvector&& a) noexcept
      : BaseArray(std::move(a))
    {}

/**
@brief Assignment operator

Sets every element of a calling \ref rvector to be equal to
appropriate element of a vector \c v and returns a reference to
the vector changed.
Operator throws \ref cvmexception in case of different vector sizes.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    double a[] = {1., 2., 3., 4., 5.};
    const rvector v(a, 5);
    rvector vc(5);

    vc = v;
    std::cout << vc;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.00e+000 2.00e+000 3.00e+000 4.00e+000 5.00e+000
\endcode
@param[in] v \ref rvector to assign from.
@return Reference to changed calling vector.
*/
    basic_rvector& operator = (const basic_rvector& v) {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        this->_assign(v, v.incr());
        return *this;
    }

/**
\copydoc basic_array::operator = (basic_array&& a)
*/
    basic_rvector& operator = (basic_rvector&& a)  noexcept {
        // size check is in BasicArray
        BaseArray::operator = (std::move(a));
        return *this;
    }

/**
@brief External array assignment

Sets every element of a calling vector to be equal to
every \c nIncr-th element of an array pointed to by parameter \c pd
and returns a reference to the vector changed. It's assumed that array passed is long
enough to fill calling vector.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

const double a[] = {1., 2., 3., 4., 5., 6., 7.,};
rvector v(5);
rvector v2 (4);

v.assign(a);
v2.assign(a, 2);
std::cout << v;
std::cout << v2;
\endcode
prints
\code
1.00e+000 2.00e+000 3.00e+000 4.00e+000 5.00e+000
1.00e+000 3.00e+000 5.00e+000 7.00e+000
\endcode
@param[in] pd Const pointer to external array.
@param[in] nIncr Increment between elements in external array.
@return Reference to changed calling vector.
*/
    basic_rvector& assign(const TR* pd, tint nIncr = 1) {
        this->_assign(pd, nIncr);
        return *this;
    }

/**
@brief External array assignment (to tail)

Sets every element of a calling vector, starting from \c n-th one till the end,
to be equal to every \c nIncr-th element of an array pointed to by parameter \c pd
and returns a reference to the vector changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

const double a[] = {1., 2., 3., 4., 5.};
rvector v(5);
rvector v2 (5);

v.assign(2, a);
v2.assign(3, a, 2);
std::cout << v;
std::cout << v2;
\endcode
prints
\code
0.00e+000 1.00e+000 2.00e+000 3.00e+000 4.00e+000
0.00e+000 0.00e+000 1.00e+000 3.00e+000 5.00e+000
\endcode
@param[in] n Start \ref rvector index to assign from.
@param[in] pd Const pointer to external array.
@param[in] nIncr Increment between elements in external array.
@return Reference to changed calling vector.
*/
    basic_rvector& assign(tint n, const TR* pd, tint nIncr = 1) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, n, tint(), this->size());
        this->_assign_shifted(this->get() + this->incr() * n, pd, this->size() - n, nIncr, 0);
        return *this;
    }

/**
@brief External array assignment (range)

Sets every element of a calling vector, starting from \c n-th one,
up to \c nSize total,
to be equal to every \c nIncr-th element of an array pointed to by parameter \c pd
and returns a reference to the vector changed.
If \c n+nSize goes beyond \ref rvector boundaries assignment stops at the last element.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

const double a[] = {1., 2., 3., 4., 5., 6., 7.};
rvector v(5);

v.assign(2, a, 5, 2);
std::cout << v;
v.assign(2, a, 3, 1);
std::cout << v;
\endcode
prints
\code
0.00e+000 1.00e+000 3.00e+000 5.00e+000 7.00e+000
0.00e+000 1.00e+000 2.00e+000 3.00e+000 7.00e+000
\endcode
@param[in] n Start \ref rvector index to assign from.
@param[in] pd Const pointer to external array.
@param[in] nSize Maximum number of elements to be assigned.
@param[in] nIncr Increment between elements in external array.
@return Reference to changed calling vector.
*/
    basic_rvector& assign(tint n, const TR* pd, tint nSize, tint nIncr) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, n, tint(), this->size());
        this->_assign_shifted(this->get() + this->incr() * n, pd, _cvm_min<tint>(nSize, this->size() - n), nIncr, 0);
        return *this;
    }

/**
@brief Subvector assignment

Sets every element of a calling vector's sub-vector
beginning with index \c n to a vector \c v
and returns a reference to the vector changed.
Function throws \ref cvmexception
if \c n is not positive or \c v.size()+n-1 is greater than
calling vector's size.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

rvector v1(5);
rvector v2(2);
v1.set(1.);
v2.set(2.);
v1.assign(3, v2);
std::cout << v1;
\endcode
prints
\code
1.00e+00 1.00e+00 2.00e+00 2.00e+00 1.00e+00
\endcode
@param[in] n Start \ref rvector index to assign from.
@param[in] v Const reference to vector.
@return Reference to changed calling vector.
*/
    basic_rvector& assign(tint n, const basic_rvector& v) {
        _check_gt(CVM_SIZESMISMATCH_GT, v.size() + n, this->size());
        return assign(n, v, v.size(), v.incr());
    }

/**
@brief Sets all elements to one value

Sets every element of a calling vector to be equal to
parameter \c d
and returns a reference to the vector changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

rvector v(5);
v.set(3.);
std::cout << v;
\endcode
prints
\code
3.00e+000 3.00e+000 3.00e+000 3.00e+000 3.00e+000
\endcode
@param[in] d Value to set to.
@return Reference to changed calling vector.
*/
    basic_rvector& set(TR d) {
        this->_set(d);
        return *this;
    }

/**
@brief Changes size of vector

Changes size of a calling vector to be equal to
\c nNewSize and returns a reference to the vector changed.
In case of increasing of its size, the vector
is filled up with zeroes.
Function throws \ref cvmexception
in case of negative size passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    double a[] = {1., 2., 3., 4.};
    rvector v(a, 3);
    std::cout << v;
    v.resize(2);
    std::cout << v;
    v.resize(4);
    std::cout << v;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.00e+00 2.00e+00 3.00e+00
1.00e+00 2.00e+00
1.00e+00 2.00e+00 0.00e+00 0.00e+00
\endcode
@param[in] nNewSize New size.
@return Reference to changed calling vector.
*/
    basic_rvector& resize(tint nNewSize) {
        this->_resize(nNewSize);
        return *this;
    }

/**
@brief Vector comparison

Operator compares calling vector with a vector \c v
and returns \c true if they have same sizes
and their appropriate elements differ by not more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;

double a[] = {1., 2., 3., 4.};
rvector v1 (a, 4);
rvector v2 (4);

v2 (1) = 1.; v2 (2) = 2.;
v2 (3) = 3.; v2 (4) = 4.;

cout << (v1 == v2) << endl;
\endcode
prints
\code
1
\endcode
@see operator !=()
@param[in] v \ref rvector to compare to.
@return bool Result of comparison.
*/
    bool operator == (const basic_rvector& v) const {
        return this->_equals(v);
    }

/**
@brief Vector comparison

Operator compares calling vector with a vector \c v
and returns \c true if they have different sizes
or at least one of their appropriate elements differs by more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;

double a[] = {1., 2., 3., 4.};
rvector v1 (a, 4);
rvector v2 (4);

v2 (1) = 1.; v2 (2) = 2.;
v2 (3) = 3.; v2 (4) = 4.;

cout << (v1 != v2) << endl;
\endcode
prints
\code
0
\endcode
@see operator ==()
@param[in] v \ref rvector to compare to.
@return bool Result of comparison.
*/
    bool operator != (const basic_rvector& v) const {
        return !(this->operator == (v));
    }

/**
@brief Vector replacement

Destroys calling vector, creates a new one as a copy of \c v
and returns a reference to the vector changed. Operator throws \ref cvmexception
in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    rvector v(5);
    rvector vc(3);
    v(1) = 1.;
    v(2) = 2.;
    std::cout << v << vc << std::endl;

    vc << v;
    std::cout << vc;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.00e+000 2.00e+000 0.00e+000 0.00e+000 0.00e+000
0.00e+000 0.00e+000 0.00e+000

1.00e+000 2.00e+000 0.00e+000 0.00e+000 0.00e+000
\endcode
@see operator =()
@param[in] v \ref rvector to replace by.
@return Reference to changed calling vector.
*/
    basic_rvector& operator << (const basic_rvector& v) {
        this->_replace(v);
        __copy<TR>(this->size(), v.get(), v.incr(), this->get(), this->incr());
        return *this;
    }

/**
@brief Addition operator

Creates an object of type \ref rvector as a sum of
a calling vector and a vector \c v.
Operator throws \ref cvmexception
in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    double a[] = {1., 2., 3., 4.};
    const double b[] = {3., 5., 7., 9.};
    const rvector va(a, 4);
    rvector vb(4);
    vb.assign(b);

    std::cout << va + vb;
    std::cout << va + va;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
4.00e+000 7.00e+000 1.00e+001 1.30e+001
2.00e+000 4.00e+000 6.00e+000 8.00e+000
\endcode
@see sum()
@param[in] v \ref rvector to add to a calling one.
@return Sum of vectors.
*/
    basic_rvector operator + (const basic_rvector& v) const {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        basic_rvector vSum(*this);
        __add<TR>(vSum.get(), vSum.size(), vSum.incr(), v._pd(), v.incr());
        return vSum;
    }

/**
@brief Subtraction operator

Creates an object of type \ref rvector as a difference of
a calling vector and a vector \c v.
It throws \ref cvmexception in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    double a[] = {1., 2., 3., 4.};
    const double b[] = {3., 5., 7., 9.};
    const rvector va(a, 4);
    rvector vb(4);
    vb.assign(b);

    std::cout << va - vb;
    std::cout << va - va;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-2.00e+000 -3.00e+000 -4.00e+000 -5.00e+000
0.00e+000 0.00e+000 0.00e+000 0.00e+000
\endcode
@see diff()
@param[in] v \ref rvector to subtract from calling one.
@return Difference of vectors.
*/
    basic_rvector operator - (const basic_rvector& v) const {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        basic_rvector vDiff(*this);
        __subtract<TR>(vDiff.get(), vDiff.size(), vDiff.incr(), v._pd(), v.incr());
        return vDiff;
    }

/**
@brief Sum of vectors

Assigns sum of
vectors \c v1 and \c v2 to a calling vector
and returns a reference to the vector changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    double a[] = {1., 2., 3., 4.};
    double b[] = {2., 3., 4., 5.};
    rvector va(a, 4);
    rvector vb(b, 4);
    rvector v(4);

    std::cout << v.sum(va, vb);
    std::cout << v.sum(v, va);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3.00e+00 5.00e+00 7.00e+00 9.00e+00
4.00e+00 7.00e+00 1.00e+01 1.30e+01
\endcode
@see operator +()
@param[in] v1 First \ref rvector summand.
@param[in] v2 Second \ref rvector summand.
@return Reference to changed calling vector.
*/
    basic_rvector& sum(const basic_rvector& v1, const basic_rvector& v2) {
        _check_ne(CVM_SIZESMISMATCH, v1.size(), this->size());
        _check_ne(CVM_SIZESMISMATCH, v2.size(), this->size());
        _sum<TR,TR>(this->get(), this->size(), this->incr(), v1, v1.incr(), v2, v2.incr());
        return *this;
    }

/**
@brief Difference of vectors

Assigns difference of
vectors \c v1 and \c v2 to a calling vector
and returns a reference to the vector changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    double a[] = {1., 2., 3., 4.};
    double b[] = {2., 3., 4., 5.};
    rvector va(a, 4);
    rvector vb(b, 4);
    rvector v(4);

    std::cout << v.diff(va, vb);
    std::cout << v.diff(v, va);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1.00e+00 -1.00e+00 -1.00e+00 -1.00e+00
-2.00e+00 -3.00e+00 -4.00e+00 -5.00e+00
\endcode
@see operator -()
@param[in] v1 First \ref rvector subtrahend.
@param[in] v2 Second \ref rvector subtrahend.
@return Reference to changed calling vector.
*/
    basic_rvector& diff(const basic_rvector& v1, const basic_rvector& v2) {
        _check_ne(CVM_SIZESMISMATCH, v1.size(), this->size());
        _check_ne(CVM_SIZESMISMATCH, v2.size(), this->size());
        _diff<TR,TR>(this->get(), this->size(), this->incr(), v1, v1.incr(), v2, v2.incr());
        return *this;
    }

/**
@brief Increment operator

Adds vector \c v to a calling vector
and returns a reference to the vector changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    rvector v1 (4);
    rvector v2 (4);
    v1.set(1.);
    v2.set(2.);

    v1 += v2;
    std::cout << v1;

    // well, you can do this too, but temporary object would be created
    v2 += v2;
    std::cout << v2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3.00e+00 3.00e+00 3.00e+00 3.00e+00
4.00e+00 4.00e+00 4.00e+00 4.00e+00
\endcode
@see operator +()
@see sum()
@param[in] v \ref rvector to increment by.
@return Reference to changed calling vector.
*/
    basic_rvector& operator += (const basic_rvector& v) {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        _incr<TR,TR>(this->get(), this->size(), this->incr(), v, v.incr());
        return *this;
    }

/**
@brief Decrement operator

Subtracts vector \c v from calling vector
and returns a reference to the vector changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    rvector v1 (4);
    rvector v2 (4);
    v1.set(1.);
    v2.set(2.);

    v1 -= v2;
    std::cout << v1;

    // well, you can do this too, but temporary object would be created
    v2 -= v2;
    std::cout << v2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1.00e+00 -1.00e+00 -1.00e+00 -1.00e+00
0.00e+00 0.00e+00 0.00e+00 0.00e+00
\endcode
@see operator -()
@see diff()
@param[in] v \ref rvector to decrement by.
@return Reference to changed calling vector.
*/
    basic_rvector& operator -= (const basic_rvector& v) {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        _decr<TR,TR>(this->get(), this->size(), this->incr(), v, v.incr());
        return *this;
    }

/**
@brief Unary minus operator

Creates an object of type \ref rvector as
a calling vector multiplied by \c -1.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
const rvector v(a, 4);

std::cout << - v;
\endcode
prints
\code
-1.00e+00 -2.00e+00 -3.00e+00 -4.00e+00
\endcode
@return Result object.
*/
    basic_rvector operator - () const {
        const TR mone(-1.);
        basic_rvector vRes(*this);
        vRes._scalr(mone);
        return vRes;
    }

/**
@brief Multiply by number operator

Creates an object of type \ref rvector as a product of
a calling vector and number \c dMult.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
const rvector v(a, 4);

std::cout << v * 5.;
\endcode
prints
\code
5.00e+00 1.00e+01 1.50e+01 2.00e+01
\endcode
@see operator *=()
@param[in] dMult Number to multiply by.
@return Result object.
*/
    basic_rvector operator * (TR dMult) const {
        basic_rvector vRes(*this);
        vRes._scalr(dMult);
        return vRes;
    }

/**
@brief Divide by number operator

Creates an object of type \ref rvector as a quotient of
a calling vector and number \c dDiv.
It throws \ref cvmexception if \c dDiv has absolute value equal or less
than \ref cvmMachMin() (the smallest normalized positive number).
It also throws exception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    double a[] = {1., 2., 3., 4.};
    const rvector v(a, 4);

    std::cout << v / 2.;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
5.00e-01 1.00e+00 1.50e+00 2.00e+00
\endcode
@see operator /=()
@param[in] dDiv Number to divide by.
@return Result object.
*/
    basic_rvector operator / (TR dDiv) const {
        basic_rvector vRes(*this);
        vRes._div(dDiv);
        return vRes;
    }

/**
@brief Multiply by number and assign

Multiplies calling vector by number \c dMult and returns a reference to
the vector changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

rvector v(4);
v.set(2.);
v *= 2.
std::cout << v;
\endcode
prints
\code
4.00e+00 4.00e+00 4.00e+00 4.00e+00
\endcode
@see operator *(TR) const
@param[in] dMult Number to multiply by.
@return Reference to changed calling vector.
*/
    basic_rvector& operator *= (TR dMult) {
        this->_scalr(dMult);
        return *this;
    }

/**
@brief Divide by number and assign

Divides calling vector by number \c dDiv and returns a reference to
the vector changed. It throws \ref cvmexception if \c dDiv
has absolute value equal or less than \ref cvmMachMin() (the
smallest normalized positive number).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    rvector v(4);
    v.set(3.);
    v /= 2.;
    std::cout << v;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.50e+00 1.50e+00 1.50e+00 1.50e+00
\endcode
@see operator /(TR) const
@param[in] dDiv Number to divide by.
@return Reference to changed calling vector.
*/
    basic_rvector& operator /= (TR dDiv) {
        this->_div(dDiv);
        return *this;
    }

/**
@brief Vector normalizer

Normalizes calling vector so its Euclidean \ref norm()
becomes equal to 1 if it was greater than \ref cvmMachMin() (the
smallest normalized positive number) before the call.
Does nothing otherwise.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

rvector v(4);
v(1) = 1.;
v(2) = 2.;
v(3) = 3.;
v(4) = 4.;
std::cout << v.normalize();
std::cout << v.norm() << std::endl;
\endcode
prints
\code
1.83e-01 3.65e-01 5.48e-01 7.30e-01
1.00e+00
\endcode
@return Reference to changed calling vector.
*/
    basic_rvector& normalize() {
        this->_normalize();
        return *this;
    }

/**
@brief Scalar product

Scalar product of a calling vector and a vector \c v.
It throws \ref cvmexception if the operands have different sizes.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    double a[] = {1., 2., 3., 4.};
    rvector v1(4);
    rvector v2(4);
    v1.assign(a);
    v2.assign(a);

    std::cout << v1 * v2 << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3.00e+01
\endcode
@param[in] v \ref rvector to compute scalar product with.
@return TR Scalar product as \ref treal.
*/
    TR operator * (const basic_rvector& v) const {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        return __dot<TR>(this->get(), this->size(), this->incr(), v.get(), v.incr());
    }

/**
@brief Vector-matrix product

Creates an object of type \c rvector as a product of
a calling vector and a matrix \c m.
Use \ref mult() function to avoid new object creation.
Operator throws \ref cvmexception if calling vector's size
differs from number of rows in matrix \c m.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    rvector v(2);
    rmatrix m(2, 3);
    v.set(2.);
    m.set(1.);

    std::cout << v * m;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
4.00e+00 4.00e+00 4.00e+00
\endcode
@param[in] m \ref rmatrix to multiply calling vector by.
@return Result object.
*/
    basic_rvector operator * (const basic_rmatrix<TR>& m) const {
        _check_ne(CVM_SIZESMISMATCH, m.msize(), this->size());
        basic_rvector vRes(m.nsize());
        m._multiply(vRes, *this, true);
        return vRes;
    }

/**
@brief Vector-matrix product

Sets calling vector to be equal to product of vector
\c v by matrix \c m and returns a reference to the object changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    rvector v2(2), v3(3);
    rmatrix m(2, 3);
    v2.set(2.);
    m.set(1.);

    std::cout << v3.mult(v2, m);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
4.00e+00 4.00e+00 4.00e+00
\endcode
@param[in] v \ref rvector to multiply by matrix \c m.
@param[in] m \ref rmatrix to multiply vector \c v by.
@return Reference to changed calling vector.
*/
    basic_rvector& mult(const basic_rvector& v, const basic_rmatrix<TR>& m) {
        _check_ne(CVM_SIZESMISMATCH, m.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, m.msize(), v.size());
        m._multiply(*this, v, true);
        return *this;
    }

/**
@brief Matrix-vector product

Sets calling vector to be equal to product of a matrix \c m by vector
\c v by and returns a reference to the object changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    rvector v2(2), v3(3);
    rmatrix m(2, 3);
    v3.set(2.);
    m.set(1.);

    std::cout << v2.mult(m, v3);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
6.00e+00 6.00e+00
\endcode
@param[in] m \ref rmatrix to multiply by vector \c v.
@param[in] v \ref rvector to multiply matrix \c m by.
@return Reference to changed calling vector.
*/
    basic_rvector& mult(const basic_rmatrix<TR>& m, const basic_rvector& v) {
        _check_ne(CVM_SIZESMISMATCH, m.msize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, m.nsize(), v.size());
        m._multiply(*this, v, false);
        return *this;
    }

/**
@brief Rank-1 update

Creates an object of type \ref rmatrix
as rank-1 update of a calling vector and a vector \c v.
The rank-1 update of vector-column \f$x\f$ of size \f$m\f$ and
vector-row \f$y\f$ of size \f$n\f$ is defined as \f$m\times n\f$ matrix
\f[\begin{pmatrix}
x_1 y_1 & x_1 y_2 & \cdots & x_1 y_n \\
x_2 y_1 & x_2 y_2 & \cdots & x_2 y_n \\
\hdotsfor{4} \\
x_m y_1 & x_m y_2 & \cdots & x_m y_n
\end{pmatrix} =
\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_m
\end{pmatrix}
\begin{pmatrix}
y_1 & y_2 & \cdots & y_n
\end{pmatrix}.\f]
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

rvector v1(3);
rvector v2(2);
v1.set(2.);
v2.set(2.);
std::cout << v1.rank1update(v2);
\endcode
prints
\code
4.00e+00 4.00e+00
4.00e+00 4.00e+00
4.00e+00 4.00e+00
\endcode
@param[in] v \ref rvector to compute rank-1 update with.
@return Result object.
*/
    [[nodiscard]] basic_rmatrix<TR> rank1update(const basic_rvector& v) const {
        basic_rmatrix<TR> mRes(this->size(), v.size());
        const TR one(1.);
        __ger<TR,basic_rmatrix<TR>, basic_rvector>(mRes, *this, v, one);
        return mRes;
    }

/**
@brief Linear solver

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A*x=b\f$ where parameter \c mA is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function returns a reference to the vector changed.
It also sets output parameter \c dErr to be equal
to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when  matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(12);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    double b[] = {1., 2., 3.};
    srmatrix ma(m, 3);
    rvector  vb(b, 3);
    rvector  vx(3);
    double   dErr = 0.;

    std::cout << vx.solve(ma, vb, dErr);
    std::cout << dErr << std::endl;

    std::cout << ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+8.000000000000e+00 -8.000000000000e+00 +3.000000000000e+00
+6.661338147751e-15
+0.000000000000e+00 +0.000000000000e+00 +0.000000000000e+00
\endcode
@see solve(const basic_srmatrix<TR>&,const basic_rvector<TR>&)
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] vB \ref rvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling vector.
*/
    basic_rvector& solve(const basic_srmatrix<TR>& mA, const basic_rvector& vB, TR& dErr) {
        return _solve_helper(mA, vB, dErr, 0);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A^T*x=b\f$ (which is equivalent to \f$x*A=b\f$)
where parameter \c mA is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function returns a reference to the vector changed.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to ingular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(12);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    double b[] = {1., 2., 3.};
    srmatrix ma(m, 3);
    rvector  vb(b, 3);
    rvector  vx(3);
    double   dErr = 0.;

    std::cout << vx.solve_tran(ma, vb, dErr);
    std::cout << dErr << std::endl;

    std::cout << vx * ma - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+1.000000000000e+000 +0.000000000000e+000 +0.000000000000e+000
+7.105427357601e-015
+0.000000000000e+000 +0.000000000000e+000 +0.000000000000e+000
\endcode
@see solve_tran(const basic_srmatrix<TR>&,const basic_rvector<TR>&)
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] vB \ref rvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling vector.
*/
    basic_rvector& solve_tran(const basic_srmatrix<TR>& mA, const basic_rvector& vB, TR& dErr) {
        return _solve_helper(mA, vB, dErr, 1);
    }

/**
@fn solve(const basic_srmatrix<TR>&,const basic_rvector<TR>&)
@brief Linear solver

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A*x=b\f$ where parameter \c mA is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function returns a reference to the vector changed.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when  matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(12);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    double b[] = {1., 2., 3.};
    srmatrix ma(m, 3);
    rvector  vb(b, 3);
    rvector  vx(3);

    std::cout << vx.solve(ma, vb);
    std::cout << ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+8.000000000000e+00 -8.000000000000e+00 +3.000000000000e+00
+0.000000000000e+00 +0.000000000000e+00 +0.000000000000e+00
\endcode
@see solve(const basic_srmatrix<TR>&,const basic_rvector<TR>&,TR&)
@see operator%(const basic_srmatrix<TR>&)const
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] vB \ref rvector \f$b\f$.
@return Reference to changed calling vector.
*/
    basic_rvector& solve(const basic_srmatrix<TR>& mA, const basic_rvector& vB) {
        TR dErr(0.);
        return this->solve(mA, vB, dErr);
    }

// 6.1: transpose added
/**
@fn solve_tran(const basic_srmatrix<TR>&,const basic_rvector<TR>&)
@brief Linear solver (transposed)

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A^T*x=b\f$ (which is equivalent to \f$x*A=b\f$)
where parameter \c mA is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function returns a reference to the vector changed.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(12);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    double b[] = {1., 2., 3.};
    srmatrix ma(m, 3);
    rvector  vb(b, 3);
    rvector  vx(3);

    std::cout << vx.solve_tran(ma, vb);
    std::cout << vx * ma - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+1.000000000000e+000 +0.000000000000e+000 +0.000000000000e+000
+0.000000000000e+000 +0.000000000000e+000 +0.000000000000e+000
\endcode
@see solve_tran(const basic_srmatrix<TR>&,const basic_rvector<TR>&,TR&)
@see operator/(const basic_srmatrix<TR>&)const
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] vB \ref rvector \f$b\f$.
@return Reference to changed calling vector.
*/
    basic_rvector& solve_tran(const basic_srmatrix<TR>& mA, const basic_rvector& vB) {
        TR dErr(0.);
        return this->solve_tran(mA, vB, dErr);
    }

// 6.1: MATLAB-style operator B/A returning solution of X*A=B equation
/**
@brief Linear solver operator (transposed)

Returns solution \f$x\f$ of  linear equation
\f$A^T*x=b\f$ (which is equivalent to \f$x*A=b\f$)
where parameter \c mA is square matrix \f$A\f$
and calling vector is \f$b\f$.
This operator throws \ref cvmexception in case of inappropriate sizes
of the objects or when  matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(12);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    double b[] = {1., 2., 3.};
    srmatrix ma(m, 3);
    rvector  vb(b, 3);
    rvector  vx(3);

    vx = vb / ma;

    std::cout << vx * ma - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+0.000000000000e+000 +0.000000000000e+000 +0.000000000000e+000
\endcode
@see solve_tran(const basic_srmatrix<TR>&,const basic_rvector<TR>&)
@param[in] mA \ref srmatrix \f$A\f$.
@return Result object (solution of the equation).
*/
    basic_rvector operator / (const basic_srmatrix<TR>& mA) const {
        return _operator_solve_helper(mA, 1);
    }

    // 6.1: similar to operator / this one returns solution of A*X=B equation
/**
@brief Linear solver operator

Returns solution \f$x\f$ of linear equation \f$A*x=b\f$ where parameter \c mA is square matrix \f$A\f$
and calling vector is \f$b\f$. This operator throws \ref cvmexception in case of inappropriate sizes
of the objects or when  matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(12);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    double b[] = {1., 2., 3.};
    srmatrix ma(m, 3);
    rvector  vb(b, 3);
    rvector  vx(3);

    vx = vb % ma;

    std::cout << ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+0.000000000000e+000 +0.000000000000e+000 +0.000000000000e+000
\endcode
@see solve(const basic_srmatrix<TR>&,const basic_rvector<TR>&)
@param[in] mA \ref srmatrix \f$A\f$.
@return Result object (solution of the equation).
*/
    basic_rvector operator % (const basic_srmatrix<TR>& mA) const {
        return _operator_solve_helper(mA, 0);
    }

/**
@brief LU factorization based linear solver

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A*x=b\f$ where parameter \c mA is square matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref srmatrix::low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c vB is vector \f$b\f$.
Function returns a reference to the vector changed.
It also sets output parameter \c dErr to be equal to the norm of computation error.
This function is useful when you need to solve few linear equations
of kind \f$A*x=b\f$ with the same matrix \f$A\f$ and different vectors \f$b\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time. Throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(12);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    double b1[] = {1., 2., 3.};
    double b2[] = {0., -1., -2.};
    srmatrix ma(m, 3);
    srmatrix mLU(3);
    rvector  vb1(b1, 3);
    rvector  vb2(b2, 3);
    rvector  vx1(3);
    rvector  vx2(3);
    iarray   nPivots(3);
    double   dErr = 0.;

    mLU.low_up(ma, nPivots);
    std::cout << vx1.solve_lu(ma, mLU, nPivots, vb1, dErr);
    std::cout << dErr << std::endl;
    std::cout << vx2.solve_lu(ma, mLU, nPivots, vb2, dErr);
    std::cout << dErr << std::endl;
    std::cout << ma * vx1 - vb1 << ma * vx2 - vb2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+8.000000000000e+000 -8.000000000000e+000 +3.000000000000e+000
+6.661338147751e-015
-5.000000000000e+000 +4.000000000000e+000 -1.000000000000e+000
+5.329070518201e-015
+0.000000000000e+000 +0.000000000000e+000 +0.000000000000e+000
+0.000000000000e+000 +0.000000000000e+000 +0.000000000000e+000
\endcode
@see srmatrix::low_up()
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] vB \ref rvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling vector.
*/
    basic_rvector& solve_lu(const basic_srmatrix<TR>& mA,
                            const basic_srmatrix<TR>& mLU, const tint* pPivots,
                            const basic_rvector& vB, TR& dErr) {
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), vB.size());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), mLU.msize());
        mA._solve(vB, *this, dErr, mLU, pPivots, 0);
        return *this;
    }

/**
@brief LU factorization based linear solver

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A*x=b\f$ where parameter \c mA is square matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref srmatrix::low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c vB is vector \f$b\f$.
Function returns a reference to the vector changed.
This function is useful when you need to solve few linear equations
of kind \f$A*x=b\f$ with the same matrix \f$A\f$ and different vectors \f$b\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time. Throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(12);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    double b1[] = {1., 2., 3.};
    double b2[] = {0., -1., -2.};
    srmatrix ma(m, 3);
    srmatrix mLU(3);
    rvector  vb1(b1, 3);
    rvector  vb2(b2, 3);
    rvector  vx1(3);
    rvector  vx2(3);
    iarray   nPivots(3);

    mLU.low_up(ma, nPivots);
    std::cout << vx1.solve_lu(ma, mLU, nPivots, vb1);
    std::cout << vx2.solve_lu(ma, mLU, nPivots, vb2);
    std::cout << ma * vx1 - vb1 << ma * vx2 - vb2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+8.000000000000e+000 -8.000000000000e+000 +3.000000000000e+000
-5.000000000000e+000 +4.000000000000e+000 -1.000000000000e+000
+0.000000000000e+000 +0.000000000000e+000 +0.000000000000e+000
+0.000000000000e+000 +0.000000000000e+000 +0.000000000000e+000
\endcode
@see srmatrix::low_up()
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] vB \ref rvector \f$b\f$.
@return Reference to changed calling vector.
*/
    basic_rvector& solve_lu(const basic_srmatrix<TR>& mA,
                            const basic_srmatrix<TR>& mLU, const tint* pPivots,
                            const basic_rvector& vB) {
        TR dErr(0.);
        return this->solve_lu(mA, mLU, pPivots, vB, dErr);
    }

/**
@brief Overdetermined or underdetermined linear solver

Solves overdetermined or underdetermined linear system
\f[
A*x=b
\f]
for \f$m\times n\f$ matrix \f$A\f$ (or transposed one) where
\f$b\f$ is a vector of length \f$k\f$
and \f$k=m\f$ in non-transposed case and \f$k=n\f$ otherwise.
The algorithm uses QR or LQ factorization of \f$A\f$.
It is assumed that \f$A\f$ has full rank, infinity returned otherwise.
Internally function uses \c DGELS LAPACK routines.
If \f$m>n\f$ and \c transpose=false or \f$m<n\f$ and \c transpose=true, then
the system is overdetermined, thus the algorithm tries to find the least squares solution \f$x\f$
of the problem
\f[
\|A*x-b\|_2\to\min\quad\text{or}\quad\|A^H*x-b\|_2\to\min\
\f]
respectively. Real number \c dErr returns residual sum of squares.
The system is underdetermined otherwise, and the algorithm finds its minimum norm solution.
In this case \c bErr is set to zero. In both cases the solution computed
satisfies \f$\newcommand{\pinv}{\operatorname{pinv}} x=\pinv(A)*b\f$, but this algorithm is faster than pseudo inversion.
Function sets calling object to be the solution and returns a reference to it.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix a(7, 5);
rvector b(7), bt(5);
treal dErr;
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bt.randomize(-10., 10.);

rvector x(5);
x.gels(false, a, b, dErr);
cvm::rvector xt(7);
xt.gels(true, a, bt, dErr);
std::cout << (a.pinv()*b - x).norm() << std::endl;
std::cout << (~a.pinv()*bt - xt).norm() << std::endl;
\endcode
prints
\code
+5.1347815e-016
+1.1752774e-015
\endcode
@see rmatrix::pinv()
@param[in] transpose True to compute for transposed matrix \f$A\f$.
@param[in] mA \ref rmatrix \f$A\f$.
@param[in] vB \ref rvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling vector.
*/
    basic_rvector& gels(bool transpose,
                        const basic_rmatrix<TR>& mA, const basic_rvector& vB,
                        TR& dErr) {
        _check_ne(CVM_SIZESMISMATCH, vB.size(), transpose ? mA.nsize() : mA.msize());
        _check_ne(CVM_SIZESMISMATCH, this->size(), transpose ? mA.msize() : mA.nsize());
        basic_rmatrix<TR> mA2(mA);  // this algorithm overrides A
        basic_rmatrix<TR> mB(vB, vB.size(), 1);
        basic_rmatrix<TR> mX;
        basic_rvector vErr(1);
        __gels(transpose, mA2, mB, mX, vErr);
        dErr = vErr(0);
        *this = mX(0);
        return *this;
    }

/**
@brief Linear least squares problem

Computes minimum-norm solution to linear least squares problem
\f[
\|A*x-b\|_2\to\min
\f]
using complete orthogonal factorization of \f$m\times n\f$ matrix \f$A\f$.
Here \f$b\f$ is a vector of length \f$m\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c DGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function sets calling object to be the solution and returns a reference to it.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;

rmatrix a(4, 5);
rvector b(4);
a.randomize(-10., 10.);
b.randomize(-10., 10.);
rvector x(5);
tint rank;

x.gelsy(a, b, rank);
std::cout << (a*x - b).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+2.1326688e-015
+4 +4
\endcode
@see gelss()
@see gelsd()
@see rmatrix::gelsy()
@see rmatrix::rank()
@param[in] mA \ref rmatrix \f$A\f$.
@param[in] vB \ref rvector \f$b\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Reference to changed calling vector.
*/
    basic_rvector& gelsy(const basic_rmatrix<TR>& mA,
                         const basic_rvector& vB, tint& rank,
                         TR tol = basic_cvmMachSp<TR>()) {
        _check_ne(CVM_SIZESMISMATCH, vB.size(), mA.msize());
        _check_ne(CVM_SIZESMISMATCH, this->size(), mA.nsize());
        basic_rmatrix<TR> mA2(mA);  // this algorithm overrides A
        basic_rmatrix<TR> mB(vB, vB.size(), 1);
        basic_rmatrix<TR> mX;
        __gelsy(mA2, mB, mX, tol, rank);
        *this = mX(0);
        return *this;
    }

/**
@brief Linear least squares problem

Computes minimum-norm solution to linear least squares problem
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ matrix \f$A\f$.
Here \f$b\f$ is a vector of length \f$m\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
This function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
Internally function uses \c DGELSS LAPACK routines, see more details
about the algorithm in that routine's documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function sets calling object to be the solution and returns a reference to it.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;

rmatrix a(4, 5);
rvector b(4);
a.randomize(-10., 10.);
b.randomize(-10., 10.);
rvector sv(4);
rvector x(5);
tint rank;

x.gelss(a, b, sv, rank);
std::cout << (a*x - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+7.7937340e-015
+1.2338969e-014
+4 +4
\endcode
@see gelsy()
@see gelsd()
@see rmatrix::gelsy()
@see rmatrix::rank()
@param[in] mA \ref rmatrix \f$A\f$.
@param[in] vB \ref rvector \f$b\f$.
@param[out] sv Singular values of a matrix \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Reference to changed calling vector.
*/
    basic_rvector& gelss(const basic_rmatrix<TR>& mA,
                         const basic_rvector& vB, basic_rvector<TR>& sv,
                         tint& rank, TR tol = basic_cvmMachSp<TR>()) {
        _gels_sd(true, mA, vB, sv, rank, tol);
        return *this;
    }

/**
@brief Linear least squares problem

Computes minimum-norm solution to linear least squares problem
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ matrix \f$A\f$
and divide and conquer method.
Here \f$b\f$ is a vector of length \f$m\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
This function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
Internally function uses \c DGELSD LAPACK routines, see more details
about the algorithm in that routine's documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function sets calling object to be the solution and returns a reference to it.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;

rmatrix a(4, 5);
rvector b(4);
a.randomize(-10., 10.);
b.randomize(-10., 10.);
rvector sv(4);
rvector x(5);
tint rank;

x.gelsd(a, b, sv, rank);
std::cout << (a*x - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+7.8441794e-015
+5.1021966e-015
+4 +4
\endcode
@see gelss()
@see gelsy()
@see rmatrix::gelsy()
@see rmatrix::rank()
@param[in] mA \ref rmatrix \f$A\f$.
@param[in] vB \ref rvector \f$b\f$.
@param[out] sv Singular values of a matrix \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Reference to changed calling vector.
*/
    basic_rvector& gelsd(const basic_rmatrix<TR>& mA,
                         const basic_rvector& vB, basic_rvector<TR>& sv,
                         tint& rank, TR tol = basic_cvmMachSp<TR>()) {
        _gels_sd(false, mA, vB, sv, rank, tol);
        return *this;
    }

/**
@brief Singular value decomposition

Sets calling vector to be equal to singular values
\f[
\sigma_1\ge\sigma_2\ge\dots\ge\sigma_{\min(m,n)}\ge 0
\f]
of \f$m\times n\f$ real matrix \f$A\f$ (parameter \c mA).
These values are the main diagonal of a matrix \f$\Sigma\f$ of the singular value decomposition
\f[
A=U\Sigma V^H
\f]
where \f$U\f$ and \f$V\f$ are orthogonal for real \f$A\f$ and unitary for complex \f$A\f$.
\f$V^H\f$ is transposed \f$V\f$ for real one and Hermitian conjugated \f$V\f$ for complex one.
First \f$\min(m, n)\f$ columns of matrices \f$U\f$ and \f$V\f$ are left and right singular
vectors of \f$A\f$ respectively. Singular values and singular vectors satisfy
\f[
Av_i=\sigma_i u_i\ \ \text{ and }\ \ A^Hu_i=\sigma_i v_i
\f]
where \f$u_i\f$ and \f$v_i\f$ are \f$i\f$-th columns of \f$U\f$ and \f$V\f$ respectively.
Function returns a reference to the object it changes and throws \ref cvmexception
in case of inappropriate calling object size (it must be equal to \f$\min(m,n)\f$) or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(10);

try {
    double m[] = {1., -1., 1., 2., -2., 1.,
                  3., -2., 1., 0., -2., 1.};
    rmatrix mA(m,4,3);
    rmatrix mSigma(4,3);
    rvector v(3);
    srmatrix mU(4), mVH(3);

    v.svd(mA, mU, mVH);
    mSigma.diag(0) = v;

    std::cout << mU << std::endl;
    std::cout << mVH << std::endl;
    std::cout << mSigma << std::endl;

    std::cout << (mA * ~mVH - mU * mSigma).norm() << std::endl;
    std::cout << (~mA * mU - ~(mSigma * mVH)).norm() << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-4.8425643615e-01 +1.9516809011e-01 +1.1506232201e-02 -8.5280286542e-01
+2.1685987119e-01 -3.4107922671e-01 -8.8948423927e-01 -2.1320071636e-01
+6.6237057295e-01 +7.1553688692e-01 -6.1787070600e-02 -2.1320071636e-01
-5.2889765022e-01 +5.7756501033e-01 -4.5262319054e-01 +4.2640143271e-01

-2.2124855498e-01 +8.5354150454e-01 -4.7171599183e-01
+9.5937301747e-01 +1.0365951763e-01 -2.6240830353e-01
-1.7507852602e-01 -5.1060905244e-01 -8.4179920723e-01

+4.9561500411e+00 +0.0000000000e+00 +0.0000000000e+00
+0.0000000000e+00 +2.5088408581e+00 +0.0000000000e+00
+0.0000000000e+00 +0.0000000000e+00 +3.7721919242e-01
+0.0000000000e+00 +0.0000000000e+00 +0.0000000000e+00

+1.3710111285e-15
+2.4829995848e-15
\endcode
@param[in] mA \ref rmatrix \f$A\f$.
@return Reference to changed calling vector.
*/
    basic_rvector& svd(const basic_rmatrix<TR>& mA) {
        mA._svd(*this, nullptr, nullptr);
        return *this;
    }

/**
@brief Singular value decomposition

Sets calling vector to be equal to singular values
\f[
\sigma_1\ge\sigma_2\ge\dots\ge\sigma_{\min(m,n)}\ge 0
\f]
of \f$m\times n\f$ complex matrix \f$A\f$ (parameter \c mA).
These values are the main diagonal of a matrix \f$\Sigma\f$ of the singular value decomposition
\f[
A=U\Sigma V^H
\f]
where \f$U\f$ and \f$V\f$ are orthogonal for real \f$A\f$ and unitary for complex \f$A\f$.
\f$V^H\f$ is transposed \f$V\f$ for real one and Hermitian conjugated \f$V\f$ for complex one.
First \f$\min(m, n)\f$ columns of matrices \f$U\f$ and \f$V\f$ are left and right singular
vectors of \f$A\f$ respectively. Singular values and singular vectors satisfy
\f[
Av_i=\sigma_i u_i\ \ \text{ and }\ \ A^Hu_i=\sigma_i v_i
\f]
where \f$u_i\f$ and \f$v_i\f$ are \f$i\f$-th columns of \f$U\f$ and \f$V\f$ respectively.
Function returns a reference to the object it changes and throws \ref cvmexception
in case of inappropriate calling object size (it must be equal to \f$\min(m,n)\f$) or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(10);

try {
    double m[] = {1., -1., 1., 2., -2., 1.,
                  3., -2., 1., 0., -2., 1.};
    rmatrix mA(m,4,3);
    rmatrix mSigma(4,3);
    rvector v(3);
    srmatrix mU(4), mVH(3);

    v.svd(mA, mU, mVH);
    mSigma.diag(0) = v;

    std::cout << mU << std::endl;
    std::cout << mVH << std::endl;
    std::cout << mSigma << std::endl;

    std::cout << (mA * ~mVH - mU * mSigma).norm() << std::endl;
    std::cout << (~mA * mU - ~(mSigma * mVH)).norm() << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-4.8425643615e-01 +1.9516809011e-01 +1.1506232201e-02 -8.5280286542e-01
+2.1685987119e-01 -3.4107922671e-01 -8.8948423927e-01 -2.1320071636e-01
+6.6237057295e-01 +7.1553688692e-01 -6.1787070600e-02 -2.1320071636e-01
-5.2889765022e-01 +5.7756501033e-01 -4.5262319054e-01 +4.2640143271e-01

-2.2124855498e-01 +8.5354150454e-01 -4.7171599183e-01
+9.5937301747e-01 +1.0365951763e-01 -2.6240830353e-01
-1.7507852602e-01 -5.1060905244e-01 -8.4179920723e-01

+4.9561500411e+00 +0.0000000000e+00 +0.0000000000e+00
+0.0000000000e+00 +2.5088408581e+00 +0.0000000000e+00
+0.0000000000e+00 +0.0000000000e+00 +3.7721919242e-01
+0.0000000000e+00 +0.0000000000e+00 +0.0000000000e+00

+1.3710111285e-15
+2.4829995848e-15
\endcode
@param[in] mA \ref cmatrix \f$A\f$.
@return Reference to changed calling vector.
*/
    basic_rvector& svd(const basic_cmatrix<TR,TC>& mA) {
        mA._svd(*this, nullptr, nullptr);
        return *this;
    }

/**
@brief Singular value decomposition

Sets calling vector to be equal to singular values
\f[
\sigma_1\ge\sigma_2\ge\dots\ge\sigma_{\min(m,n)}\ge 0
\f]
of \f$m\times n\f$ real matrix \f$A\f$ (parameter \c mA).
These values are the main diagonal of a matrix \f$\Sigma\f$ of the singular value decomposition
\f[
A=U\Sigma V^H
\f]
where \f$U\f$ and \f$V\f$ are orthogonal for real \f$A\f$ and unitary for complex \f$A\f$.
\f$V^H\f$ is transposed \f$V\f$ for real one and Hermitian conjugated \f$V\f$ for complex one.
First \f$\min(m, n)\f$ columns of matrices \f$U\f$ and \f$V\f$ are left and right singular
vectors of \f$A\f$ respectively. Singular values and singular vectors satisfy
\f[
Av_i=\sigma_i u_i\ \ \text{ and }\ \ A^Hu_i=\sigma_i v_i
\f]
where \f$u_i\f$ and \f$v_i\f$ are \f$i\f$-th columns of \f$U\f$ and \f$V\f$ respectively.
Function sets output parameter \c mU to be equal to square matrix \f$U\f$ of size \f$m\times m\f$ and
\c mVH to be equal to square matrix \f$V^H\f$ of size \f$n\times n\f$.
Function returns a reference to the object it changes and throws \ref cvmexception
in case of inappropriate calling object size (it must be equal to \f$\min(m,n)\f$), matrix \c mU size
(must be \f$m\times m\f$), matrix \c mVH size (must be \f$n\times n\f$) or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(10);

try {
    double m[] = {1., -1., 1., 2., -2., 1.,
                  3., -2., 1., 0., -2., 1.};
    rmatrix mA(m,4,3);
    rmatrix mSigma(4,3);
    rvector v(3);
    srmatrix mU(4), mVH(3);

    v.svd(mA, mU, mVH);
    mSigma.diag(0) = v;

    std::cout << mU << std::endl;
    std::cout << mVH << std::endl;
    std::cout << mSigma << std::endl;

    std::cout << (mA * ~mVH - mU * mSigma).norm() << std::endl;
    std::cout << (~mA * mU - ~(mSigma * mVH)).norm() << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-4.8425643615e-01 +1.9516809011e-01 +1.1506232201e-02 -8.5280286542e-01
+2.1685987119e-01 -3.4107922671e-01 -8.8948423927e-01 -2.1320071636e-01
+6.6237057295e-01 +7.1553688692e-01 -6.1787070600e-02 -2.1320071636e-01
-5.2889765022e-01 +5.7756501033e-01 -4.5262319054e-01 +4.2640143271e-01

-2.2124855498e-01 +8.5354150454e-01 -4.7171599183e-01
+9.5937301747e-01 +1.0365951763e-01 -2.6240830353e-01
-1.7507852602e-01 -5.1060905244e-01 -8.4179920723e-01

+4.9561500411e+00 +0.0000000000e+00 +0.0000000000e+00
+0.0000000000e+00 +2.5088408581e+00 +0.0000000000e+00
+0.0000000000e+00 +0.0000000000e+00 +3.7721919242e-01
+0.0000000000e+00 +0.0000000000e+00 +0.0000000000e+00

+1.3710111285e-15
+2.4829995848e-15
\endcode
@param[in] mA \ref rmatrix \f$A\f$.
@param[out] mU \ref srmatrix \f$U\f$.
@param[out] mVH \ref srmatrix \f$V^H\f$.
@return Reference to changed calling vector.
*/
    basic_rvector& svd(const basic_rmatrix<TR>& mA, basic_srmatrix<TR>& mU,
                       basic_srmatrix<TR>& mVH) {
        mA._svd(*this, &mU, &mVH);
        return *this;
    }

/**
@brief Singular value decomposition

Sets calling vector to be equal to singular values
\f[
\sigma_1\ge\sigma_2\ge\dots\ge\sigma_{\min(m,n)}\ge 0
\f]
of \f$m\times n\f$ complex matrix \f$A\f$ (parameter \c mA).
These values are the main diagonal of a matrix \f$\Sigma\f$ of the singular value decomposition
\f[
A=U\Sigma V^H
\f]
where \f$U\f$ and \f$V\f$ are orthogonal for real \f$A\f$ and unitary for complex \f$A\f$.
\f$V^H\f$ is transposed \f$V\f$ for real one and Hermitian conjugated \f$V\f$ for complex one.
First \f$\min(m, n)\f$ columns of matrices \f$U\f$ and \f$V\f$ are left and right singular
vectors of \f$A\f$ respectively. Singular values and singular vectors satisfy
\f[
Av_i=\sigma_i u_i\ \ \text{ and }\ \ A^Hu_i=\sigma_i v_i
\f]
where \f$u_i\f$ and \f$v_i\f$ are \f$i\f$-th columns of \f$U\f$ and \f$V\f$ respectively.
Function sets output parameter \c mU to be equal to square matrix \f$U\f$ of size \f$m\times m\f$ and
\c mVH to be equal to square matrix \f$V^H\f$ of size \f$n\times n\f$.
Function returns a reference to the object it changes and throws \ref cvmexception
in case of inappropriate calling object size (it must be equal to \f$\min(m,n)\f$), matrix \c mU size
(must be \f$m\times m\f$), matrix \c mVH size (must be \f$n\times n\f$) or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(10);

try {
    double m[] = {1., -1., 1., 2., -2., 1.,
                  3., -2., 1., 0., -2., 1.};
    rmatrix mA(m,4,3);
    rmatrix mSigma(4,3);
    rvector v(3);
    srmatrix mU(4), mVH(3);

    v.svd(mA, mU, mVH);
    mSigma.diag(0) = v;

    std::cout << mU << std::endl;
    std::cout << mVH << std::endl;
    std::cout << mSigma << std::endl;

    std::cout << (mA * ~mVH - mU * mSigma).norm() << std::endl;
    std::cout << (~mA * mU - ~(mSigma * mVH)).norm() << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-4.8425643615e-01 +1.9516809011e-01 +1.1506232201e-02 -8.5280286542e-01
+2.1685987119e-01 -3.4107922671e-01 -8.8948423927e-01 -2.1320071636e-01
+6.6237057295e-01 +7.1553688692e-01 -6.1787070600e-02 -2.1320071636e-01
-5.2889765022e-01 +5.7756501033e-01 -4.5262319054e-01 +4.2640143271e-01

-2.2124855498e-01 +8.5354150454e-01 -4.7171599183e-01
+9.5937301747e-01 +1.0365951763e-01 -2.6240830353e-01
-1.7507852602e-01 -5.1060905244e-01 -8.4179920723e-01

+4.9561500411e+00 +0.0000000000e+00 +0.0000000000e+00
+0.0000000000e+00 +2.5088408581e+00 +0.0000000000e+00
+0.0000000000e+00 +0.0000000000e+00 +3.7721919242e-01
+0.0000000000e+00 +0.0000000000e+00 +0.0000000000e+00

+1.3710111285e-15
+2.4829995848e-15
\endcode
@param[in] mA \ref cmatrix \f$A\f$.
@param[out] mU \ref scmatrix \f$U\f$.
@param[out] mVH \ref scmatrix \f$V^H\f$.
@return Reference to changed calling vector.
*/
    basic_rvector& svd(const basic_cmatrix<TR,TC>& mA, basic_scmatrix<TR,TC>& mU,
                       basic_scmatrix<TR,TC>& mVH) {
        mA._svd(*this, &mU, &mVH);
        return *this;
    }

// we don't use _eig here since this is the special case - symmetric matrix
/**
@brief Eigenvalues

Solves symmetric eigenvalue problem and sets calling vector to be equal to eigenvalues
of symmetric matrix \c mA.
The symmetric eigenvalue problem is defined as follows: given symmetric
or Hermitian matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
All \f$n\f$ eigenvalues are real not only for real
symmetric but also for complex Hermitian matrices \f$A\f$,
and there exists an orthogonal system of \f$n\f$ eigenvectors.
If \f$A\f$ is symmetric or Hermitian positive-definite matrix, all eigenvalues are positive.
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);

try {
    srsmatrix m(3);
    srmatrix me(3);
    rvector v(3);
    m.randomize(1., 3.);

    v.eig(m, me);
    std::cout << v;

    std::cout << m * me(1) - me(1) * v(1);
    std::cout << m * me(2) - me(2) * v(2);
    std::cout << m * me(3) - me(3) * v(3);
    std::cout << me(1) * me(2) << std::endl;  // orthogonality check

    schmatrix mc(3);
    scmatrix mce(3);
    mc.randomize_real(1., 3.);
    mc.randomize_imag(1., 3.);

    v.eig(mc, mce);
    std::cout << v;

    std::cout << mc * mce(1) - mce(1) * v(1);
    std::cout << mc * mce(2) - mce(2) * v(2);
    std::cout << mc * mce(3) - mce(3) * v(3);
    std::cout << mce(1) % mce(2) << std::endl;  // orthogonality check
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-9.360e-01 +3.535e-01 +6.376e+00
-4.441e-16 -5.551e-16 -6.106e-16
+3.331e-16 +1.145e-16 +1.110e-16
-4.441e-16 +0.000e+00 -4.441e-16
+2.060e-17
-3.274e+00 +9.710e-01 +8.209e+00
(-4.441e-16,-1.221e-15) (-1.443e-15,-4.441e-16) (-8.882e-16,+4.683e-16)
(-5.551e-16,-2.776e-16) (+0.000e+00,-4.025e-16) (+6.661e-16,-2.461e-17)
(-5.551e-16,+0.000e+00) (+4.441e-16,-4.441e-16) (+0.000e+00,+3.896e-16)
(+1.608e-16,-2.261e-17)
\endcode
@see cvector::eig()
@param[in] mA \ref srsmatrix \f$A\f$.
@return Reference to changed calling vector.
*/
    basic_rvector& eig(const basic_srsmatrix<TR>& mA) {
        _check_ne(CVM_SIZESMISMATCH, this->size(), mA.nsize());
        __eig<basic_rvector, basic_srsmatrix<TR>, basic_srmatrix<TR>> (*this, mA, nullptr, true);
        return *this;
    }

/**
@brief Eigenvalues

Solves symmetric eigenvalue problem and sets calling vector to be equal to eigenvalues
of symmetric matrix \c mA.
The symmetric eigenvalue problem is defined as follows: given symmetric
or Hermitian matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
All \f$n\f$ eigenvalues are real not only for real
symmetric but also for complex Hermitian matrices \f$A\f$,
and there exists an orthogonal system of \f$n\f$ eigenvectors.
If \f$A\f$ is symmetric or Hermitian positive-definite matrix, all eigenvalues are positive.
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
It sets output parameter \c mEigVect to be equal to square matrix containing eigenvectors as columns.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);

try {
    srsmatrix m(3);
    srmatrix me(3);
    rvector v(3);
    m.randomize(1., 3.);

    v.eig(m, me);
    std::cout << v;

    std::cout << m * me(1) - me(1) * v(1);
    std::cout << m * me(2) - me(2) * v(2);
    std::cout << m * me(3) - me(3) * v(3);
    std::cout << me(1) * me(2) << std::endl;  // orthogonality check

    schmatrix mc(3);
    scmatrix mce(3);
    mc.randomize_real(1., 3.);
    mc.randomize_imag(1., 3.);

    v.eig(mc, mce);
    std::cout << v;

    std::cout << mc * mce(1) - mce(1) * v(1);
    std::cout << mc * mce(2) - mce(2) * v(2);
    std::cout << mc * mce(3) - mce(3) * v(3);
    std::cout << mce(1) % mce(2) << std::endl;  // orthogonality check
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-9.360e-01 +3.535e-01 +6.376e+00
-4.441e-16 -5.551e-16 -6.106e-16
+3.331e-16 +1.145e-16 +1.110e-16
-4.441e-16 +0.000e+00 -4.441e-16
+2.060e-17
-3.274e+00 +9.710e-01 +8.209e+00
(-4.441e-16,-1.221e-15) (-1.443e-15,-4.441e-16) (-8.882e-16,+4.683e-16)
(-5.551e-16,-2.776e-16) (+0.000e+00,-4.025e-16) (+6.661e-16,-2.461e-17)
(-5.551e-16,+0.000e+00) (+4.441e-16,-4.441e-16) (+0.000e+00,+3.896e-16)
(+1.608e-16,-2.261e-17)
\endcode
@see cvector::eig()
@param[in] mA \ref srsmatrix \f$A\f$.
@param[out] mEigVect \ref srmatrix of eigenvectors (as columns).
@return Reference to changed calling vector.
*/
    basic_rvector& eig(const basic_srsmatrix<TR>& mA,
                       basic_srmatrix<TR>& mEigVect) {
        _check_ne(CVM_SIZESMISMATCH, this->size(), mA.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->size(), mEigVect.nsize());
        __eig<basic_rvector, basic_srsmatrix<TR>, basic_srmatrix<TR>> (*this, mA, &mEigVect, true);
        return *this;
    }

// we don't use _eig here since this is the special case - Hermitian matrix
/**
@brief Eigenvalues

Solves symmetric eigenvalue problem and sets calling vector to be equal to eigenvalues
of Hermitian matrix \c mA.
The symmetric eigenvalue problem is defined as follows: given symmetric
or Hermitian matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
All \f$n\f$ eigenvalues are real not only for real
symmetric but also for complex Hermitian matrices \f$A\f$,
and there exists an orthogonal system of \f$n\f$ eigenvectors.
If \f$A\f$ is symmetric or Hermitian positive-definite matrix, all eigenvalues are positive.
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);

try {
    srsmatrix m(3);
    srmatrix me(3);
    rvector v(3);
    m.randomize(1., 3.);

    v.eig(m, me);
    std::cout << v;

    std::cout << m * me(1) - me(1) * v(1);
    std::cout << m * me(2) - me(2) * v(2);
    std::cout << m * me(3) - me(3) * v(3);
    std::cout << me(1) * me(2) << std::endl;  // orthogonality check

    schmatrix mc(3);
    scmatrix mce(3);
    mc.randomize_real(1., 3.);
    mc.randomize_imag(1., 3.);

    v.eig(mc, mce);
    std::cout << v;

    std::cout << mc * mce(1) - mce(1) * v(1);
    std::cout << mc * mce(2) - mce(2) * v(2);
    std::cout << mc * mce(3) - mce(3) * v(3);
    std::cout << mce(1) % mce(2) << std::endl;  // orthogonality check
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-9.360e-01 +3.535e-01 +6.376e+00
-4.441e-16 -5.551e-16 -6.106e-16
+3.331e-16 +1.145e-16 +1.110e-16
-4.441e-16 +0.000e+00 -4.441e-16
+2.060e-17
-3.274e+00 +9.710e-01 +8.209e+00
(-4.441e-16,-1.221e-15) (-1.443e-15,-4.441e-16) (-8.882e-16,+4.683e-16)
(-5.551e-16,-2.776e-16) (+0.000e+00,-4.025e-16) (+6.661e-16,-2.461e-17)
(-5.551e-16,+0.000e+00) (+4.441e-16,-4.441e-16) (+0.000e+00,+3.896e-16)
(+1.608e-16,-2.261e-17)
\endcode
@see cvector::eig()
@param[in] mA \ref schmatrix \f$A\f$.
@return Reference to changed calling vector.
*/
    basic_rvector& eig(const basic_schmatrix<TR,TC>& mA) {
        _check_ne(CVM_SIZESMISMATCH, this->size(), mA.nsize());
        __eig<basic_rvector, basic_schmatrix<TR,TC>,
            basic_scmatrix<TR,TC>> (*this, mA, nullptr, true);
        return *this;
    }

/**
@brief Eigenvalues

Solves symmetric eigenvalue problem and sets calling vector to be equal to eigenvalues
of Hermitian matrix \c mA.
The symmetric eigenvalue problem is defined as follows: given symmetric
or Hermitian matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
All \f$n\f$ eigenvalues are real not only for real
symmetric but also for complex Hermitian matrices \f$A\f$,
and there exists an orthogonal system of \f$n\f$ eigenvectors.
If \f$A\f$ is symmetric or Hermitian positive-definite matrix, all eigenvalues are positive.
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
It sets output parameter \c mEigVect to be equal to square matrix containing eigenvectors as columns.
Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);

try {
    srsmatrix m(3);
    srmatrix me(3);
    rvector v(3);
    m.randomize(1., 3.);

    v.eig(m, me);
    std::cout << v;

    std::cout << m * me(1) - me(1) * v(1);
    std::cout << m * me(2) - me(2) * v(2);
    std::cout << m * me(3) - me(3) * v(3);
    std::cout << me(1) * me(2) << std::endl;  // orthogonality check

    schmatrix mc(3);
    scmatrix mce(3);
    mc.randomize_real(1., 3.);
    mc.randomize_imag(1., 3.);

    v.eig(mc, mce);
    std::cout << v;

    std::cout << mc * mce(1) - mce(1) * v(1);
    std::cout << mc * mce(2) - mce(2) * v(2);
    std::cout << mc * mce(3) - mce(3) * v(3);
    std::cout << mce(1) % mce(2) << std::endl;  // orthogonality check
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-9.360e-01 +3.535e-01 +6.376e+00
-4.441e-16 -5.551e-16 -6.106e-16
+3.331e-16 +1.145e-16 +1.110e-16
-4.441e-16 +0.000e+00 -4.441e-16
+2.060e-17
-3.274e+00 +9.710e-01 +8.209e+00
(-4.441e-16,-1.221e-15) (-1.443e-15,-4.441e-16) (-8.882e-16,+4.683e-16)
(-5.551e-16,-2.776e-16) (+0.000e+00,-4.025e-16) (+6.661e-16,-2.461e-17)
(-5.551e-16,+0.000e+00) (+4.441e-16,-4.441e-16) (+0.000e+00,+3.896e-16)
(+1.608e-16,-2.261e-17)
\endcode
@see cvector::eig()
@param[in] mA \ref schmatrix \f$A\f$.
@param[out] mEigVect \ref scmatrix of eigenvectors (as columns).
@return Reference to changed calling vector.
*/
    basic_rvector& eig(const basic_schmatrix<TR,TC>& mA,
                       basic_scmatrix<TR,TC>& mEigVect) {
        _check_ne(CVM_SIZESMISMATCH, this->size(), mA.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->size(), mEigVect.nsize());
        __eig<basic_rvector, basic_schmatrix<TR,TC>,
            basic_scmatrix<TR,TC>> (*this, mA, &mEigVect, true);
        return *this;
    }

// ?gemv routines perform a matrix-vector operation defined as
// this = alpha*m*v + beta * this,
/**
@brief Generic matrix-vector operation

Calls one of \c DGEMV routines of the BLAS Library
performing matrix-vector operation defined as
\f[
c=\alpha\,M\cdot v + \beta\,c\quad\text{or}\quad c=\alpha\,v\cdot M + \beta\, c,
\f]
where \f$\alpha\f$ and \f$\beta\f$ are real numbers
(parameters \c dAlpha and \c dBeta), \f$M\f$ is matrix (parameter \c m)
and \f$v\f$ and \f$c\f$ are vectors (parameter \c v and calling vector respectively).
First operation is performed if \c bLeft passed is \c false and second one otherwise.
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);

try {
    double alpha = 1.3;
    double beta = -0.7;
    rmatrix m(4,3);
    rvector c(4);
    rvector v(3);
    m.randomize(-1., 2.); v.randomize(-1., 3.); c.randomize(0., 2.);

    std::cout << m * v * alpha + c * beta;
    std::cout << c.gemv(false, m, alpha, v, beta);
    std::cout << c * m * alpha + v * beta;
    std::cout << v.gemv(true, m, alpha, c, beta);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-3.5397829e-02 +3.1990410e-02 +3.2633344e-01 -5.4669713e-01
-3.5397829e-02 +3.1990410e-02 +3.2633344e-01 -5.4669713e-01
-4.7697026e-01 -2.2544922e-01 -5.5204984e-01
-4.7697026e-01 -2.2544922e-01 -5.5204984e-01
\endcode
@see http://www.netlib.org/blas
@param[in] bLeft Is left-sided multiplication.
@param[in] m \ref rmatrix \f$M\f$.
@param[in] dAlpha Number \f$\alpha\f$.
@param[in] v \ref rvector \f$v\f$.
@param[in] dBeta Number \f$\beta\f$.
@return Reference to changed calling vector.
*/
    basic_rvector& gemv(bool bLeft, const basic_rmatrix<TR>& m, TR dAlpha,
                        const basic_rvector& v, TR dBeta) {
        _check_ne(CVM_SIZESMISMATCH, this->size(), bLeft ? m.nsize() : m.msize());
        _check_ne(CVM_SIZESMISMATCH, v.size(), bLeft ? m.msize() : m.nsize());
        m._gemv(bLeft, dAlpha, v, dBeta, *this);
        return *this;
    }

/**
@brief Generic band matrix-vector operation

Calls one of \c DGBMV routines of the BLAS Library
performing matrix-vector operation defined as
\f[
c=\alpha\,M\cdot v + \beta\,c\quad\text{or}\quad c=\alpha\,v\cdot M + \beta\, c,
\f]
where \f$\alpha\f$ and \f$\beta\f$ are real numbers
(parameters \c dAlpha and \c dBeta), \f$M\f$ is band matrix (parameter \c m)
and \f$v\f$ and \f$c\f$ are vectors (parameter \c v and calling vector respectively).
First operation is performed if \c bLeft passed is \c false and second one otherwise.
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);

try {
    double alpha = 1.3;
    double beta = -0.7;
    srbmatrix m(3, 1, 0);
    rvector c(3);
    rvector v(3);
    m.randomize(-1., 2.); v.randomize(-1., 3.); c.randomize(0., 2.);

    std::cout << m * v * alpha + c * beta;
    std::cout << c.gbmv(false, m, alpha, v, beta);
    std::cout << c * m * alpha + v * beta;
    std::cout << v.gbmv(true, m, alpha, c, beta);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+1.4551599e+00 -5.1882508e-01 -5.2088503e-02
+1.4551599e+00 -5.1882508e-01 -5.2088503e-02
+7.3471591e-01 -2.6952064e-01 -2.0478054e-01
+7.3471591e-01 -2.6952064e-01 -2.0478054e-01
\endcode
@see http://www.netlib.org/blas
@param[in] bLeft Is left-sided multiplication.
@param[in] m \ref srbmatrix \f$M\f$.
@param[in] dAlpha Number \f$\alpha\f$.
@param[in] v \ref rvector \f$v\f$.
@param[in] dBeta Number \f$\beta\f$.
@return Reference to changed calling vector.
*/
    basic_rvector& gbmv(bool bLeft, const basic_srbmatrix<TR>& m, TR dAlpha,
                        const basic_rvector& v, TR dBeta) {
        _check_ne(CVM_SIZESMISMATCH, this->size(), bLeft ? m.nsize() : m.msize());
        _check_ne(CVM_SIZESMISMATCH, v.size(), bLeft ? m.msize() : m.nsize());
        m._gbmv(bLeft, dAlpha, v, dBeta, *this);
        return *this;
    }

/**
@brief Randomizer

Fills calling vector with pseudo-random numbers distributed between \c dFrom and \c dTo.
Function returns a reference to the vector changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(7);

rvector v(4);
v.randomize(-2.,3.);
std::cout << v;
\endcode
prints
\code
-1.1160314e+000 2.5649586e+000 8.9345988e-001 -1.1631825e+000
\endcode
@param[in] dFrom First limit.
@param[in] dTo Second limit.
@return Reference to changed calling vector.
*/
    basic_rvector& randomize(TR dFrom, TR dTo) {
        __randomize<TR>(this->get(), this->size(), this->incr(), dFrom, dTo);
        return *this;
    }

private:
//! @cond INTERNAL
    basic_rvector& _solve_helper(const basic_srmatrix<TR>& mA, const basic_rvector& vB,
                                 TR& dErr, int transp_mode) {
        _check_ne(CVM_SIZESMISMATCH, this->size(), mA.msize());
        _check_ne(CVM_SIZESMISMATCH, vB.size(), mA.msize());
        mA._solve(vB, *this, dErr, nullptr, nullptr, transp_mode);
        return *this;
    }

    [[nodiscard]] basic_rvector _operator_solve_helper(const basic_srmatrix<TR>& mA,
                                                       int transp_mode) const {
        _check_ne(CVM_SIZESMISMATCH, this->size(), mA.msize());
        TR dErr(0.);
        basic_rvector vX(this->size());
        mA._solve(*this, vX, dErr, nullptr, nullptr, transp_mode);
        return vX;
    }

    // helper for svd and divide&conquer methods
    void _gels_sd(bool svd, const basic_rmatrix<TR>& mA, const basic_rvector& vB,
                  basic_rvector<TR>& sv, tint& rank, TR tol) {
        _check_ne(CVM_SIZESMISMATCH, this->size(), mA.nsize());
        _check_ne(CVM_SIZESMISMATCH, vB.size(), mA.msize());
        _check_ne(CVM_SIZESMISMATCH, sv.size(), _cvm_min<tint>(mA.msize(), mA.nsize()));
        basic_rmatrix<TR> mA2(mA);  // this algorithm overrides A
        basic_rmatrix<TR> mB(vB, vB.size(), 1);
        basic_rmatrix<TR> mX;
        basic_rvector<TR> sv1(sv.size());  // to ensure that incr=1
        if (svd) {
            __gelss(mA2, mB, mX, tol, sv1, rank);
        } else {
            __gelsd(mA2, mB, mX, tol, sv1, rank);
        }
        sv = sv1;
        *this = mX(0);
    }
//! @endcond
};


/**
@brief End-user class encapsulating vector of complex numbers

\c TR type stands for \ref treal, \c TC type stands for \ref tcomplex. Please use predefined \ref cvector class in your applications.
@see basic_array
*/
template<typename TR, typename TC>
class basic_cvector : public basic_array<TR,TC>
{
    using BaseArray = basic_array<TR,TC>; //!< base class

public:
/**
@brief Default constructor

Creates zero size \ref cvector. No memory gets allocated.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector v;
std::cout << v.size() << std::endl;

v.resize(3);
v(1) = std::complex<double>(1.5, -1.);
std::cout << v;
\endcode
prints
\code
0
(1.50e+00,-1.00e+00) (0.00e+00,0.00e+00) (0.00e+00,0.00e+00)
\endcode
@see resize()
*/
    basic_cvector() = default;

/**
@brief Constructor

Creates \ref cvector object of given size.
It throws \ref cvmexception in case of non-positive size passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector v(3);
std::cout << v.size() << std::endl;
std::cout << v;
\endcode
prints
\code
3
(0.00e+00,0.00e+00) (0.00e+00,0.00e+00) (0.00e+00,0.00e+00)
\endcode
@param[in] nSize Size of \ref cvector (must be positive).
*/
    explicit basic_cvector(tint nSize)
      : BaseArray(nSize)
    {}

#if defined(CVM_USE_INITIALIZER_LISTS)
/**
@brief Constructor

Creates \ref cvector object and fills it with values provided in the initializer list.
This constructor is available only if your compiler supports initializer lists
(GCC 4.4 and higher, MS Visual Studio 2013 and higher, Apple LLVM 5.0 and higher).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);

cvector v = { tcomplex(1.2, 3.4), tcomplex(3.4, 5.6), 99.99 };
std::cout << v;
\endcode
prints
\code
(1.200e+000,3.400e+000) (3.400e+000,5.600e+000) (9.999e+001,0.000e+000)
\endcode
Also, if your compiler supports user-defined literals (GCC 4.7 and higher, Apple LLVM 5.0 and higher)
you can write
\code
cvector v = { 1.2+3.4_i, 3.4+5.6_i, 99.99 };
\endcode
@param[in] list Initializer list as shown above.
*/
    basic_cvector(const std::initializer_list<TC>& list)
      : BaseArray(static_cast<tint>(list.size())) {
        tint i = 0;
#ifdef CVM_USE_POOL_MANAGER
        TC* p = this->mpd;
#else
        TC* p = this->mp.get();
#endif
        for (auto it = list.begin(); it != list.end(); ++it) {
            p[i++] = *it;
        }
    }
#endif

/**
@brief Constructor

Creates \ref cvector object of given size and fills it with given complex number.
It throws \ref cvmexception in case of non-positive size passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector v(3, std::complex<double>(1.5, -1.));
std::cout << v;
\endcode
prints
\code
(1.50e+00,-1.00e+00) (1.50e+00,-1.00e+00) (1.50e+00,-1.00e+00)
\endcode
@param[in] nSize Size of \ref cvector (must be positive).
@param[in] c Number to fill \ref cvector in.
*/
    basic_cvector(tint nSize, TC c)
      : BaseArray(nSize, false) {
        this->_set(c);
    }

/**
@brief Constructor

Creates \ref cvector object of given size with given increment between elements (default is 1).
It throws \ref cvmexception in case of non-positive size passed.
Unlike others, this constructor <b>does not allocate memory</b>.
It just shares memory with an array pointed to by \c pd using
distance between elements equal to \c nIncr.
It is intented to make possible the following syntax:
\code
cmatrix m(10, 20);
cvector v(20);

m[1] = v;  // assigns v to the 1st row of m
\endcode
     And for example this code...
\code
cmatrix m(10,20);
cvector vRow = m[1];
\endcode
will also call this constructor and <em>memory will be shared</em>.

If you need the code like this with memory allocation, use the following:
\code
cmatrix m(10,20);
cvector vRow(m.msize());
vRow = m[1];
\endcode

\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
cvector v1 ((std::complex<double>*) a, 2, 2);

std::cout << v1;
v1(2) = std::complex<double> (9.99, 9.99);
std::cout << v1 << std::endl;

for (int i = 0; i < 6; i++) {
    std::cout << a[i] << " ";
}
std::cout << std::endl;

cvector v2 ((std::complex<double>*) a, 3);
std::cout << v2;
\endcode
prints
\code
(1.00e+000,2.00e+000) (5.00e+000,6.00e+000)
(1.00e+000,2.00e+000) (9.99e+000,9.99e+000)

1.00e+000 2.00e+000 3.00e+000 4.00e+000 9.99e+000 9.99e+000
(1.00e+000,2.00e+000) (3.00e+000,4.00e+000) (9.99e+000,9.99e+000)
\endcode
@see http://cvmlib.com/faq.htm
@param[in] pd Pointer to an array to share memory with.
@param[in] nSize Size of \ref cvector (must be positive).
@param[in] nIncr Increment between elements, default is 1 (one after another).
*/
    basic_cvector(TC* pd, tint nSize, tint nIncr = 1)
      : BaseArray(pd, nSize, nIncr)
    {}

/**
@brief Constructor

Creates \ref cvector of \c nSize elements with increment 1 in between. This is const version,
it allocates memory and copies every \c nIncr-th element (deep copy) from external array pointed to by \c pd parameter.
It copies \c nSize elements total.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

const double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
cvector v1 ((const std::complex<double>*) a, 2, 2);

std::cout << v1;
v1(2) = std::complex<double> (9.99, 9.99);
std::cout << v1 << std::endl;

for (int i = 0; i < 6; i++) {
    std::cout << a[i] << " ";
}
std::cout << std::endl;

cvector v2 ((std::complex<double>*) a, 3);
std::cout << v2;
\endcode
prints
\code
(1.00e+000,2.00e+000) (5.00e+000,6.00e+000)
(1.00e+000,2.00e+000) (9.99e+000,9.99e+000)

1.00e+000 2.00e+000 3.00e+000 4.00e+000 5.00e+000 6.00e+000
(1.00e+000,2.00e+000) (3.00e+000,4.00e+000) (5.00e+000,6.00e+000)
\endcode
@see http://cvmlib.com/faq.htm
@param[in] pd Const pointer to external array.
@param[in] nSize Number of an array  elements.
@param[in] nIncr Increment between external array elements.
*/
    basic_cvector(const TC* pd, tint nSize, tint nIncr = 1)
      : BaseArray(pd, nSize, nIncr)
    {}

/**
@brief Copy constructor

Creates \ref cvector object of size equal to size of
vector \c v and sets every element of created vector to be equal to
appropriate element of \c v.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9., 10.};
const cvector v((std::complex<double>*) a, 3, 2);
cvector vc(v);

vc(1) = std::complex<double>(7.77,8.88);
std::cout << vc;
std::cout << v;
\endcode
prints
\code
(7.77e+00,8.88e+00) (5.00e+00,6.00e+00) (9.00e+00,1.00e+01)
(1.00e+00,2.00e+00) (5.00e+00,6.00e+00) (9.00e+00,1.00e+01)
\endcode
@param[in] v Vector to copy from.
*/
    basic_cvector(const basic_cvector& v)
      : BaseArray(v.size(), false) {
        __copy<TC>(this->size(), v, v.incr(), this->get(), this->incr());
    }

/**
@brief Move constructor

Implements move semantics introduced in new C++ standard.
Moves data ownership from other vector to newly created object.
It's usually executed implicitly in cases like this:
\code
cvector a(b + c);
\endcode
or this
\code
cvector a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to newly created object <tt>a</tt>.
@param[in] a rvalue reference to other array.
*/
    basic_cvector(basic_cvector&& a) noexcept
      : BaseArray(std::move(a))
    {}

/**
@brief Constructor

Creates \ref cvector of \c nSize elements with increment 1 in between.
Constructor copies every \c nIncrRe-th element of an array pointed to by \c pRe
and every \c nIncrIm-th element of an array pointed to by \c pIm
to real and imaginary part of the object created.
It throws \ref cvmexception in case of non-positive size passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double re[] = {1., 2., 3., 4., 5.};
double im[] = {5., 4., 3., 2., 1.};
cvector v(re, im, 3, 2);

std::cout << v;
re[0] = 7.77;
std::cout << v;

const double rec[] = {1., 2., 3.};
const double imc[] = {5., 4., 3.};
const cvector vc(rec, imc, 3);
std::cout << vc;
\endcode
prints
\code
(1.00e+00,5.00e+00) (3.00e+00,4.00e+00) (5.00e+00,3.00e+00)
(1.00e+00,5.00e+00) (3.00e+00,4.00e+00) (5.00e+00,3.00e+00)
(1.00e+00,5.00e+00) (2.00e+00,4.00e+00) (3.00e+00,3.00e+00)
\endcode
@param[in] pRe Const pointer to external real array.
@param[in] pIm Const pointer to external imaginary array.
@param[in] nSize Number of an array  elements.
@param[in] nIncrRe Increment between external real array elements.
@param[in] nIncrIm Increment between external iumaginary array elements.
*/
    basic_cvector(const TR* pRe, const TR* pIm, tint nSize, tint nIncrRe = 1, tint nIncrIm = 1)
      : BaseArray(nSize, pRe == nullptr || pIm == nullptr) {
        __copy2<TR,TC>(this->get(), this->size(), this->incr(), pRe, pIm, nIncrRe, nIncrIm);
    }

/**
@brief Constructor

Creates \ref cvector object
of size equal to \c vRe.size() and \c vIm.size()
and copies vectors \c vRe and \c vIm
to real and imaginary part of the object created.
It throws \ref cvmexception in case of non-equal sizes of the parameters passed
or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

rvector vr(3), vi(3);
vr[1] = 1.;
vr[2] = 2.;
vr[3] = 3.;
vi[1] = 5.;
vi[2] = 4.;
vi[3] = 3.;

const cvector vc(vr, vi);
std::cout << vc;
\endcode
prints
\code
(1.00e+00,5.00e+00) (2.00e+00,4.00e+00) (3.00e+00,3.00e+00)
\endcode
@param[in] vRe \ref rvector of real values.
@param[in] vIm \ref rvector of imaginary values.
*/
    basic_cvector(const basic_rvector<TR>& vRe, const basic_rvector<TR>& vIm)
      : BaseArray(vRe.size(), false) {
        _check_ne(CVM_SIZESMISMATCH, vRe.size(), vIm.size());
        __copy2<TR,TC>(this->get(), this->size(), this->incr(), vRe, vIm, vRe.incr(), vIm.incr());
    }

/**
@brief Constructor

Creates \ref cvector object
of size equal to \c nSize and copies every
\c nIncr-th element of an array pointed to by \c pA
to real (if \c bRealPart is \c true)
or imaginary (if \c bRealPart is \c false)
part of the object created.
Constructor throws \ref cvmexception in case of non-positive size passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

const double a[] = {1., 2., 3., 4., 5.};
cvector v1 (a, 3, false, 2);
cvector v2 (a, 2);

std::cout << v1 << v2;
\endcode
prints
\code
(0.00e+00,1.00e+00) (0.00e+00,3.00e+00) (0.00e+00,5.00e+00)
(1.00e+00,0.00e+00) (2.00e+00,0.00e+00)
\endcode
@param[in] pA basic_array of real values.
@param[in] nSize Size of \ref cvector (must be positive).
@param[in] bRealPart True to copy \c pA values to real part of the object created.
@param[in] nIncr Copy every \c nIncr-th element of \c pA array.
*/
    basic_cvector(const TR* pA, tint nSize, bool bRealPart = true, tint nIncr = 1)
      : BaseArray(nSize) {
        if (bRealPart) __copy2<TR,TC>(this->get(), this->size(), this->incr(), pA, nullptr, nIncr, 0);
        else __copy2<TR,TC>(this->get(), this->size(), this->incr(), nullptr, pA, 0, nIncr);
    }

/**
@brief Constructor

Creates  \ref cvector object of size equal to \c v.size() and copies every
element of a vector \c v to real (if \c bRealPart is \c true)
or imaginary (if \c bRealPart is \c false) part of the object created.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

rvector vr(3);
vr(1) = 1.;
vr(2) = 2.;
vr(3) = 3.;

cvector v1 (vr);
cvector v2 (vr, false);
std::cout << v1 << v2;
\endcode
prints
\code
(1.00e+00,0.00e+00) (2.00e+00,0.00e+00) (3.00e+00,0.00e+00)
(0.00e+00,1.00e+00) (0.00e+00,2.00e+00) (0.00e+00,3.00e+00)
\endcode
@param[in] v \ref rvector to copy values from.
@param[in] bRealPart True to copy \c v values to real part of the object created.
*/
    explicit basic_cvector(const basic_rvector<TR>& v, bool bRealPart = true)
      : BaseArray(v.size()) {
        if (bRealPart) {
            __copy2<TR,TC>(this->get(), this->size(), this->incr(), v, nullptr, v.incr(), 0);
        }
        else {
            __copy2<TR,TC>(this->get(), this->size(), this->incr(), nullptr, v, 0, v.incr());
        }
    }

/**
@brief Real part (l-value)

Creates \ref rvector object of size equal to size of a calling vector
<b>sharing memory with its real part</b>.
In other words, the vector returned is <em>l-value</em>.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector vc(3);
vc.set(std::complex<double>(1.,1.));
std::cout << vc << vc.real();
vc.real()(1) = 7.77;
std::cout << vc;
\endcode
prints
\code
(1.00e+00,1.00e+00) (1.00e+00,1.00e+00) (1.00e+00,1.00e+00)
1.00e+00 1.00e+00 1.00e+00
(7.77e+00,1.00e+00) (1.00e+00,1.00e+00) (1.00e+00,1.00e+00)
\endcode
@see imag()
@return Result object (vector of real parts).
*/
    basic_rvector<TR> real() {
        return basic_rvector<TR>(__get_real_p<TR>(this->get()), this->size(), this->incr() * 2);
    }

/**
@brief Imaginary part (l-value)

Creates \ref rvector object of size equal to size of a calling vector
<b>sharing memory with its imaginary part</b>.
In other words, the vector returned is <em>l-value</em>.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector vc(3);
vc.set(std::complex<double>(1.,1.));
std::cout << vc << vc.imag();
vc.imag()(1) = 7.77;
std::cout << vc;
\endcode
prints
\code
(1.00e+00,1.00e+00) (1.00e+00,1.00e+00) (1.00e+00,1.00e+00)
1.00e+00 1.00e+00 1.00e+00
(1.00e+00,7.77e+00) (1.00e+00,1.00e+00) (1.00e+00,1.00e+00)
\endcode
@see real()
@return Result object (vector of imaginary parts).
*/
    basic_rvector<TR> imag() {
        return basic_rvector<TR>(__get_imag_p<TR>(this->get()), this->size(), this->incr() * 2);
    }

/**
@brief Assignment operator

Sets every element of a calling \ref cvector to be equal to
appropriate element of a vector \c v and returns a reference to
the vector changed.
Operator throws \ref cvmexception in case of different vector sizes.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector vc(3);
vc.set(std::complex<double>(1.,1.));
std::cout << vc << vc.imag();
vc.imag()(1) = 7.77;
std::cout << vc;
\endcode
prints
\code
(1.00e+00,1.00e+00) (1.00e+00,1.00e+00) (1.00e+00,1.00e+00)
1.00e+00 1.00e+00 1.00e+00
(1.00e+00,7.77e+00) (1.00e+00,1.00e+00) (1.00e+00,1.00e+00)
\endcode
@param[in] v \ref cvector to assign from.
@return Reference to changed calling vector.
*/
    basic_cvector& operator = (const basic_cvector& v) {
        _check_ne(CVM_SIZESMISMATCH, this->size(), v.size());
        this->_assign(v, v.incr());
        return *this;
    }

/**
@brief Move assignment operator

Implements move semantics introduced in new C++ standard.
Moves data ownership from other vector to a calling object.
It's usually executed implicitly in cases like this:
\code
a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to a calling object <tt>a</tt>.
@param[in] a rvalue reference to other array.
*/
    basic_cvector& operator = (basic_cvector&& a)  noexcept {
        // size check is in BasicArray
        BaseArray::operator = (std::move(a));
        return *this;
    }

/**
@brief External array assignment

Sets every element of a calling vector to be equal to
every \c nIncr-th element of an array pointed to by parameter \c pd
and returns a reference to the vector changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

const double a[] = {1., 2., 3., 4., 5., 6., 7.};
cvector v1(3);
cvector v2(2);

v1.assign((const std::complex<double>*) a);
v2.assign((const std::complex<double>*) a, 2);
std::cout << v1;
std::cout << v2;
\endcode
prints
\code
(1.00e+00,2.00e+00) (3.00e+00,4.00e+00) (5.00e+00,6.00e+00)
(1.00e+00,2.00e+00) (5.00e+00,6.00e+00)
\endcode
@param[in] pd Const pointer to external array.
@param[in] nIncr Increment between elements in external array.
@return Reference to changed calling vector.
*/
    basic_cvector& assign(const TC* pd, tint nIncr = 1) {
        this->_assign(pd, nIncr);
        return *this;
    }

/**
@brief External array assignment (to tail)

Sets every element of a calling vector, starting from \c n-th one till the end,
to be equal to every \c nIncr-th element of an array pointed to by parameter \c pd
and returns a reference to the vector changed.
\par Example:
\code
using namespace cvm;

const double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9., 10.};
cvector v1(4);
cvector v2(4);

v1.assign(3, (const std::complex<double>*) a);
v2.assign(2, (const std::complex<double>*) a, 2);
std::cout << v1;
std::cout << v2;
\endcode
prints
\code
(0,0) (0,0) (1,2) (3,4)
(0,0) (1,2) (5,6) (9,10)
\endcode
@param[in] n Start \ref cvector index to assign from.
@param[in] pd Const pointer to external array.
@param[in] nIncr Increment between elements in external array.
@return Reference to changed calling vector.
*/
    basic_cvector& assign(tint n, const TC* pd, tint nIncr = 1) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, n, tint(), this->size());
        this->_assign_shifted(this->get() + this->incr() * n, pd, this->size() - n, nIncr, 0);
        return *this;
    }

/**
@brief External array assignment (range)

Sets every element of a calling vector, starting from \c n-th one,
up to \c nSize total,
to be equal to every \c nIncr-th element of an array pointed to by parameter \c pd
and returns a reference to the vector changed.
If \c n+nSize goes beyond \ref rvector boundaries assignment stops at the last element.
\par Example:
\code
using namespace cvm;
const double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9., 10.};
cvector v1(4);

v1.assign(2, (const std::complex<double>*) a, 2, 3);
std::cout << v1;
\endcode
prints
\code
(0,0) (1,2) (7,8) (0,0)
\endcode
@param[in] n Start \ref cvector index to assign from.
@param[in] pd Const pointer to external array.
@param[in] nSize Maximum number of elements to be assigned.
@param[in] nIncr Increment between elements in external array.
@return Reference to changed calling vector.
*/
    basic_cvector& assign(tint n, const TC* pd, tint nSize, tint nIncr) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, n, tint(), this->size());
        this->_assign_shifted(this->get() + this->incr() * n, pd,
                              _cvm_min<tint>(nSize, this->size() - n), nIncr, 0);
        return *this;
    }

/**
@brief Subvector assignment

Sets every element of a calling vector's sub-vector
beginning with index \c n to a vector \c v
and returns a reference to the vector changed.
Function throws \ref cvmexception
if \c n is not positive or \c v.size()+n-1 is greater than
calling vector's size.
\par Example:
\code
using namespace cvm;
cvector v1(5);
cvector v2(2);
v1.set(std::complex<double>(1.,1.));
v2.set(std::complex<double>(2.,2.));
v1.assign(3, v2);
std::cout << v1;
\endcode
prints
\code
(1,1) (1,1) (2,2) (2,2) (1,1)
\endcode
@param[in] n Start \ref cvector index to assign from.
@param[in] v Const reference to vector.
@return Reference to changed calling vector.
*/
    basic_cvector& assign(tint n, const basic_cvector& v) {
        _check_gt(CVM_SIZESMISMATCH_GT, v.size() + n, this->size());
        return assign(n, v, v.size(), v.incr());
    }

/**
@brief Sets all elements to one value

Sets every element of a calling vector to be equal to
parameter \c c
and returns a reference to the vector changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector v(3);
v.set(std::complex<double>(3.,1.));
std::cout << v;
\endcode
prints
\code
(3.00e+00,1.00e+00) (3.00e+00,1.00e+00) (3.00e+00,1.00e+00)
\endcode
@param[in] c Value to set to.
@return Reference to changed calling vector.
*/
    basic_cvector& set(TC c) {
        this->_set(c);
        return *this;
    }

/**
@brief Assignment to real part

Sets real part of every element of a calling vector to be equal to appropriate element of a vector \c vRe
and returns a reference to the vector changed.
Function throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

rvector v(3);
cvector vc(3);
v(1) = 1.; v(2) = 2.; v(3) = 3.;

vc.assign_real(v);
std::cout << vc;
\endcode
prints
\code
(1.00e+00,0.00e+00) (2.00e+00,0.00e+00) (3.00e+00,0.00e+00)
\endcode
@param[in] vRe \ref rvector to assign to real part.
@return Reference to changed calling vector.
*/
    basic_cvector& assign_real(const basic_rvector<TR>& vRe) {
        _check_ne(CVM_SIZESMISMATCH, vRe.size(), this->size());
        __copy_real<TR,TC>(this->get(), this->size(), this->incr(), vRe, vRe.incr());
        return *this;
    }

/**
@brief Assignment to imaginary part

Sets imaginary part of every element of a calling vector to be equal to appropriate element of a vector \c vIm
and returns a reference to the vector changed.
Function throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

rvector v(3);
cvector vc(3);
v(1) = 1.; v(2) = 2.; v(3) = 3.;

vc.assign_imag(v);
std::cout << vc;
\endcode
prints
\code
(0.00e+00,1.00e+00) (0.00e+00,2.00e+00) (0.00e+00,3.00e+00)
\endcode
@param[in] vIm \ref rvector to assign to imaginary part.
@return Reference to changed calling vector.
*/
    basic_cvector& assign_imag(const basic_rvector<TR>& vIm) {
        _check_ne(CVM_SIZESMISMATCH, vIm.size(), this->size());
        __copy_imag<TR,TC>(this->get(), this->size(), this->incr(), vIm, vIm.incr());
        return *this;
    }

/**
@brief Fills real part

Sets real part of every element of a calling vector to be equal to
parameter \c x and returns a reference to the vector changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector v(3);
v.set_real(1.);
std::cout << v;
\endcode
prints
\code
(1.00e+00,0.00e+00) (1.00e+00,0.00e+00) (1.00e+00,0.00e+00)
\endcode
@param[in] d \ref treal number to fill real part with.
@return Reference to changed calling vector.
*/
    basic_cvector& set_real(TR d) {
        this->_set_real_number(d);
        return *this;
    }

/**
@brief Fills imaginary part

Sets imaginary part of every element of a calling vector to be equal to
parameter \c x and returns a reference to the vector changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector v(3);
v.set_imag(1.);
std::cout << v;
\endcode
prints
\code
(0.00e+00,1.00e+00) (0.00e+00,1.00e+00) (0.00e+00,1.00e+00)
\endcode
@param[in] d \ref treal number to fill imaginary part with.
@return Reference to changed calling vector.
*/
    basic_cvector& set_imag(TR d) {
        this->_set_imag_number(d);
        return *this;
    }

/**
@brief Changes size of vector

Changes size of a calling vector to be equal to
\c nNewSize and returns a reference to the vector changed.
In case of increasing of its size, the vector
is filled up with zeroes.
Function throws \ref cvmexception
in case of negative size passed or memory allocation failure.
\par Example:
\code
using namespace cvm;

try {
    double a[] = {1., 2., 3., 4.};
    rvector v(a, 3);
    std::cout << v;
    v.resize(2);
    std::cout << v;
    v.resize(4);
    std::cout << v;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1,2) (3,4) (5,6)
(1,2) (3,4)
(1,2) (3,4) (0,0) (0,0)
\endcode
@param[in] nNewSize New size.
@return Reference to changed calling vector.
*/
    basic_cvector& resize(tint nNewSize) {
        this->_resize(nNewSize);
        return *this;
    }

/**
@brief Vector comparison

Operator compares calling vector with a vector \c v
and returns \c true if they have same sizes
and their appropriate elements differ by not more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;

double a[] = {1., 2., 3., 4.};
cvector v1 ((std::complex<double>*)a, 2);
cvector v2 (2);

v2(1) = std::complex<double>(1.,2.);
v2(2) = std::complex<double>(3.,4.);

std::cout << (v1 == v2) << std::endl;
\endcode
prints
\code
1
\endcode
@see operator !=()
@param[in] v \ref cvector to compare to.
@return bool Result of comparison.
*/
    bool operator == (const basic_cvector& v) const {
        return this->_equals(v);
    }

/**
@brief Vector comparison

Operator compares calling vector with a vector \c v
and returns \c true if they have different sizes
or at least one of their appropriate elements differs by more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;

double a[] = {1., 2., 3., 4.};
cvector v1 ((std::complex<double>*)a, 2);
cvector v2 (2);

std::cout << (v1 != v2) << std::endl;
\endcode
prints
\code
1
\endcode
@see operator ==()
@param[in] v \ref cvector to compare to.
@return bool Result of comparison.
*/
    bool operator != (const basic_cvector& v) const {
        return !(this->operator == (v));
    }

/**
@brief Vector replacement

Destroys calling vector, creates a new one as a copy of \c v
and returns a reference to the vector changed. Operator throws \ref cvmexception
in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    cvector v(2);
    cvector vc(3);
    v(1) = std::complex<double> (1.,2.);
    v(2) = std::complex<double> (3.,4.);
    std::cout << v << vc << std::endl;

    vc << v;
    std::cout << vc;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1.00e+000,2.00e+000) (3.00e+000,4.00e+000)
(0.00e+000,0.00e+000) (0.00e+000,0.00e+000) (0.00e+000,0.00e+000)

(1.00e+000,2.00e+000) (3.00e+000,4.00e+000)
\endcode
@see operator =()
@param[in] v \ref cvector to replace by.
@return Reference to changed calling vector.
*/
    basic_cvector& operator << (const basic_cvector& v) {
        this->_replace(v);
        __copy<TC>(this->size(), v.get(), v.incr(), this->get(), this->incr());
        return *this;
    }

/**
@brief Addition operator

Creates an object of type \ref cvector as a sum of
a calling vector and a vector \c v.
Operator throws \ref cvmexception
in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    cvector va(3);
    cvector vb(3);
    va.set(std::complex<double>(1.,1.));
    vb.set(std::complex<double>(2.,2.));

    std::cout << va + vb;
    std::cout << va + va;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(3.00e+000,3.00e+000) (3.00e+000,3.00e+000) (3.00e+000,3.00e+000)
(2.00e+000,2.00e+000) (2.00e+000,2.00e+000) (2.00e+000,2.00e+000)
\endcode
@see sum()
@param[in] v \ref cvector to add to a calling one.
@return Sum of vectors.
*/
    basic_cvector operator + (const basic_cvector& v) const {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        basic_cvector vSum(*this);
        __add<TC>(vSum.get(), vSum.size(), vSum.incr(), v._pd(), v.incr());
        return vSum;
    }

/**
@brief Subtraction operator

Creates an object of type \ref cvector as a difference of
a calling vector and a vector \c v.
It throws \ref cvmexception in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    cvector va(3);
    cvector vb(3);
    va.set(std::complex<double> (1.,1.));
    vb.set(std::complex<double> (2.,2.));

    std::cout << va - vb;
    std::cout << va - va;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-1.00e+000,-1.00e+000) (-1.00e+000,-1.00e+000) (-1.00e+000,-1.00e+000)
(0.00e+000,0.00e+000) (0.00e+000,0.00e+000) (0.00e+000,0.00e+000)
\endcode
@see diff()
@param[in] v \ref cvector to subtract from calling one.
@return Difference of vectors.
*/
    basic_cvector operator - (const basic_cvector& v) const {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        basic_cvector vDiff(*this);
        __subtract<TC>(vDiff.get(), vDiff.size(), vDiff.incr(), v._pd(), v.incr());
        return vDiff;
    }

/**
@brief Sum of vectors

Assigns sum of
vectors \c v1 and \c v2 to a calling vector
and returns a reference to the vector changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    cvector va(3);
    cvector vb(3);
    cvector v(3);
    va.set(std::complex<double> (1.,1.));
    vb.set(std::complex<double> (2.,2.));

    std::cout << v.sum(va, vb);
    std::cout << v.sum(v, va);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(3.00e+000,3.00e+000) (3.00e+000,3.00e+000) (3.00e+000,3.00e+000)
(4.00e+000,4.00e+000) (4.00e+000,4.00e+000) (4.00e+000,4.00e+000)
\endcode
@see operator +()
@param[in] v1 First \ref cvector summand.
@param[in] v2 Second \ref cvector summand.
@return Reference to changed calling vector.
*/
    basic_cvector& sum(const basic_cvector& v1, const basic_cvector& v2) {
        _check_ne(CVM_SIZESMISMATCH, v1.size(), this->size());
        _check_ne(CVM_SIZESMISMATCH, v2.size(), this->size());
        _sum<TR,TC>(this->get(), this->size(), this->incr(), v1, v1.incr(), v2, v2.incr());
        return *this;
    }

/**
@brief Difference of vectors

Assigns difference of
vectors \c v1 and \c v2 to a calling vector
and returns a reference to the vector changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    cvector va(3);
    cvector vb(3);
    cvector v(3);
    va.set(std::complex<double> (1.,1.));
    vb.set(std::complex<double> (2.,2.));

    std::cout << v.diff(va, vb);
    std::cout << v.diff(v, va);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-1.00e+000,-1.00e+000) (-1.00e+000,-1.00e+000) (-1.00e+000,-1.00e+000)
(-2.00e+000,-2.00e+000) (-2.00e+000,-2.00e+000) (-2.00e+000,-2.00e+000)
\endcode
@see operator -()
@param[in] v1 First \ref cvector subtrahend.
@param[in] v2 Second \ref cvector subtrahend.
@return Reference to changed calling vector.
*/
    basic_cvector& diff(const basic_cvector& v1, const basic_cvector& v2) {
        _check_ne(CVM_SIZESMISMATCH, v1.size(), this->size());
        _check_ne(CVM_SIZESMISMATCH, v2.size(), this->size());
        _diff<TR,TC>(this->get(), this->size(), this->incr(), v1, v1.incr(), v2, v2.incr());
        return *this;
    }

/**
@brief Increment operator

Adds vector \c v to a calling vector
and returns a reference to the vector changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    cvector v1(3);
    cvector v2(3);
    v1.set(std::complex<double> (1.,1.));
    v2.set(std::complex<double> (2.,2.));

    v1 += v2;
    std::cout << v1;

    // well, you can do this too, but temporary object would be created
    v2 += v2;
    std::cout << v2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(3.00e+000,3.00e+000) (3.00e+000,3.00e+000) (3.00e+000,3.00e+000)
(4.00e+000,4.00e+000) (4.00e+000,4.00e+000) (4.00e+000,4.00e+000)
\endcode
@see operator +()
@see sum()
@param[in] v \ref cvector to increment by.
@return Reference to changed calling vector.
*/
    basic_cvector& operator += (const basic_cvector& v) {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        _incr<TR,TC>(this->get(), this->size(), this->incr(), v, v.incr());
        return *this;
    }

/**
@brief Decrement operator

Subtracts vector \c v from calling vector
and returns a reference to the vector changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    cvector v1(3);
    cvector v2(3);
    v1.set(std::complex<double> (1.,1.));
    v2.set(std::complex<double> (2.,2.));

    v1 -= v2;
    std::cout << v1;

    // well, you can do this too, but temporary object would be created
    v2 -= v2;
    std::cout << v2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-1.00e+000,-1.00e+000) (-1.00e+000,-1.00e+000) (-1.00e+000,-1.00e+000)
(0.00e+000,0.00e+000) (0.00e+000,0.00e+000) (0.00e+000,0.00e+000)
\endcode
@see operator -()
@see diff()
@param[in] v \ref cvector to decrement by.
@return Reference to changed calling vector.
*/
    basic_cvector& operator -= (const basic_cvector& v) {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        _decr<TR,TC>(this->get(), this->size(), this->incr(), v, v.incr());
        return *this;
    }

/**
@brief Unary minus operator

Creates an object of type \ref cvector as
calling vector multiplied by \c -1.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
const cvector v((std::complex<double>*) a, 2);

std::cout << - v;
\endcode
prints
\code
(-1.00e+000,-2.00e+000) (-3.00e+000,-4.00e+000)
\endcode
@return Result object.
*/
    basic_cvector operator - () const {
        const TR mone(-1.);
        basic_cvector vRes(*this);
        vRes._scalr(mone);
        return vRes;
    }

/**
@fn operator *(TR) const
@brief Multiply by real number operator

Creates an object of type \ref cvector as a product of
a calling vector and \ref treal number \c dMult.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
const cvector v((std::complex<double>*) a, 2);

std::cout << v * 5.;
\endcode
prints
\code
(5.00e+000,1.00e+001) (1.50e+001,2.00e+001)
\endcode
@see operator *=()
@param[in] dMult Number to multiply by.
@return Result object.
*/
    basic_cvector operator * (TR dMult) const {
        basic_cvector vRes(*this);
        vRes._scalr(dMult);
        return vRes;
    }

/**
@fn operator /(TR) const
@brief Divide by real number operator

Creates an object of type \ref cvector as a quotient of
a calling vector and \ref treal number \c dDiv.
It throws \ref cvmexception if \c dDiv has absolute value equal or less
than \ref cvmMachMin() (the smallest normalized positive number).
It also throws exception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
const cvector v((std::complex<double>*) a, 2);

std::cout << v / 4.;
\endcode
prints
\code
(2.50e-001,5.00e-001) (7.50e-001,1.00e+000)
\endcode
@see operator /=()
@param[in] dDiv Number to divide by.
@return Result object.
*/
    basic_cvector operator / (TR dDiv) const {
        basic_cvector vRes(*this);
        vRes._div(dDiv);
        return vRes;
    }

/**
@fn operator *(TC) const
@brief Multiply by complex number operator

Creates an object of type \ref cvector as a product of
a calling vector and \ref tcomplex number \c cMult.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
const cvector v((std::complex<double>*) a, 2);

std::cout << v * std::complex<double>(1.,1.);
\endcode
prints
\code
(-1.00e+000,3.00e+000) (-1.00e+000,7.00e+000)
\endcode
@see operator *=()
@param[in] cMult Number to multiply by.
@return Result object.
*/
    basic_cvector operator * (TC cMult) const {
        basic_cvector vRes(*this);
        vRes._scalc(cMult);
        return vRes;
    }

/**
@fn operator /(TC) const
@brief Divide by complex number operator

Creates an object of type \ref cvector as a quotient of
a calling vector and \ref tcomplex number \c cDiv.
It throws \ref cvmexception if \c cDiv has absolute value equal or less
than \ref cvmMachMin() (the smallest normalized positive number).
It also throws exception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
const cvector v((std::complex<double>*) a, 2);

std::cout << v / std::complex<double>(1.,1.);
\endcode
prints
\code
(1.50e+000,5.00e-001) (3.50e+000,5.00e-001)
\endcode
@see operator /=()
@param[in] cDiv Number to divide by.
@return Result object.
*/
    basic_cvector operator / (TC cDiv) const {
        basic_cvector vRes(*this);
        vRes._div(cDiv);
        return vRes;
    }

/**
@brief Multiply by real number and assign

Multiplies calling vector by \ref treal number \c dMult and returns a reference to
the vector changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
cvector v((std::complex<double>*) a, 2);

std::cout << (v *= 2.);
\endcode
prints
\code
(2.00e+000,4.00e+000) (6.00e+000,8.00e+000)
\endcode
@see operator *(TR) const
@param[in] dMult Number to multiply by.
@return Reference to changed calling vector.
*/
    basic_cvector& operator *= (TR dMult) {
        this->_scalr(dMult);
        return *this;
    }

/**
@brief Divide by real number and assign

Divides calling vector by \ref treal number \c dDiv and returns a reference to
the vector changed. It throws \ref cvmexception if \c dDiv
has absolute value equal or less than \ref cvmMachMin() (the
smallest normalized positive number).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
cvector v((std::complex<double>*) a, 2);

std::cout << (v /= 2.);
\endcode
prints
\code
(5.00e-001,1.00e+000) (1.50e+000,2.00e+000)
\endcode
@see operator /(TR) const
@param[in] dDiv Number to divide by.
@return Reference to changed calling vector.
*/
    basic_cvector& operator /= (TR dDiv) {
        this->_div(dDiv);
        return *this;
    }

/**
@brief Multiply by complex number and assign

Multiplies calling vector by \ref tcomplex number \c cMult and returns a reference to
the vector changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
cvector v((std::complex<double>*) a, 2);

v *= std::complex<double>(1.,1.);
std::cout << v;
\endcode
prints
\code
(-1.00e+000,3.00e+000) (-1.00e+000,7.00e+000)
\endcode
@see operator *(TC) const
@param[in] cMult Number to multiply by.
@return Reference to changed calling vector.
*/
    basic_cvector& operator *= (TC cMult) {
        this->_scalc(cMult);
        return *this;
    }

/**
@brief Divide by complex number and assign

Divides calling vector by \ref tcomplex number \c cDiv and returns a reference to
the vector changed. It throws \ref cvmexception if \c cDiv
has absolute value equal or less than \ref cvmMachMin() (the
smallest normalized positive number).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
cvector v((std::complex<double>*) a, 2);

v /= std::complex<double>(1.,1.);
std::cout << v;
\endcode
prints
\code
(1.50e+000,5.00e-001) (3.50e+000,5.00e-001)
\endcode
@see operator /(TC) const
@param[in] cDiv Number to divide by.
@return Reference to changed calling vector.
*/
    basic_cvector& operator /= (TC cDiv) {
        this->_div(cDiv);
        return *this;
    }

/**
@brief Vector normalizer

Normalizes calling vector so its Euclidean \ref norm()
becomes equal to 1 if it was greater than \ref cvmMachMin() (the
smallest normalized positive number) before the call.
Does nothing otherwise.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
cvector v((std::complex<double>*) a, 2);

std::cout << v.normalize();
std::cout << v.norm() << std::endl;
\endcode
prints
\code
(1.83e-01,3.65e-01) (5.48e-01,7.30e-01)
1.00e+00
\endcode
@return Reference to changed calling vector.
*/
    basic_cvector& normalize() {
        this->_normalize();
        return *this;
    }

/**
@brief Conjugation operator

Creates an object of type \ref cvector as
complex conjugated calling vector
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
double a[] = {1., 2., 3., 4.};
const cvector v((std::complex<double>*) a, 2);
cvector vc(2);

std::cout << ~v;
std::cout << vc.conj(v);
std::cout << vc.conj();
\endcode
prints
\code
(1.00e+00,-2.00e+00) (3.00e+00,-4.00e+00)
(1.00e+00,-2.00e+00) (3.00e+00,-4.00e+00)
(1.00e+00,2.00e+00) (3.00e+00,4.00e+00)
\endcode
@see conj()
@return Result object.
*/
    basic_cvector operator ~ () const {
        basic_cvector vRes(*this);
        __conj<TC>(vRes.get(), vRes.size(), vRes.incr());
        return vRes;
    }

/**
@brief Conjugation

Sets calling vector to be equal to a vector \c v conjugated
It throws \ref cvmexception in case of different sizes of the operands)
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
double a[] = {1., 2., 3., 4.};
const cvector v((std::complex<double>*) a, 2);
cvector vc(2);

std::cout << ~v;
std::cout << vc.conj(v);
std::cout << vc.conj();
\endcode
prints
\code
(1.00e+00,-2.00e+00) (3.00e+00,-4.00e+00)
(1.00e+00,-2.00e+00) (3.00e+00,-4.00e+00)
(1.00e+00,2.00e+00) (3.00e+00,4.00e+00)
\endcode
@see operator ~()
@see conj()
@return Reference to changed calling vector.
*/
    basic_cvector& conj(const basic_cvector& v) {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        this->_assign(v, v.incr());
        __conj<TC>(this->get(), this->size(), this->incr());
        return *this;
    }

/**
@brief Conjugation

Sets calling vector to be equal to conjugated itself.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
double a[] = {1., 2., 3., 4.};
const cvector v((std::complex<double>*) a, 2);
cvector vc(2);

std::cout << ~v;
std::cout << vc.conj(v);
std::cout << vc.conj();
\endcode
prints
\code
(1.00e+00,-2.00e+00) (3.00e+00,-4.00e+00)
(1.00e+00,-2.00e+00) (3.00e+00,-4.00e+00)
(1.00e+00,2.00e+00) (3.00e+00,4.00e+00)
\endcode
@see operator ~()
@see conj(const basic_cvector<TR,TC>&)
@return Reference to changed calling vector.
*/
    basic_cvector& conj() {
        __conj<TC>(this->get(), this->size(), this->incr());
        return *this;
    }

/**
@brief Scalar product

Scalar product of a calling vector and a vector \c v.
It throws \ref cvmexception if the operands have different sizes.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
double b[] = {1., -1., 1., 2.};
const cvector v1((std::complex<double>*) a, 2);
const cvector v2((std::complex<double>*) b, 2);

std::cout << v1 * v2 << std::endl;
\endcode
prints
\code
(-2.00e+00,1.10e+01)
\endcode
@param[in] v \ref cvector to compute scalar product with.
@return TC Scalar product as \ref tcomplex.
*/
    TC operator * (const basic_cvector& v) const {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        return __dotu<TC>(this->get(), this->size(), this->incr(), v.get(), v.incr());
    }

/**
@brief Scalar product

Scalar product of complex conjugated calling vector and a vector \c v.
It throws \ref cvmexception if the operands have different sizes.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 4.};
double b[] = {1., -1., 1., 2.};
const cvector v1((std::complex<double>*) a, 2);
const cvector v2((std::complex<double>*) b, 2);

std::cout << v1 % v2 << std::endl;
std::cout << ~v1 * v2 << std::endl;
\endcode
prints
\code
(1.00e+01,-1.00e+00)
(1.00e+01,-1.00e+00)
\endcode
@param[in] v \ref cvector to compute scalar product with.
@return TC Scalar product as \ref tcomplex.
*/
    TC operator % (const basic_cvector& v) const {
        _check_ne(CVM_SIZESMISMATCH, v.size(), this->size());
        return __dotc<TC>(this->get(), this->size(), this->incr(), v.get(), v.incr());
    }

/**
@brief Vector-matrix product

Creates an object of type \c cvector as a product of
a calling vector and a matrix \c m.
Use \ref mult() function to avoid new object creation.
Operator throws \ref cvmexception if calling vector's size
differs from number of rows in matrix \c m.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

double a[] = {1., 2., 3., 3., 2., 1.};
double b[] = {1., -1., 1., 2., -2., 1.,
              3., -2., 1., 2., -1., 3.};
const cvector v((std::complex<double>*) a, 3);
const cmatrix m((std::complex<double>*) b, 3, 2);

std::cout << v << m << std::endl << v * m;
\endcode
prints
\code
(1.00e+00,2.00e+00) (3.00e+00,3.00e+00) (2.00e+00,1.00e+00)
(1.00e+00,-1.00e+00) (3.00e+00,-2.00e+00)
(1.00e+00,2.00e+00) (1.00e+00,2.00e+00)
(-2.00e+00,1.00e+00) (-1.00e+00,3.00e+00)

(-5.00e+00,1.00e+01) (-1.00e+00,1.80e+01)
\endcode
@param[in] m \ref cmatrix to multiply calling vector by.
@return Result object.
*/
    basic_cvector operator * (const basic_cmatrix<TR,TC>& m) const {
        _check_ne(CVM_SIZESMISMATCH, m.msize(), this->size());
        basic_cvector vRes(m.nsize());
        m._multiply(vRes, *this, true);
        return vRes;
    }

/**
@brief Vector-matrix product

Sets calling vector to be equal to product of vector
\c v by matrix \c m and returns a reference to the object changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 1., 2., 3.};
    double b[] = {1., -1., 1., -1., 1., -1.,
                  2., -1., 2., -1., 2., -1.};
    const cvector v((std::complex<double>*) a, 3);
    const cmatrix m((std::complex<double>*) b, 3, 2);
    const scmatrix sm((std::complex<double>*) b, 2);
    cvector vm(2);

    std::cout << vm.mult(v, m) << std::endl;
    std::cout << sm << std::endl;
    std::cout << vm.mult(vm, sm);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1.20e+01,0.00e+00) (1.80e+01,6.00e+00)

(1.00e+00,-1.00e+00) (1.00e+00,-1.00e+00)
(1.00e+00,-1.00e+00) (2.00e+00,-1.00e+00)

(3.60e+01,-2.40e+01) (5.40e+01,-1.80e+01)
\endcode
@see operator *(const basic_cmatrix<TR,TC>&) const
@param[in] v \ref cvector to multiply by matrix \c m.
@param[in] m \ref cmatrix to multiply vector \c v by.
@return Reference to changed calling vector.
*/
    basic_cvector& mult(const basic_cvector& v,
                        const basic_cmatrix<TR,TC>& m) {
        _check_ne(CVM_SIZESMISMATCH, m.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, m.msize(), v.size());
        m._multiply(*this, v, true);
        return *this;
    }

/**
@brief Matrix-vector product

Sets calling vector to be equal to product of a matrix \c m by vector
\c v by and returns a reference to the object changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 1., 2., 3.};
    double b[] = {1., -1., 1., -1., 1., -1.,
                2., -1., 2., -1., 2., -1.};
    const cvector v((std::complex<double>*) a, 3);
    const cmatrix m((std::complex<double>*) b, 2, 3);
    const scmatrix sm((std::complex<double>*) b, 2);
    cvector vm(2);

    std::cout << vm.mult(m, v) << std::endl;
    std::cout << sm << std::endl;;
    std::cout << vm.mult(vm, sm);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1.40e+01,3.00e+00) (1.70e+01,4.00e+00)

(1.00e+00,-1.00e+00) (1.00e+00,-1.00e+00)
(1.00e+00,-1.00e+00) (2.00e+00,-1.00e+00)

(3.80e+01,-2.40e+01) (5.50e+01,-2.00e+01)
\endcode
@param[in] m \ref cmatrix to multiply by vector \c v.
@param[in] v \ref cvector to multiply matrix \c m by.
@return Reference to changed calling vector.
*/
    basic_cvector& mult(const basic_cmatrix<TR,TC>& m,
                        const basic_cvector& v) {
        _check_ne(CVM_SIZESMISMATCH, m.msize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, v.size(), m.nsize());
        m._multiply(*this, v, false);
        return *this;
    }

/**
@brief Rank-1 update(unconjugated)

Creates an object of type \ref cmatrix
as rank-1 update of a calling vector and a vector \c v.
The rank-1 update of vector-column \f$x\f$ of size \f$m\f$ and
vector-row \f$y\f$ of size \f$n\f$ is defined as \f$m\times n\f$ matrix
\f[\begin{pmatrix}
x_1 y_1 & x_1 y_2 & \cdots & x_1 y_n \\
x_2 y_1 & x_2 y_2 & \cdots & x_2 y_n \\
\hdotsfor{4} \\
x_m y_1 & x_m y_2 & \cdots & x_m y_n
\end{pmatrix} =
\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_m
\end{pmatrix}
\begin{pmatrix}
y_1 & y_2 & \cdots & y_n
\end{pmatrix}.\f]
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
double a[] = {1., 2., 3., -2., -1., 1.};
double b[] = {4., 5., 3., 2.};
cvector v1((std::complex<double>*) a, 3);
cvector v2((std::complex<double>*) b, 2);

std::cout << v1.rank1update_u(v2);
\endcode
prints
\code
(-6.00e+00,1.30e+01) (-1.00e+00,8.00e+00)
(2.20e+01,7.00e+00) (1.30e+01,0.00e+00)
(-9.00e+00,-1.00e+00) (-5.00e+00,1.00e+00)
\endcode
@param[in] v \ref cvector to compute rank-1 update with.
@return Result object.
*/
    [[nodiscard]] basic_cmatrix<TR,TC> rank1update_u(const basic_cvector& v) const {
        basic_cmatrix<TR,TC> mRes(this->size(), v.size());
        const TC one(1., 0.);
        __geru<TC, basic_cmatrix<TR,TC>, basic_cvector>(mRes, *this, v, one);
        return mRes;
    }

/**
@brief Rank-1 update (conjugated)

Creates an object of type \ref cmatrix
as rank-1 update of a calling vector and complex conjugated vector \c v.
The rank-1 update of vector-column \f$x\f$ of size \f$m\f$ and
vector-row \f$y\f$ of size \f$n\f$ is defined as \f$m\times n\f$ matrix
\f[\begin{pmatrix}
x_1 y_1^* & x_1 y_2^* & \cdots & x_1 y_n^* \\
x_2 y_1^* & x_2 y_2^* & \cdots & x_2 y_n^* \\
\hdotsfor{4} \\
x_m y_1^* & x_m y_2^* & \cdots & x_m y_n^*
\end{pmatrix} =
\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_m
\end{pmatrix}
\begin{pmatrix}
y_1^* & y_2^* & \hdots & y_n^*
\end{pmatrix},\f]
where \f$y_i^*\f$ is \f$i\f$-th complex conjugated element of \f$y\f$.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
double a[] = {1., 2., 3., -2., -1., 1.};
double b[] = {4., 5., 3., 2.};
cvector v1((std::complex<double>*) a, 3);
cvector v2((std::complex<double>*) b, 2);

std::cout << v1.rank1update_c(v2) << std::endl;
std::cout << v1.rank1update_u(~v2);
\endcode
prints
\code
(1.40e+01,3.00e+00) (7.00e+00,4.00e+00)
(2.00e+00,-2.30e+01) (5.00e+00,-1.20e+01)
(1.00e+00,9.00e+00) (-1.00e+00,5.00e+00)

(1.40e+01,3.00e+00) (7.00e+00,4.00e+00)
(2.00e+00,-2.30e+01) (5.00e+00,-1.20e+01)
(1.00e+00,9.00e+00) (-1.00e+00,5.00e+00)
\endcode
@param[in] v \ref cvector to compute rank-1 update with.
@return Result object.
*/
    [[nodiscard]] basic_cmatrix<TR,TC> rank1update_c(const basic_cvector& v) const {
        basic_cmatrix<TR,TC> mRes(this->size(), v.size());
        const TC one(1., 0.);
        __gerc<TC, basic_cmatrix<TR,TC>, basic_cvector>(mRes, *this, v, one);
        return mRes;
    }

/**
@brief Linear solver

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A*x=b\f$ where parameter \c mA is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function returns a reference to the vector changed.
It also sets output parameter \c dErr to be equal
to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when  matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);
    double dErr = 0.;

    std::cout << vx.solve(ma, vb, dErr);
    std::cout << dErr << std::endl;
    std::cout << ma * vx - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(3.5200000e+00,6.4000000e-01) (2.2400000e+00,-1.3200000e+00)
3.2788531e-15
(-7.7715612e-16,4.4408921e-16) (0.0000000e+00,0.0000000e+00)
\endcode
@see solve(const basic_scmatrix<TR,TC>&,const basic_cvector<TR,TC>&)
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] vB \ref cvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling vector.
*/
    basic_cvector& solve(const basic_scmatrix<TR,TC>& mA, const basic_cvector& vB, TR& dErr) {
        return _solve_helper(mA, vB, dErr, 0);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A^T*x=b\f$ (which is equivalent to \f$x*A=b\f$)
where parameter \c mA is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function returns a reference to the vector changed.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);
    double dErr = 0.;

    std::cout << vx.solve_tran(ma, vb, dErr);
    std::cout << dErr << std::endl;
    std::cout << vx * ma - vb;
    std::cout << !ma * vx - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+1.6000000e-001,-8.8000000e-001) (+1.5600000e+000,-8.0000000e-002)
+3.7480513e-015
(+0.0000000e+000,+0.0000000e+000) (+0.0000000e+000,+4.4408921e-016)
(+0.0000000e+000,+0.0000000e+000) (+0.0000000e+000,+4.4408921e-016)
\endcode
@see solve_tran(const basic_scmatrix<TR,TC>&,const basic_cvector<TR,TC>&)
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] vB \ref cvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling vector.
*/
    basic_cvector& solve_tran(const basic_scmatrix<TR,TC>& mA, const basic_cvector& vB, TR& dErr) {
        return _solve_helper(mA, vB, dErr, 1);
    }

// 6.1: conjugate added
/**
@brief Linear solver (conjugated)

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A^H*x=b\f$ (here \f$A^H\f$ is conjugated \f$A\f$)
where parameter \c mA is square complex matrix \f$A\f$
and parameter \c vB is complex vector \f$b\f$.
Function returns a reference to the vector changed.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Functions throws \ref cvmexception in case of inappropriate sizes
of the objects or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);
    double dErr = 0.;

    std::cout << vx.solve_conj(ma, vb, dErr);
    std::cout << dErr << std::endl;
    std::cout << ~ma * vx - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+2.3200000e+000,+3.7600000e+000) (+2.1200000e+000,+1.6000000e-001)
+2.1932508e-015
(+0.0000000e+000,-4.4408921e-016) (-8.8817842e-016,-8.8817842e-016)
\endcode
@see solve_conj(const basic_scmatrix<TR,TC>&,const basic_cvector<TR,TC>&)
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] vB \ref cvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling vector.
*/
    basic_cvector& solve_conj(const basic_scmatrix<TR,TC>& mA, const basic_cvector& vB, TR& dErr) {
        return _solve_helper(mA, vB, dErr, 2);
    }

/**
@brief Linear solver

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A*x=b\f$ where parameter \c mA is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function returns a reference to the vector changed.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when  matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);

    std::cout << vx.solve(ma, vb);
    std::cout << ma * vx - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(3.5200000e+00,6.4000000e-01) (2.2400000e+00,-1.3200000e+00)
(-7.7715612e-16,4.4408921e-16) (0.0000000e+00,0.0000000e+00)
\endcode
@see solve(const basic_scmatrix<TR,TC>&,const basic_cvector<TR,TC>&,TR&)
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] vB \ref cvector \f$b\f$.
@return Reference to changed calling vector.
*/
    basic_cvector& solve(const basic_scmatrix<TR,TC>& mA,
                         const basic_cvector& vB) {
        TR dErr(0.);
        return this->solve(mA, vB, dErr);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A^T*x=b\f$ (which is equivalent to \f$x*A=b\f$)
where parameter \c mA is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function returns a reference to the vector changed.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);

    std::cout << vx.solve_tran(ma, vb);
    std::cout << vx * ma - vb;
    std::cout << !ma * vx - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+1.6000000e-001,-8.8000000e-001) (+1.5600000e+000,-8.0000000e-002)
(+0.0000000e+000,+0.0000000e+000) (+0.0000000e+000,+4.4408921e-016)
(+0.0000000e+000,+0.0000000e+000) (+0.0000000e+000,+4.4408921e-016)
\endcode
@see solve_tran(const basic_scmatrix<TR,TC>&,const basic_cvector<TR,TC>&,TR&)
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] vB \ref cvector \f$b\f$.
@return Reference to changed calling vector.
*/
    basic_cvector& solve_tran(const basic_scmatrix<TR,TC>& mA,
                              const basic_cvector& vB) {
        TR dErr(0.);
        return this->solve_tran(mA, vB, dErr);
    }

// 6.1: conjugate added
/**
@brief Linear solver (conjugated)

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A^H*x=b\f$ (here \f$A^H\f$ is conjugated \f$A\f$)
where parameter \c mA is square complex matrix \f$A\f$
and parameter \c vB is complex vector \f$b\f$.
Function returns a reference to the vector changed.
Functions throws \ref cvmexception in case of inappropriate sizes
of the objects or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);

    std::cout << vx.solve_conj(ma, vb);
    std::cout << ~ma * vx - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+2.3200000e+000,+3.7600000e+000) (+2.1200000e+000,+1.6000000e-001)
(+0.0000000e+000,-4.4408921e-016) (-8.8817842e-016,-8.8817842e-016)
\endcode
@see solve_conj(const basic_scmatrix<TR,TC>&,const basic_cvector<TR,TC>&,TR&)
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] vB \ref cvector \f$b\f$.
@return Reference to changed calling vector.
*/
    basic_cvector& solve_conj(const basic_scmatrix<TR,TC>& mA,
                              const basic_cvector& vB) {
        TR dErr(0.);
        return this->solve_conj(mA, vB, dErr);
    }

// 6.1: MATLAB-style operator B/A returning solution of X*A=B equation
/**
@brief Linear solver operator (transposed)

Returns solution \f$x\f$ of  linear equation
\f$A^T*x=b\f$ (which is equivalent to \f$x*A=b\f$)
where parameter \c mA is square matrix \f$A\f$
and calling vector is \f$b\f$.
This operator throws \ref cvmexception in case of inappropriate sizes
of the objects or when  matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);

    vx = vb / ma;

    std::cout << vx * ma - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+0.0000000e+000,+0.0000000e+000) (+0.0000000e+000,+4.4408921e-016)
\endcode
@see solve_tran(const basic_scmatrix<TR,TC>&,const basic_cvector<TR,TC>&)
@param[in] mA \ref scmatrix \f$A\f$.
@return Result object (solution of the equation).
*/
    basic_cvector operator / (const basic_scmatrix<TR,TC>& mA) const {
        return _operator_solve_helper(mA, 1);
    }

// 6.1: similar to operator / this one returns solution of A*X=B equation
/**
@brief Linear solver operator

Returns solution \f$x\f$ of linear equation \f$A*x=b\f$ where parameter \c mA is square matrix \f$A\f$
and calling vector is \f$b\f$. This operator throws \ref cvmexception in case of inappropriate sizes
of the objects or when  matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);

    vx = vb % ma;

    std::cout << ma * vx - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-6.6613381e-016,+4.4408921e-016) (+0.0000000e+000,+0.0000000e+000)
\endcode
@see solve(const basic_scmatrix<TR,TC>&,const basic_cvector<TR,TC>&)
@param[in] mA \ref scmatrix \f$A\f$.
@return Result object (solution of the equation).
*/
    basic_cvector operator % (const basic_scmatrix<TR,TC>& mA) const {
        return _operator_solve_helper(mA, 0);
    }

/**
@brief LU factorization based linear solver

Sets calling vector to be equal to solution \f$x\f$ of linear
equation
\f$A*x=b\f$ where parameter \c mA is square matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref scmatrix::low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c vB is vector \f$b\f$.
Function returns a reference to the vector changed.
It also sets output parameter \c dErr to be equal to the norm of computation error.
This function is useful when you need to solve few linear equations
of kind \f$Ax=b\f$ with the same matrix \f$A\f$ and different vectors \f$b\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time. Throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b1[] = {1., 2., 5., -3.};
    double b2[] = {3., -1., 1., 7.};
    scmatrix ma((std::complex<double>*) m, 2);
    scmatrix mLU(2);
    cvector vb1((std::complex<double>*) b1, 2);
    cvector vb2((std::complex<double>*) b2, 2);
    cvector vx1(2);
    cvector vx2(2);
    iarray nPivots(2);
    double dErr = 0.;

    mLU.low_up(ma, nPivots);
    std::cout << vx1.solve_lu(ma, mLU, nPivots, vb1, dErr);
    std::cout << dErr << std::endl;
    std::cout << vx2.solve_lu(ma, mLU, nPivots, vb2, dErr);
    std::cout << dErr << std::endl;
    std::cout << ma * vx1 - vb1 << ma * vx2 - vb2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+3.5200000e+000,+6.4000000e-001) (+2.2400000e+000,-1.3200000e+000)
+3.2191768e-015
(+2.2800000e+000,+1.9600000e+000) (+3.6000000e-001,+5.2000000e-001)
+2.1974410e-015
(-6.6613381e-016,+4.4408921e-016) (+0.0000000e+000,+0.0000000e+000)
(-4.4408921e-016,+0.0000000e+000) (-8.8817842e-016,+8.8817842e-016)
\endcode
@see scmatrix::low_up()
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] vB \ref rvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling vector.
*/
    basic_cvector& solve_lu(const basic_scmatrix<TR,TC>& mA,
                            const basic_scmatrix<TR,TC>& mLU, const tint* pPivots,
                            const basic_cvector& vB, TR& dErr) {
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, vB.size(), mA.msize());
        _check_ne(CVM_SIZESMISMATCH, mLU.msize(), mA.msize());
        mA._solve(vB, *this, dErr, mLU, pPivots, 0);
        return *this;
    }

/**
@brief LU factorization based linear solver

Sets calling vector to be equal to solution \f$x\f$ of linear equation
\f$A*x=b\f$ where parameter \c mA is square matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref scmatrix::low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c vB is vector \f$b\f$.
Function returns a reference to the vector changed.
This function is useful when you need to solve few linear equations
of kind \f$Ax=b\f$ with the same matrix \f$A\f$ and different vectors \f$b\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time. Throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b1[] = {1., 2., 5., -3.};
    double b2[] = {3., -1., 1., 7.};
    scmatrix ma((std::complex<double>*) m, 2);
    scmatrix mLU(2);
    cvector vb1((std::complex<double>*) b1, 2);
    cvector vb2((std::complex<double>*) b2, 2);
    cvector vx1(2);
    cvector vx2(2);
    iarray nPivots(2);

    mLU.low_up(ma, nPivots);
    std::cout << vx1.solve_lu(ma, mLU, nPivots, vb1);
    std::cout << vx2.solve_lu(ma, mLU, nPivots, vb2);
    std::cout << ma * vx1 - vb1 << ma * vx2 - vb2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+3.5200000e+000,+6.4000000e-001) (+2.2400000e+000,-1.3200000e+000)
(+2.2800000e+000,+1.9600000e+000) (+3.6000000e-001,+5.2000000e-001)
(-6.6613381e-016,+4.4408921e-016) (+0.0000000e+000,+0.0000000e+000)
(-4.4408921e-016,+0.0000000e+000) (-8.8817842e-016,+8.8817842e-016)
\endcode
@see scmatrix::low_up()
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] vB \ref rvector \f$b\f$.
@return Reference to changed calling vector.
*/
    basic_cvector& solve_lu(const basic_scmatrix<TR,TC>& mA,
                            const basic_scmatrix<TR,TC>& mLU, const tint* pPivots,
                            const basic_cvector& vB) {
        TR dErr(0.);
        return this->solve_lu(mA, mLU, pPivots, vB, dErr);
    }

/**
@brief Overdetermined or underdetermined linear solver

Solves overdetermined or underdetermined linear system
\f[
A*x=b
\f]
for \f$m\times n\f$ matrix \f$A\f$ (or conjugateed one) where
\f$b\f$ is a vector of length \f$k\f$
and \f$k=m\f$ in non-conjugateed case and \f$k=n\f$ otherwise.
The algorithm uses QR or LQ factorization of \f$A\f$.
It is assumed that \f$A\f$ has full rank, infinity returned otherwise.
Internally function uses \c ZGELS LAPACK routines.
If \f$m>n\f$ and \c conjugate=false or \f$m<n\f$ and \c conjugate=true, then
the system is overdetermined, thus the algorithm tries to find the least squares solution \f$x\f$
of the problem
\f[
\|A*x-b\|_2\to\min\quad\text{or}\quad\|A^H*x-b\|_2\to\min\
\f]
respectively. Complex number \c cErr returns residuals.
The system is underdetermined otherwise, and the algorithm finds its minimum norm solution.
In this case \c cErr is set to zero. In both cases the solution computed
satisfies \f$\newcommand{\pinv}{\operatorname{pinv}} x=\pinv(A)*b\f$, but this algorithm is faster than pseudo inversion.
Function sets calling object to be the solution and returns a reference to it.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);
cvm::cmatrix a(7, 5);
cvm::cvector b(7), bt(5);
tcomplex cErr, cErrc;
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bt.randomize_real(-10., 10.);
bt.randomize_imag(-10., 10.);

cvm::cvector x(5);
x.gels(false, a, b, cErr);
cvm::cvector xt(7);
xt.gels(true, a, bt, cErrc);

std::cout << (a.pinv()*b - x).norm() << std::endl;
std::cout << cErr << std::endl;
std::cout << (~a.pinv()*bt - xt).norm() << std::endl;
std::cout << cErrc << std::endl;
\endcode
prints
\code
+1.0444134e-015
(-3.2469414e+001,+5.8375852e+000)
+1.9786436e-015
(+0.0000000e+000,+0.0000000e+000)
\endcode
@see cmatrix::pinv()
@param[in] conjugate True to compute for conjugated matrix \f$A\f$.
@param[in] mA \ref cmatrix \f$A\f$.
@param[in] vB \ref cvector \f$b\f$.
@param[out] cErr Norm of computation error.
@return Reference to changed calling vector.
*/
    basic_cvector& gels(bool conjugate, const basic_cmatrix<TR,TC>& mA, const basic_cvector& vB,
                        TC& cErr) {
        _check_ne(CVM_SIZESMISMATCH, vB.size(), conjugate ? mA.nsize() : mA.msize());
        _check_ne(CVM_SIZESMISMATCH, this->size(), conjugate ? mA.msize() : mA.nsize());
        basic_cmatrix<TR,TC> mA2(mA);  // this algorithm overrides A
        basic_cmatrix<TR,TC> mB(vB, vB.size(), 1);
        basic_cmatrix<TR,TC> mX;
        basic_cvector vErr(1);
        __gels(conjugate, mA2, mB, mX, vErr);
        cErr = vErr(0);
        *this = mX(0);
        return *this;
    }

/**
@brief Linear least squares problem

Computes minimum-norm solution to linear least squares problem
\f[
\|A*x-b\|_2\to\min
\f]
using complete orthogonal factorization of \f$m\times n\f$ matrix \f$A\f$.
Here \f$b\f$ is a vector of length \f$m\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c ZGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function sets calling object to be the solution and returns a reference to it.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;

cmatrix a(4, 5);
cvector b(4);
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
cvector x(5);
tint rank;

x.gelsy(a, b, rank);
std::cout << (a*x - b).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+6.0116296e-015
+4 +4
\endcode
@see gelss()
@see gelsd()
@see cmatrix::gelsy()
@see cmatrix::rank()
@param[in] mA \ref cmatrix \f$A\f$.
@param[in] vB \ref cvector \f$b\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Reference to changed calling vector.
*/
    basic_cvector& gelsy(const basic_cmatrix<TR,TC>& mA,
                         const basic_cvector& vB, tint& rank,
                         TR tol = basic_cvmMachSp<TR>()) {
        _check_ne(CVM_SIZESMISMATCH, vB.size(), mA.msize());
        _check_ne(CVM_SIZESMISMATCH, this->size(), mA.nsize());
        basic_cmatrix<TR,TC> mA2(mA);  // this algorithm overrides A
        basic_cmatrix<TR,TC> mB(vB, vB.size(), 1);
        basic_cmatrix<TR,TC> mX;
        __gelsy(mA2, mB, mX, tol, rank);
        *this = mX(0);
        return *this;
    }

/**
@brief Linear least squares problem

Computes minimum-norm solution to linear least squares problem
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ matrix \f$A\f$.
Here \f$b\f$ is a vector of length \f$m\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
This function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
Internally function uses \c ZGELSS LAPACK routines, see more details
about the algorithm in that routine's documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function sets calling object to be the solution and returns a reference to it.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;

cvm::cmatrix a(4, 5);
cvm::cvector b(4);
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
cvm::rvector sv(4);
cvm::cvector x(5);
tint rank;

x.gelss(a, b, sv, rank);
std::cout << (a*x - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+9.4127010e-015
+4.4408921e-015
+4 +4
\endcode
@see gelsy()
@see gelsd()
@see cmatrix::gelsy()
@see cmatrix::rank()
@param[in] mA \ref cmatrix \f$A\f$.
@param[in] vB \ref cvector \f$b\f$.
@param[out] sv Singular values of a matrix \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Reference to changed calling vector.
*/
    basic_cvector& gelss(const basic_cmatrix<TR,TC>& mA,
                         const basic_cvector& vB, basic_rvector<TR>& sv,
                         tint& rank, TR tol = basic_cvmMachSp<TR>()) {
        _gels_sd(true, mA, vB, sv, rank, tol);
        return *this;
    }

/**
@brief Linear least squares problem

Computes minimum-norm solution to linear least squares problem
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ matrix \f$A\f$
and divide and conquer method.
Here \f$b\f$ is a vector of length \f$m\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
This function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
Internally function uses \c ZGELSD LAPACK routines, see more details
about the algorithm in that routine's documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function sets calling object to be the solution and returns a reference to it.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;

cvm::cmatrix a(4, 5);
cvm::cvector b(4);
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
cvm::rvector sv(4);
cvm::cvector x(5);
tint rank;

x.gelsd(a, b, sv, rank);
std::cout << (a*x - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+1.3491837e-014
+5.3290705e-015
+4 +4
\endcode
@see gelss()
@see gelsy()
@see cmatrix::gelsy()
@see cmatrix::rank()
@param[in] mA \ref cmatrix \f$A\f$.
@param[in] vB \ref cvector \f$b\f$.
@param[out] sv Singular values of a matrix \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Reference to changed calling vector.
*/
    basic_cvector& gelsd(const basic_cmatrix<TR,TC>& mA,
                         const basic_cvector& vB, basic_rvector<TR>& sv,
                         tint& rank, TR tol = basic_cvmMachSp<TR>()) {
        _gels_sd(false, mA, vB, sv, rank, tol);
        return *this;
    }

/**
@brief Eigenvalues

Solves eigenvalue problem and sets calling vector to be equal to eigenvalues
of real square matrix \c mA.
The eigenvalue problem is defined as follows: given square matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
Some eigenvalues may be complex even for real matrix \f$A\f$.
Moreover, if real nonsymmetric matrix has a complex eigenvalue \f$a+bi\f$
corresponding to an eigenvector \f$z\f$, then \f$a-bi\f$ is also an eigenvalue.
The eigenvalue \f$a-bi\f$ corresponds to the eigenvector whose elements
are complex conjugate to the elements of \f$z\f$.
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);

try {
    srmatrix m(3);
    cvector vl(3);

    m(1,1) = 0.1;  m(1,2) = 0.2;  m(1,3) = 0.1;
    m(2,1) = 0.11; m(2,2) = 2.9;  m(2,3) = -8.4;
    m(3,1) = 0.;   m(3,2) = 2.91; m(3,3) = 8.2;

    std::cout << vl.eig(m);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+9.69e-002,+0.00e+000) (+5.55e+000,+4.17e+000) (+5.55e+000,-4.17e+000)
\endcode
@see cvector::eig()
@param[in] mA \ref srmatrix \f$A\f$.
@return Reference to changed calling vector.
*/
    basic_cvector& eig(const basic_srmatrix<TR>& mA) {
        _check_ne(CVM_SIZESMISMATCH, mA.nsize(), this->size());
        mA._eig(*this, nullptr, true);
        return *this;
    }

/**
@brief Eigenvalues anf eigenvectors

Solves eigenvalue problem and sets calling vector to be equal to eigenvalues
of real square matrix \c mA.
The eigenvalue problem is defined as follows: given square matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
Some eigenvalues may be complex even for real matrix \f$A\f$.
Moreover, if real nonsymmetric matrix has a complex eigenvalue \f$a+bi\f$
corresponding to an eigenvector \f$z\f$, then \f$a-bi\f$ is also an eigenvalue.
The eigenvalue \f$a-bi\f$ corresponds to the eigenvector whose elements
are complex conjugate to the elements of \f$z\f$.
Function sets output parameter \c mEigVect to be equal to square matrix containing eigenvectors as columns.
Function also computes "left" eigenvectors if parameter \c bRightVect is set to \c false.
Left eigencectors satisfy
\f[
z^HA = \lambda z^H.
\f]
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);

try {
    srmatrix m(3);
    scmatrix me(3);
    cvector vl(3);

    m(1,1) = 0.1;  m(1,2) = 0.2;  m(1,3) = 0.1;
    m(2,1) = 0.11; m(2,2) = 2.9;  m(2,3) = -8.4;
    m(3,1) = 0.;   m(3,2) = 2.91; m(3,3) = 8.2;
    scmatrix mc(m);

    std::cout << vl.eig(m, me) << std::endl;
    std::cout << mc * me(1) - me(1) * vl(1);
    std::cout << mc * me(2) - me(2) * vl(2);
    std::cout << mc * me(3) - me(3) * vl(3) << std::endl;

    std::cout << vl.eig(m, me, false) << std::endl;
    std::cout << ~(me(1)) * mc - ~(me(1)) * vl(1);
    std::cout << ~(me(2)) * mc - ~(me(2)) * vl(2);
    std::cout << ~(me(3)) * mc - ~(me(3)) * vl(3);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+9.69e-002,+0.00e+000) (+5.55e+000,+4.17e+000) (+5.55e+000,-4.17e+000)

(+2.78e-017,+0.00e+000) (+7.24e-017,+0.00e+000) (+4.23e-017,+0.00e+000)
(-2.22e-016,-1.94e-016) (-7.11e-015,-4.88e-015) (+0.00e+000,+1.78e-015)
(-2.22e-016,+1.94e-016) (-7.11e-015,+4.88e-015) (+0.00e+000,-1.78e-015)

(+9.69e-002,+0.00e+000) (+5.55e+000,+4.17e+000) (+5.55e+000,-4.17e+000)

(+0.00e+000,+0.00e+000) (+4.19e-017,+0.00e+000) (+1.13e-017,+0.00e+000)
(+0.00e+000,-4.16e-017) (+2.22e-016,-1.78e-015) (-8.88e-016,+2.44e-015)
(+0.00e+000,+4.16e-017) (+2.22e-016,+1.78e-015) (-8.88e-016,-2.44e-015)
\endcode
@see cvector::eig()
@param[in] mA \ref srmatrix \f$A\f$.
@param[out] mEigVect Eigenvectors of \c mA.
@param[in] bRightVect \c true (default) to compute right eigenvectors.
@return Reference to changed calling vector.
*/
    basic_cvector& eig(const basic_srmatrix<TR>& mA,
                       basic_scmatrix<TR,TC>& mEigVect,
                       bool bRightVect = true) {
        _check_ne(CVM_SIZESMISMATCH, mA.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mEigVect.nsize(), this->size());
        mA._eig(*this, &mEigVect, bRightVect);
        return *this;
    }

/**
@brief Eigenvalues

Solves eigenvalue problem and sets calling vector to be equal to eigenvalues
of complex square matrix \c mA.
The eigenvalue problem is defined as follows: given square matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);

try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {9., 8., 7., 6., 5., 4., 3., 2., 1.};
    scmatrix m(re, im, 3);
    cvector vl(3);

    std::cout << vl.eig(m);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+1.37e+001,+1.37e+001) (+1.32e+000,+1.32e+000) (+1.10e-015,+1.92e-015)
\endcode
@see cvector::eig()
@param[in] mA \ref scmatrix \f$A\f$.
@return Reference to changed calling vector.
*/
    basic_cvector& eig(const basic_scmatrix<TR,TC>& mA) {
        _check_ne(CVM_SIZESMISMATCH, mA.nsize(), this->size());
        mA._eig(*this, nullptr, true);
        return *this;
    }

/**
@brief Eigenvalues

Solves eigenvalue problem and sets calling vector to be equal to eigenvalues
of complex square matrix \c mA.
The eigenvalue problem is defined as follows: given square matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
Function sets output parameter \c mEigVect to be equal to square matrix containing eigenvectors as columns.
Function also computes "left" eigenvectors if parameter \c bRightVect is set to \c false.
Left eigencectors satisfy
\f[
z^HA = \lambda z^H.
\f]
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);

try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {9., 8., 7., 6., 5., 4., 3., 2., 1.};
    scmatrix m(re, im, 3);
    scmatrix me(3);
    cvector vl(3);

    std::cout << vl.eig(m, me) << std::endl;
    std::cout << m * me(1) - me(1) * vl(1);
    std::cout << m * me(2) - me(2) * vl(2);
    std::cout << m * me(3) - me(3) * vl(3) << std::endl;

    std::cout << vl.eig(m, me, false) << std::endl;
    std::cout << ~(me(1)) * m - ~(me(1)) * vl(1);
    std::cout << ~(me(2)) * m - ~(me(2)) * vl(2);
    std::cout << ~(me(3)) * m - ~(me(3)) * vl(3);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+1.37e+001,+1.37e+001) (+1.32e+000,+1.32e+000) (+1.10e-015,+1.92e-015)

(+1.55e-015,+3.55e-015) (-8.44e-015,+1.07e-014) (-7.99e-015,+7.11e-015)
(-2.89e-015,+5.11e-015) (-1.39e-015,+5.00e-016) (+3.33e-016,+2.00e-015)
(-2.91e-016,+6.23e-016) (+3.25e-015,+1.86e-015) (+1.82e-015,-4.87e-016)

(+1.37e+001,+1.37e+001) (+1.32e+000,+1.32e+000) (+1.10e-015,+1.92e-015)

(+3.55e-015,+2.31e-014) (+1.24e-014,+3.55e-015) (+5.33e-015,-7.11e-015)
(+1.33e-015,+0.00e+000) (-2.33e-015,-4.33e-015) (-1.55e-015,-6.44e-015)
(-9.67e-016,-1.00e-019) (-6.44e-017,+4.33e-015) (+4.43e-018,+3.66e-015)
\endcode
@see cvector::eig()
@param[in] mA \ref scmatrix \f$A\f$.
@param[out] mEigVect Eigenvectors of \c mA.
@param[in] bRightVect \c true (default) to compute right eigenvectors.
@return Reference to changed calling vector.
*/
    basic_cvector& eig(const basic_scmatrix<TR,TC>& mA,
                       basic_scmatrix<TR,TC>& mEigVect,
                       bool bRightVect = true) {
        _check_ne(CVM_SIZESMISMATCH, mA.nsize(), this->size());
        mA._eig(*this, &mEigVect, bRightVect);
        return *this;
    }

/**
@brief Generalized eigenvalues of real matrices

Solves generalized eigenvalue problem and sets calling complex vector to be equal to generalized eigenvalues
of real square matrices \c mA and  \c mB.
A generalized eigenvalue for a pair of matrices \f$(A,B)\f$ is a scalar \f$\lambda\f$ or a ratio \f$\alpha / \beta = \lambda\f$, 
such that \f$A - \lambda B\f$ is singular. It is usually represented as the pair \f$(\alpha, \beta)\f$, 
as there is a reasonable interpretation for \f$\beta =0\f$ and even for both being zero.
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;

try {
    srmatrix a(5), b(5);
    a.randomize(-10., 10.);
    b.randomize(-10., 10.);
    cvector alpha(5);
    rvector beta(5);

    alpha.geneig(a, b, beta);

    for (int i = 1; i <= 5; ++i) {
        std::cout << (scmatrix(a) - alpha[i] / beta[i] * scmatrix(b)).svd();
    }
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
99.7613 88.2526 59.4809 39.999 2.58055e-015
99.7613 88.2526 59.4809 39.999 2.58055e-015
26.8437 17.4907 9.30819 6.88691 1.44137e-015
25.8221 19.8697 11.2967 4.08824 3.35041e-015
25.8221 19.8697 11.2967 4.08824 1.43823e-015
\endcode
@see cvector::eig()
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] mB \ref srmatrix \f$B\f$.
@param[out] vBeta computed \f$\beta\f$ values.
@return Reference to changed calling vector with computed \f$\alpha\f$ values
*/
    basic_cvector& geneig(const basic_srmatrix<TR>& mA,
                          const basic_srmatrix<TR>& mB,
                          basic_rvector<TR>& vBeta) {
        _check_ne(CVM_SIZESMISMATCH, mA.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mB.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, vBeta.size(), this->size());
        basic_srmatrix<TR> ma(mA);  // overriden below. also, we need to care about band ones
        basic_srmatrix<TR> mb(mB);
        __ggev<basic_srmatrix<TR>, basic_scmatrix<TR,TC>,
            basic_rvector<TR>, basic_cvector>(ma, mb, *this, vBeta, nullptr, nullptr);
        return *this;
    }

/**
@brief Generalized eigenvalues of real matrices

Solves generalized eigenvalue problem and sets calling complex vector to be equal to generalized eigenvalues
of real square matrices \c mA and  \c mB.
A generalized eigenvalue for a pair of matrices \f$(A,B)\f$ is a scalar \f$\lambda\f$ or a ratio \f$\alpha / \beta = \lambda\f$, 
such that \f$A - \lambda B\f$ is singular. It is usually represented as the pair \f$(\alpha, \beta)\f$, 
as there is a reasonable interpretation for \f$\beta =0\f$ and even for both being zero.
The right generalized eigenvector \f$v_j\f$ corresponding to the generalized eigenvalue \f$\lambda_j\f$ of \f$(A,B)\f$ satisfies
\f[
A v_j = \lambda_j B v_j.
\f]
The left generalized eigenvector \f$u_j\f$ corresponding to the generalized eigenvalue \f$\lambda_j\f$ of \f$(A,B)\f$ satisfies
\f[
u_j^H A = \lambda_j u_j^H B.
\f]
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;

try {
    srmatrix a(5), b(5);
    a.randomize(-10., 10.);
    b.randomize(-10., 10.);
    cvector alpha(5);
    rvector beta(5);
    scmatrix eigVectLeft(5), eigVectRight(5);
    int i;

    alpha.geneig(a, b, beta, eigVectLeft, eigVectRight);

    for (i = 1; i <= 5; ++i) {
        std::cout << (scmatrix(a) - alpha[i] / beta[i] * scmatrix(b)).svd();
    }
    for (i = 1; i <= 5; ++i) {
        std::cout << (~(eigVectLeft(i)) * scmatrix(a) - (alpha[i] / beta[i]) * ~(eigVectLeft(i)) * scmatrix(b)).norm() << std::endl;
    }
    for (i = 1; i <= 5; ++i) {
        std::cout << (scmatrix(a) * eigVectRight(i) - (alpha[i] / beta[i]) * scmatrix(b) * eigVectRight(i)).norm() << std::endl;
    }
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
99.7613 88.2526 59.4809 39.999 2.58055e-015
99.7613 88.2526 59.4809 39.999 2.58055e-015
26.8437 17.4907 9.30819 6.88691 1.44137e-015
25.8221 19.8697 11.2967 4.08824 3.35041e-015
25.8221 19.8697 11.2967 4.08824 1.43823e-015
5.91177e-014
5.91177e-014
9.42906e-015
5.56442e-015
5.65233e-015
4.10838e-014
4.10838e-014
5.82212e-015
9.46038e-015
9.15244e-015
\endcode
@see cvector::eig()
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] mB \ref srmatrix \f$B\f$.
@param[out] vBeta computed \f$\beta\f$ values.
@param[out] mEigVectLeft computed left eigenvectors \f$v_j\f$ stored by columns.
@param[out] mEigVectRight computed right eigenvectors \f$u_j\f$ stored by columns.
@return Reference to changed calling vector with computed \f$\alpha\f$ values
*/
    basic_cvector& geneig(const basic_srmatrix<TR>& mA,
                          const basic_srmatrix<TR>& mB, basic_rvector<TR>& vBeta,
                          basic_scmatrix<TR,TC>& mEigVectLeft,
                          basic_scmatrix<TR,TC>& mEigVectRight) {
        _check_ne(CVM_SIZESMISMATCH, mA.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mB.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, vBeta.size(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mEigVectLeft.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mEigVectRight.nsize(), this->size());
        basic_srmatrix<TR> ma(mA);  // overriden below. also, we need to care about band ones
        basic_srmatrix<TR> mb(mB);
        __ggev(ma, mb, *this, vBeta, &mEigVectLeft, &mEigVectRight);
        return *this;
    }

/**
@brief Generalized eigenvalues of real matrices

Solves generalized eigenvalue problem and sets calling complex vector to be equal to generalized eigenvalues
of real square matrices \c mA and  \c mB.
A generalized eigenvalue for a pair of matrices \f$(A,B)\f$ is a scalar \f$\lambda\f$ or a ratio \f$\alpha / \beta = \lambda\f$, 
such that \f$A - \lambda B\f$ is singular. It is usually represented as the pair \f$(\alpha, \beta)\f$, 
as there is a reasonable interpretation for \f$\beta =0\f$ and even for both being zero.
The right generalized eigenvector \f$v_j\f$ corresponding to the generalized eigenvalue \f$\lambda_j\f$ of \f$(A,B)\f$ satisfies
\f[
A v_j = \lambda_j B v_j.
\f]
The left generalized eigenvector \f$u_j\f$ corresponding to the generalized eigenvalue \f$\lambda_j\f$ of \f$(A,B)\f$ satisfies
\f[
u_j^H A = \lambda_j u_j^H B.
\f]
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;

try {
    srmatrix a(5), b(5);
    a.randomize(-10., 10.);
    b.randomize(-10., 10.);
    cvector alpha(5);
    rvector beta(5);
    scmatrix eigVectLeft(5), eigVectRight(5);
    int i;

    alpha.geneig(a, b, beta, eigVectLeft, false);

    for (i = 1; i <= 5; ++i) {
        std::cout << (scmatrix(a) - alpha[i] / beta[i] * scmatrix(b)).svd();
    }
    for (i = 1; i <= 5; ++i) {
        std::cout << (~(eigVectLeft(i)) * scmatrix(a) - (alpha[i] / beta[i]) * ~(eigVectLeft(i)) * scmatrix(b)).norm() << std::endl;
    }

    alpha.geneig(a, b, beta, eigVectRight);

    for (i = 1; i <= 5; ++i) {
        std::cout << (scmatrix(a) * eigVectRight(i) - (alpha[i] / beta[i]) * scmatrix(b) * eigVectRight(i)).norm() << std::endl;
    }
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
240.642 220.334 163.141 92.5529 3.32163e-014
25.6052 17.872 12.2668 8.4116 1.95196e-015
24.2267 22.5764 12.2631 8.3846 7.13458e-016
24.2267 22.5764 12.2631 8.3846 8.2214e-016
20.9593 15.6649 14.9024 9.8735 2.25102e-016
1.3069e-013
1.39588e-014
1.07709e-014
1.10778e-014
1.07411e-014
8.41382e-014
1.46503e-014
1.78632e-014
1.80007e-014
4.56813e-015
\endcode
@see cvector::eig()
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] mB \ref srmatrix \f$B\f$.
@param[out] vBeta computed \f$\beta\f$ values.
@param[out] mEigVect computed left or right eigenvectors stored by columns.
@param[in] bRightVect true to compute right eigenvectors, false to compute left ones.
@return Reference to changed calling vector with computed \f$\alpha\f$ values
*/
    basic_cvector& geneig(const basic_srmatrix<TR>& mA, const basic_srmatrix<TR>& mB,
                          basic_rvector<TR>& vBeta,
                          basic_scmatrix<TR,TC>& mEigVect,
                          bool bRightVect = true) {
        _check_ne(CVM_SIZESMISMATCH, mA.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mB.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, vBeta.size(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mEigVect.nsize(), this->size());
        basic_srmatrix<TR> ma(mA);  // overriden below. also, we need to care about band ones
        basic_srmatrix<TR> mb(mB);
        __ggev(ma, mb, *this, vBeta, bRightVect ? nullptr : &mEigVect,
               bRightVect ? &mEigVect : nullptr);
        return *this;
    }

/**
@brief Generalized eigenvalues of complex matrices

Solves generalized eigenvalue problem and sets calling complex vector to be equal to generalized eigenvalues
of complex square matrices \c mA and  \c mB.
A generalized eigenvalue for a pair of matrices \f$(A,B)\f$ is a scalar \f$\lambda\f$ or a ratio \f$\alpha / \beta = \lambda\f$, 
such that \f$A - \lambda B\f$ is singular. It is usually represented as the pair \f$(\alpha, \beta)\f$, 
as there is a reasonable interpretation for \f$\beta =0\f$ and even for both being zero.
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;

try {
    scmatrix a(5);
    scbmatrix b(5, 2, 1);
    a.randomize_real(-10., 10.);
    a.randomize_imag(-10., 10.);
    b.randomize_real(-10., 10.);
    b.randomize_imag(-10., 10.);
    cvector alpha(5);
    cvector beta(5);

    alpha.geneig(a, b, beta);

    for (int i = 1; i <= 5; ++i) {
        std::cout << (a - alpha[i] / beta[i] * b).svd();
    }
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
54.1185 36.7609 17.7991 12.6586 2.06711e-015
37.0357 23.4901 14.3073 7.11309 6.83749e-015
43.3951 31.7299 26.8143 12.1402 9.2184e-015
30.6039 21.3084 14.9713 6.77913 1.25657e-015
29.5941 22.7112 18.7702 4.08204 4.24703e-015
\endcode
@see cvector::eig()
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mB \ref scmatrix \f$B\f$.
@param[out] vBeta computed \f$\beta\f$ values.
@return Reference to changed calling vector with computed \f$\alpha\f$ values
*/
    basic_cvector& geneig(const basic_scmatrix<TR,TC>& mA, const basic_scmatrix<TR,TC>& mB,
                          basic_cvector& vBeta) {
        _check_ne(CVM_SIZESMISMATCH, mA.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mB.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, vBeta.size(), this->size());
        basic_scmatrix<TR,TC> ma(mA);  // overriden below. also, we need to care about band ones
        basic_scmatrix<TR,TC> mb(mB);
        __ggev<basic_scmatrix<TR,TC>, basic_scmatrix<TR,TC>, basic_cvector,
            basic_cvector>(ma, mb, *this, vBeta, nullptr, nullptr);
        return *this;
    }

/**
@brief Generalized eigenvalues of complex matrices

Solves generalized eigenvalue problem and sets calling complex vector to be equal to generalized eigenvalues
of complex square matrices \c mA and  \c mB.
A generalized eigenvalue for a pair of matrices \f$(A,B)\f$ is a scalar \f$\lambda\f$ or a ratio \f$\alpha / \beta = \lambda\f$, 
such that \f$A - \lambda B\f$ is singular. It is usually represented as the pair \f$(\alpha, \beta)\f$, 
as there is a reasonable interpretation for \f$\beta =0\f$ and even for both being zero.
The right generalized eigenvector \f$v_j\f$ corresponding to the generalized eigenvalue \f$\lambda_j\f$ of \f$(A,B)\f$ satisfies
\f[
A v_j = \lambda_j B v_j.
\f]
The left generalized eigenvector \f$u_j\f$ corresponding to the generalized eigenvalue \f$\lambda_j\f$ of \f$(A,B)\f$ satisfies
\f[
u_j^H A = \lambda_j u_j^H B.
\f]
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;

try {
    scmatrix a(5);
    scbmatrix b(5, 2, 1);
    a.randomize_real(-10., 10.);
    a.randomize_imag(-10., 10.);
    b.randomize_real(-10., 10.);
    b.randomize_imag(-10., 10.);
    cvector alpha(5);
    cvector beta(5);
    scmatrix eigVectLeft(5), eigVectRight(5);
    int i;

    alpha.geneig(a, b, beta, eigVectLeft, eigVectRight);

    for (i = 1; i <= 5; ++i) {
        std::cout << (a - alpha[i] / beta[i] * b).svd();
    }
    for (i = 1; i <= 5; ++i) {
        std::cout << (~(eigVectLeft(i)) * a - (alpha[i] / beta[i]) * ~(eigVectLeft(i)) * b).norm() << std::endl;
    }
    for (i = 1; i <= 5; ++i) {
        std::cout << (a * eigVectRight(i) - (alpha[i] / beta[i]) * b * eigVectRight(i)).norm() << std::endl;
    }
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
143.311 87.1305 55.3041 33.3983 2.72025e-015
62.2127 52.6279 28.8434 16.4205 3.40966e-015
63.6394 45.3556 35.0669 11.7007 6.85443e-015
32.1333 23.8343 16.2436 9.18922 6.82323e-016
38.7917 31.4473 18.0545 10.806 7.54392e-015
4.65447e-014
3.99705e-014
2.64046e-014
1.54875e-014
1.3413e-014
3.93314e-014
1.06772e-014
2.37629e-014
1.14562e-014
1.99e-014
\endcode
@see cvector::eig()
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mB \ref scmatrix \f$B\f$.
@param[out] vBeta computed \f$\beta\f$ values.
@param[out] mEigVectLeft computed left eigenvectors \f$v_j\f$ stored by columns.
@param[out] mEigVectRight computed right eigenvectors \f$u_j\f$ stored by columns.
@return Reference to changed calling vector with computed \f$\alpha\f$ values
*/
    basic_cvector& geneig(const basic_scmatrix<TR,TC>& mA,
                          const basic_scmatrix<TR,TC>& mB, basic_cvector& vBeta,
                          basic_scmatrix<TR,TC>& mEigVectLeft,
                          basic_scmatrix<TR,TC>& mEigVectRight) {
        _check_ne(CVM_SIZESMISMATCH, mA.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mB.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, vBeta.size(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mEigVectLeft.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mEigVectRight.nsize(), this->size());
        basic_scmatrix<TR,TC> ma(mA);  // overriden below. also, we need to care about band ones
        basic_scmatrix<TR,TC> mb(mB);
        __ggev(ma, mb, *this, vBeta, &mEigVectLeft, &mEigVectRight);
        return *this;
    }

/**
@brief Generalized eigenvalues of complex matrices

Solves generalized eigenvalue problem and sets calling complex vector to be equal to generalized eigenvalues
of complex square matrices \c mA and  \c mB.
A generalized eigenvalue for a pair of matrices \f$(A,B)\f$ is a scalar \f$\lambda\f$ or a ratio \f$\alpha / \beta = \lambda\f$, 
such that \f$A - \lambda B\f$ is singular. It is usually represented as the pair \f$(\alpha, \beta)\f$, 
as there is a reasonable interpretation for \f$\beta =0\f$ and even for both being zero.
The right generalized eigenvector \f$v_j\f$ corresponding to the generalized eigenvalue \f$\lambda_j\f$ of \f$(A,B)\f$ satisfies
\f[
A v_j = \lambda_j B v_j.
\f]
The left generalized eigenvector \f$u_j\f$ corresponding to the generalized eigenvalue \f$\lambda_j\f$ of \f$(A,B)\f$ satisfies
\f[
u_j^H A = \lambda_j u_j^H B.
\f]
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;

try {
    scmatrix a(5);
    scbmatrix b(5, 2, 1);
    a.randomize_real(-10., 10.);
    a.randomize_imag(-10., 10.);
    b.randomize_real(-10., 10.);
    b.randomize_imag(-10., 10.);
    cvector alpha(5);
    cvector beta(5);
    scmatrix eigVectLeft(5), eigVectRight(5);
    int i;

    alpha.geneig(a, b, beta, eigVectLeft, false);

    for (i = 1; i <= 5; ++i) {
        std::cout << (a - alpha[i] / beta[i] * b).svd();
    }
    for (i = 1; i <= 5; ++i) {
        std::cout << (~(eigVectLeft(i)) * a - (alpha[i] / beta[i]) * ~(eigVectLeft(i)) * b).norm() << std::endl;
    }

    alpha.geneig(a, b, beta, eigVectRight);

    for (i = 1; i <= 5; ++i) {
        std::cout << (a * eigVectRight(i) - (alpha[i] / beta[i]) * b * eigVectRight(i)).norm() << std::endl;
    }
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
58.952 50.1947 28.6464 11.6468 2.4024e-015
51.8029 34.5341 26.584 13.8821 8.32486e-015
41.2836 33.7583 20.6533 11.6938 6.15973e-015
32.6075 20.7858 16.4413 10.8306 3.05618e-015
31.678 23.5424 14.7232 9.93361 2.41315e-015
2.13093e-014
3.15991e-014
1.97457e-014
7.83081e-015
8.88248e-015
3.70688e-014
1.89195e-014
2.79176e-014
5.49027e-015
9.92253e-015
\endcode
@see cvector::eig()
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mB \ref scmatrix \f$B\f$.
@param[out] vBeta computed \f$\beta\f$ values.
@param[out] mEigVect computed left or right eigenvectors stored by columns.
@param[in] bRightVect true to compute right eigenvectors, false to compute left ones.
@return Reference to changed calling vector with computed \f$\alpha\f$ values
*/
    basic_cvector& geneig(const basic_scmatrix<TR,TC>& mA,
                          const basic_scmatrix<TR,TC>& mB, basic_cvector& vBeta,
                          basic_scmatrix<TR,TC>& mEigVect,
                          bool bRightVect = true) {
        _check_ne(CVM_SIZESMISMATCH, mA.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mB.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, vBeta.size(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mEigVect.nsize(), this->size());
        basic_scmatrix<TR,TC> ma(mA);  // overriden below. also, we need to care about band ones
        basic_scmatrix<TR,TC> mb(mB);
        __ggev(ma, mb, *this, vBeta, bRightVect ? nullptr : &mEigVect,
               bRightVect ? &mEigVect : nullptr);
        return *this;
    }

/**
@brief Generic matrix-vector operation

Calls one of \c ZGEMV routines of the BLAS Library
performing matrix-vector operation defined as
\f[
c=\alpha\,M\cdot v + \beta\,c\quad\text{or}\quad c=\alpha\,v\cdot M + \beta\, c,
\f]
where \f$\alpha\f$ and \f$\beta\f$ are complex numbers
(parameters \c dAlpha and \c dBeta), \f$M\f$ is matrix (parameter \c m)
and \f$v\f$ and \f$c\f$ are vectors (parameter \c v and calling vector respectively).
First operation is performed if \c bLeft passed is \c false and second one otherwise.
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    std::complex<double> alpha = std::complex<double>(1.3,-0.7);
    std::complex<double> beta  = std::complex<double>(0.15,-1.09);
    cmatrix m(3,2);
    cvector c(3);
    cvector v(2);
    m.randomize_real(-1., 2.); m.randomize_imag(0., 1.);
    v.randomize_real(-1., 3.); v.randomize_imag(2., 4.);
    c.randomize_real(0., 2.); c.randomize_imag(3., 7.);
    std::cout << m * v * alpha + c * beta;
    std::cout << c.gemv(false, m, alpha, v, beta);
    std::cout << c * m * alpha + v * beta;
    std::cout << v.gemv(true, m, alpha, c, beta);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(2.71e-01,2.44e+00) (2.20e+01,7.16e+00) (-7.89e-01,2.45e+00)
(2.71e-01,2.44e+00) (2.20e+01,7.16e+00) (-7.89e-01,2.45e+00)
(5.92e+01,-1.47e+01) (3.54e+01,-3.14e+00)
(5.92e+01,-1.47e+01) (3.54e+01,-3.14e+00)
\endcode
@see http://www.netlib.org/blas
@param[in] bLeft Is left-sided multiplication.
@param[in] m \ref cmatrix \f$M\f$.
@param[in] dAlpha Number \f$\alpha\f$.
@param[in] v \ref cvector \f$v\f$.
@param[in] dBeta Number \f$\beta\f$.
@return Reference to changed calling vector.
*/
    basic_cvector& gemv(bool bLeft, const basic_cmatrix<TR,TC>& m, TC dAlpha, const basic_cvector& v, TC dBeta) {
        _check_ne(CVM_SIZESMISMATCH, v.size(), bLeft ? m.msize() : m.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->size(), bLeft ? m.nsize() : m.msize());
        m._gemv(bLeft, dAlpha, v, dBeta, *this);
        return *this;
    }

/**
@brief Generic band matrix-vector operation

Calls one of \c ZGBMV routines of the BLAS Library
performing matrix-vector operation defined as
\f[
c=\alpha\,M\cdot v + \beta\,c\quad\text{or}\quad c=\alpha\,v\cdot M + \beta\, c,
\f]
where \f$\alpha\f$ and \f$\beta\f$ are complex numbers
(parameters \c dAlpha and \c dBeta), \f$M\f$ is band matrix (parameter \c m)
and \f$v\f$ and \f$c\f$ are vectors (parameter \c v and calling vector respectively).
First operation is performed if \c bLeft passed is \c false and second one otherwise.
Function returns a reference to the vector changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    std::complex<double> alpha = std::complex<double>(1.3,-0.7);
    std::complex<double> beta  = std::complex<double>(0.15,-1.09);
    scbmatrix m(3,1,0);
    cvector c(3);
    cvector v(3);
    m.randomize_real(-1., 2.); m.randomize_imag(0., 1.);
    v.randomize_real(-1., 3.); v.randomize_imag(2., 4.);
    c.randomize_real(0., 2.); c.randomize_imag(3., 7.);
    std::cout << m * v * alpha + c * beta;
    std::cout << c.gbmv(false, m, alpha, v, beta);
    std::cout << c * m * alpha + v * beta;
    std::cout << v.gbmv(true, m, alpha, c, beta);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(3.73e+00,7.96e-01) (6.89e+00,1.07e+01) (2.16e+00,3.28e+00)
(3.73e+00,7.96e-01) (6.89e+00,1.07e+01) (2.16e+00,3.28e+00)
(3.11e+01,2.51e+01) (-4.93e+00,1.34e+01) (1.70e+00,3.93e+00)
(3.11e+01,2.51e+01) (-4.93e+00,1.34e+01) (1.70e+00,3.93e+00)
\endcode
@see http://www.netlib.org/blas
@param[in] bLeft Is left-sided multiplication.
@param[in] m \ref scbmatrix \f$M\f$.
@param[in] dAlpha Number \f$\alpha\f$.
@param[in] v \ref cvector \f$v\f$.
@param[in] dBeta Number \f$\beta\f$.
@return Reference to changed calling vector.
*/
    basic_cvector& gbmv(bool bLeft, const basic_scbmatrix<TR,TC>& m, TC dAlpha,
                        const basic_cvector& v, TC dBeta) {
        _check_ne(CVM_SIZESMISMATCH, v.size(), bLeft ? m.msize() : m.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->size(), bLeft ? m.nsize() : m.msize());
        m._gbmv(bLeft, dAlpha, v, dBeta, *this);
        return *this;
    }

/**
@brief Randomizer (real part)

Fills real part of a calling complex vector with pseudo-random numbers distributed between \c dFrom and \c dTo.
It returns a reference to the vector changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector v(3);
v.randomize_real(-2.,3.);
std::cout << v;
\endcode
prints
\code
(-4.93e-01,0.00e+00) (1.37e+00,0.00e+00) (-1.49e-01,0.00e+00)
\endcode
@param[in] dFrom First limit.
@param[in] dTo Second limit.
@return Reference to changed calling vector.
*/
    basic_cvector& randomize_real(TR dFrom, TR dTo) {
        __randomize_real<TC,TR>(this->get(), this->size(), this->incr(), dFrom, dTo);
        return *this;
    }

/**
@brief Randomizer (imaginary part)

Fills imaginary part of a calling complex vector with pseudo-random numbers distributed between \c dFrom and \c dTo.
It returns a reference to the vector changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

cvector v(3);
v.randomize_imag(-2.,3.);
std::cout << v;
\endcode
prints
\code
(0.00e+00,-4.37e-01) (0.00e+00,-1.59e+00) (0.00e+00,2.42e+00)
\endcode
@param[in] dFrom First limit.
@param[in] dTo Second limit.
@return Reference to changed calling vector.
*/
    basic_cvector& randomize_imag(TR dFrom, TR dTo) {
        __randomize_imag<TC,TR>(this->get(), this->size(), this->incr(), dFrom, dTo);
        return *this;
    }

protected:
//! @cond INTERNAL
    void _div(TC d) {
        if (std::abs(d) <= basic_cvmMachMin<TR>()) {
            throw cvmexception(CVM_DIVISIONBYZERO);
        }
        const TC one(1., 0.);
        this->_scalc(one / d);
    }

    void _scalc(TC d) {
        __scal<TC,TC>(this->get(), this->size(), this->incr(), d);
    }

    void _set_real_number(TR d) {
        _set_real<TR,TC>(this->get(), this->size(), this->incr(), d);
    }

    void _set_imag_number(TR d) {
        _set_imag<TR,TC>(this->get(), this->size(), this->incr(), d);
    }

private:
    basic_cvector& _solve_helper(const basic_scmatrix<TR,TC>& mA, const basic_cvector& vB,
                                 TR& dErr, int transp_mode) {
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), vB.size());
        mA._solve(vB, *this, dErr, nullptr, nullptr, transp_mode);
        return *this;
    }

    [[nodiscard]] basic_cvector _operator_solve_helper(const basic_scmatrix<TR,TC>& mA,
                                                       int transp_mode) const {
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), this->size());
        TR dErr(0.);
        basic_cvector vX(this->size());
        mA._solve(*this, vX, dErr, nullptr, nullptr, transp_mode);
        return vX;
    }

    // helper for svd and divide&conquer methods
    void _gels_sd(bool svd, const basic_cmatrix<TR,TC>& mA, const basic_cvector& vB,
                  basic_rvector<TR>& sv, tint& rank,
                  TR tol = basic_cvmMachSp<TR>()) {
        _check_ne(CVM_SIZESMISMATCH, mA.nsize(), this->size());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), vB.size());
        _check_ne(CVM_SIZESMISMATCH, sv.size(), _cvm_min<tint>(mA.msize(), mA.nsize()));
        basic_cmatrix<TR,TC> mA2(mA);  // this algorithm overrides A
        basic_cmatrix<TR,TC> mB(vB, vB.size(), 1);
        basic_cmatrix<TR,TC> mX;
        basic_rvector<TR> sv1(sv.size());  // to ensure that incr=1
        if (svd) {
            __gelss(mA2, mB, mX, tol, sv1, rank);
        } else {
            __gelsd(mA2, mB, mX, tol, sv1, rank);
        }
        sv = sv1;
        *this = mX(0);
    }
//! @endcond
};

/**
@brief Generalized matrix class (not end-user)

\c TR type stands for \ref treal, \c TC type stands for \ref tcomplex. Please use inherited matrix classes.
This one provides some member functions which are common for all matrices.
@see basic_array
*/
template<typename TR, typename TC>
class Matrix : public basic_array<TR,TC>
{
    using BaseArray = basic_array<TR,TC>;

protected:
    tint mm;  //!< Number of rows
    tint mn;  //!< Number of columns
    tint mld;  //!< Leading dimension

/**
@brief Default constructor

Creates empty matrix. No memory gets allocated.
*/
    Matrix()
      : mm(0),
        mn(0),
        mld(0)
    {}

/**
@brief Constructor

Creates Matrix of \c nM by \c nN size with \c nLD leading dimension. Assigns zero to all elements if \c bZeroMemory is \c true.
@param[in] nM Number of rows.
@param[in] nN Number of columns.
@param[in] nLD Leading dimension.
@param[in] bZeroMemory True if all elements should be set to zero.
*/
    Matrix(tint nM, tint nN, tint nLD, bool bZeroMemory)
      : BaseArray(nLD * nN, bZeroMemory),
        mm(nM),
        mn(nN),
        mld(nLD)
    {}

/**
@brief Constructor

Creates Matrix of \c nM by \c nN size with \c nLD leading dimension and \c nSize array size. This is non-const version,
it shares memory (shallow copy) with an array pointed to by \c pd parameter.
@see http://cvmlib.com/faq.htm
@param[in] pd Non-const pointer to external array.
@param[in] nM Number of rows.
@param[in] nN Number of columns.
@param[in] nLD Leading dimension.
@param[in] nSize Number of an array  elements.
*/
    Matrix(TC* pd, tint nM, tint nN, tint nLD, tint nSize)
      : BaseArray(pd, nSize, 1),
        mm(nM),
        mn(nN),
        mld(nLD)
    {}

/**
@brief Constructor

Creates Matrix of \c nM by \c nN size with \c nLD leading dimension and \c nSize array size. This is const version,
it allocates memory and copies every element (deep copy) from external array pointed to by \c pd parameter.
It copies \c nSize elements total.
@see http://cvmlib.com/faq.htm
@param[in] pd Const pointer to external array.
@param[in] nM Number of rows.
@param[in] nN Number of columns.
@param[in] nLD Leading dimension.
@param[in] nSize Number of an array  elements.
*/
    Matrix(const TC* pd, tint nM, tint nN, tint nLD, tint nSize)
      : BaseArray(pd, nSize, 1),
        mm(nM),
        mn(nN),
        mld(nLD)
    {}

/**
@brief Constructor

Creates Matrix of \c 1 by \c N size if \c bBeColumn is false and \c N by \c 1 otherwise.
Here \c N is size of an array  \c v passed as the first parameter. Copies all elements of \c v to the matrix created.
@param[in] v basic_array to copy elements from.
@param[in] bBeColumn True to create column matrix.
*/
    Matrix(const BaseArray& v, bool bBeColumn)
      : BaseArray(v.size()),
        mm(bBeColumn ? v.size() : 1),
        mn(bBeColumn ? 1 : v.size()),
        mld(mm) {
        __copy<TC>(this->size(), v, v.incr(), this->get(), this->incr());
    }

/**
@brief Move constructor

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to newly created object.
It's usually executed implicitly in cases like this:
\code
rvector a(b + c);
\endcode
or this
\code
rvector a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to newly created object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    Matrix(Matrix&& m) noexcept  // NOLINT
#if defined(CVM_USE_DELEGATING_CONSTRUCTORS)
        : Matrix(m.size(), m.incr(), m.msize(), m.nsize(), m.ld())
#else
        : BaseArray(m.size(), m.incr()),
        mm(m.msize()),
        mn(m.nsize()),
        mld(m.ld())
#endif
    {
        _mmove(std::move(m));
    }

/**
@brief Move assignment operator

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to a calling object.
It's usually executed implicitly in cases like this:
\code
a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to a calling object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    Matrix& operator = (Matrix&& m) noexcept {
        _check_ne(CVM_SIZESMISMATCH, m.msize(), this->msize());
        _check_ne(CVM_SIZESMISMATCH, m.nsize(), this->nsize());
        _mmove(std::move(m));
        return *this;
    }

public:
    ~Matrix() override = default;

/**
@brief Number of rows

Returns number of rows of a calling matrix.
\par Example:
\code
using namespace cvm;

rmatrix m(100, 200);
std::cout << m.msize() << std::endl;
\endcode
prints
\code
100
\endcode
@return \ref tint Number of rows.
*/
    [[nodiscard]] tint msize() const {
        return mm;
    }

/**
@brief Number of columns

Returns number of columns of a calling matrix.
\par Example:
\code
using namespace cvm;

rmatrix m(100, 200);
std::cout << m.nsize() << std::endl;
\endcode
prints
\code
200
\endcode
@return \ref tint Number of columns.
*/
    [[nodiscard]] tint nsize() const {
        return mn;
    }

/**
@brief Leading dimension

Returns leading dimension of a calling matrix.
Leading dimension is equal to number of rows
for every matrix except submatrices. For submatrices
it's equal to number of rows of parent matrix.
\par Example:
\code
using namespace cvm;

rmatrix m(100, 200);
srmatrix ms(m, 30, 40, 5); // 5x5 submatrix
std::cout << ms.ld() << std::endl;
\endcode
prints
\code
100
\endcode
@return \ref tint Leading dimension.
*/
    [[nodiscard]] tint ld() const {
        return mld;
    }

/**
@brief Row with the maximum element

Returns number of a calling matrix row
where the element with the maximum absolute value is located.
\par Example:
\code
using namespace cvm;

double a[] = {1., 0., 2., -3., 1., -1.};
rmatrix m(a, 2, 3);

std::cout << m << std::endl << m.rowofmax() << std::endl;
\endcode
prints
\code
1 2 1
0 -3 -1

2
\endcode
@return \ref tint Row number.
*/
    [[nodiscard]] tint rowofmax() const {
        return this->_indofmax() % mm;
    }

/**
@brief Row with the minimum element

Returns number of a calling matrix row
where the element with the minimum absolute value is located.
\par Example:
\code
using namespace cvm;

double a[] = {1., 0., 2., -3., 1., -1.};
rmatrix m(a, 2, 3);

std::cout << m << std::endl << m.rowofmin() << std::endl;
\endcode
prints
\code
1 2 1
0 -3 -1

2
\endcode
@return \ref tint Row number.
*/
    [[nodiscard]] tint rowofmin() const {
        return this->_indofmin() % mm;
    }

/**
@brief Column with the maximum element

Returns number of a calling matrix column
where the element with the maximum absolute value is located.
\par Example:
\code
using namespace cvm;

double a[] = {1., 0., 2., -3., 1., -1.};
rmatrix m(a, 2, 3);

std::cout << m << std::endl << m.colofmax() << std::endl;
\endcode
prints
\code
1 2 1
0 -3 -1

2
\endcode
@return \ref tint Column number.
*/
    [[nodiscard]] tint colofmax() const {
        return this->_indofmax() / mm;
    }

/**
@brief Column with the minimum element

Returns number of a calling matrix column
where the element with the minimum absolute value is located.
\par Example:
\code
using namespace cvm;

double a[] = {1., 0., 2., -3., 1., -1.};
rmatrix m(a, 2, 3);

std::cout << m << std::endl << m.colofmin() << std::endl;
\endcode
prints
\code
1 2 1
0 -3 -1

1
\endcode
@return \ref tint Column number.
*/
    [[nodiscard]] tint colofmin() const {
        return this->_indofmin() / mm;
    }

    [[nodiscard]] TR norm1() const override {
        tint i, j, k;
        TR  rSum, rNorm(0.);

        for (j = 0; j < this->nsize(); ++j) {
            rSum = TR(0.);

            k = j * this->ld();
            for (i = 0; i < this->msize(); ++i) {
                CVM_ASSERT(this->get(), (k + i + 1) * sizeof(TC))
                rSum += std::abs(this->get()[k + i]);
            }

            if (rSum > rNorm) {
                rNorm = rSum;
            }
        }
        return rNorm;
    }

    [[nodiscard]] TR norminf() const override {
        tint i, j;
        TR  rSum, rNorm(0.);

        for (i = 0; i < this->msize(); ++i) {
            rSum = TR(0.);

            for (j = 0; j < this->nsize(); ++j) {
                CVM_ASSERT(this->get(), (j * this->ld() + i + 1) * sizeof(TC))
                rSum += std::abs(this->get()[j * this->ld() + i]);
            }

            if (rSum > rNorm) {
                rNorm = rSum;
            }
        }
        return rNorm;
    }

//! @cond INTERNAL
    [[nodiscard]] const tint* _pm() const {
        return &mm;
    }

    [[nodiscard]] const tint* _pn() const {
        return &mn;
    }

    [[nodiscard]] const tint* _pld() const {
        return &mld;
    }

    TC* _sub_pointer_nocheck(tint row, tint col) {
        return this->_pd() + (col * this->ld() + row);
    }

    TC* _sub_pointer(tint row, tint col, tint height, tint width) {
        _check_lt(CVM_SIZESMISMATCH_LT, row, tint());
        _check_lt(CVM_SIZESMISMATCH_LT, col, tint());
        _check_lt(CVM_SIZESMISMATCH_LT, height, tint());
        _check_lt(CVM_SIZESMISMATCH_LT, width, tint());
        _check_gt(CVM_SIZESMISMATCH_GT, row + height, this->msize());
        _check_gt(CVM_SIZESMISMATCH_GT, col + width, this->nsize());
        return _sub_pointer_nocheck(row, col);
    }

    [[nodiscard]] virtual tint _ldm() const {
        return this->ld();
    }

    [[nodiscard]] virtual const tint* _pldm() const {
        return this->_pld();
    }

    [[nodiscard]] virtual bool _continuous() const {
        return this->msize() == this->ld();
    }

    void _check_ld() const {
        if (!this->_continuous()) {
            throw cvmexception(CVM_SUBMATRIXACCESSERROR);
        }
    }

    void _scalr(TR d) override {
        if (this->_continuous()) {
            __scal<TR,TC>(this->get(), this->size(), this->incr(), d);
        } else for (tint i = 0; i < this->nsize(); ++i) {
            __scal<TR,TC>(this->get() + this->ld() * i, this->msize(), this->incr(), d);
        }
    }

protected:
    Matrix(tint size, tint incr, tint msize, tint nsize, tint ld) noexcept
      : BaseArray(size, incr),
        mm(msize),
        mn(nsize),
        mld(ld)
    {}

    // move semantics implementation for matrices
    void _mmove(Matrix&& m) noexcept {
        // no size checks here
#ifdef CVM_USE_POOL_MANAGER
        this->_resize2(m.msize(), m.nsize());
        this->_massign(m);
#else
        if (m.mpf == nullptr) {
            if (this->mpf == nullptr && this->_continuous() && m._continuous()) {
                this->mp = std::move(m.mp);
                m.msz = m.mm = m.mn = m.mld = 0;
            } else {
                // *this has foreign array inside or not continuous; no place to move to
                // i.e. this is the case where we don't even touch m, just copy its content
                this->_massign(m);
            }
        } else {
            // here we have no clue about foreign poiter life cycle, thus copying
            this->_resize2(m.msize(), m.nsize());
            this->_massign(m);
        }
#endif
    }

    void _diag_helper(tint nDiag, tint& nShift, tint& nSize) const {
        if (nDiag >= 0) {
            _check_ge(CVM_INDEX_GE, nDiag, this->nsize());
            nShift = nDiag * this->ld();
            nSize = this->nsize() > this->msize() ?
                (nDiag > this->nsize() - this->msize() ? this->nsize() - nDiag : this->msize()) :
                this->nsize() - nDiag;
        } else {
            nShift = -nDiag;
            _check_ge(CVM_INDEX_GE, nShift, this->msize());
            nSize = this->msize() > this->nsize() ?
                (nShift > this->msize() - this->nsize() ? this->msize() - nShift : this->nsize()) :
                this->msize() - nShift;
        }
    }

    [[nodiscard]] tint _indofmin() const override {
      this->_check_ld();
      return __idamin<TC>(this->get(), this->size(), this->incr());
    }

    [[nodiscard]] tint _indofmax() const override {
        this->_check_ld();
        return __idamax<TC>(this->get(), this->size(), this->incr());
    }

    void _assign(const TC* pd, tint nIncr) override {
        if (this->get() != pd) {
            if (this->_continuous()) {
                __copy<TC>(this->size(), pd, nIncr, this->get(), this->incr());
            } else for (tint i = 0; i < this->nsize(); ++i) {
                __copy<TC>(this->msize(), pd + this->msize() * i * nIncr, nIncr, this->get() + this->ld() * i, this->incr());
            }
        }
    }

    // reusing nSise and nIncr parameter
    void _assign_shifted(TC* pDshifted, const TC* pd,
                         tint nRows, tint nCols, tint nLD) override {
        if (pDshifted != pd) {
            for (tint i = 0; i < nCols; ++i) {
                __copy<TC>(nRows, pd + nLD * i, 1, pDshifted + this->ld() * i, this->incr());
            }
        }
    }

    void _set(TC d) override {
        CVM_ASSERT(this->get(), this->size() * sizeof(TC))
        tint i, j, k;
        for (j = 0; j < this->nsize(); ++j) {
            k = j * this->ld();
            for (i = 0; i < this->msize(); ++i) {
                this->get()[k + i] = d;
            }
        }
    }

    virtual void _massign(const Matrix& m) {
        if (this->get() != m.get()) {
            if (this->_continuous() && m._continuous()) {
                __copy<TC>(this->size(), m._pd(), m.incr(), this->get(), this->incr());
            } else {
                const TC* p = m._pd();
                const tint nLD = m._ldm();
                for (tint i = 0; i < this->nsize(); ++i) {
                    __copy<TC>(this->msize(), p + nLD * i, m.incr(), this->get() + this->ld() * i, this->incr());
                }
            }
        }
    }

    virtual void _resize2(tint nNewM, tint nNewN) {
        _check_lt(CVM_WRONGSIZE_LT, nNewM, tint());
        _check_lt(CVM_WRONGSIZE_LT, nNewN, tint());
        const bool is_empty = this->_is_empty();
        if (nNewM != this->msize() || nNewN != this->nsize() || is_empty) {
            if (!is_empty) {
                this->_check_ld();
            }
            const tint nNewSize = nNewM * nNewN;
            TC* pd = cvmMalloc<TC>(nNewSize);
            cvmZeroMemory<TC>(pd, nNewSize);
            const tint nMinM = _cvm_min<tint>(nNewM, this->msize());
            const tint nMinN = _cvm_min<tint>(nNewN, this->nsize());
            if (nNewSize > 0 && !is_empty) {
                for (tint i = 0; i < nMinN; ++i) {
                    __copy<TC>(nMinM, this->get() + i * this->msize(), this->incr(), pd + i * nNewM, 1);
                }
            }
#ifdef CVM_USE_POOL_MANAGER
            cvmFree<TC>(this->mpd);
            this->mpd = pd;
#else
            this->mp.reset(pd, ArrayDeleter<TC>());
            this->mpf = nullptr;
#endif
            this->msz = nNewSize;
            CVM_ASSERT(this->get(), this->size() * sizeof(TC))
            this->mm    = nNewM;
            this->mn    = nNewN;
            this->mld   = nNewM;
            this->mincr = 1;
        }
    }

    [[nodiscard]] virtual tint _ld_for_replace() const {
        return this->mld;
    }

    [[nodiscard]] virtual tint _size_for_replace() const {
        return this->size();
    }

    void _replace(const Matrix& m) {
        // submatrix replacement is obviously not possible
        this->_check_ld();
#ifdef CVM_USE_POOL_MANAGER
        cvmFree<TC>(this->mpd);
        this->msz = m._size_for_replace();
        this->mpd = cvmMalloc<TC>(this->size());
#else
        this->msz = m._size_for_replace();
        this->mp.reset(cvmMalloc<TC>(this->size()), ArrayDeleter<TC>());
        this->mpf = nullptr;
#endif
        this->mincr = 1;
        CVM_ASSERT(this->get(), (this->size() * sizeof(TC)))
        this->mm  = m.msize();
        this->mn  = m.nsize();
        this->mld = m._ld_for_replace();
    }

    void _transp_m(const Matrix& m) {
        tint i;
        if (this->msize() > this->nsize()) for (i = 0; i < this->nsize(); ++i) {
            __copy<TC>(m.nsize(), m.get() + i, m.ld(), this->get() + i * this->ld(), 1);
        }
        else for (i = 0; i < this->msize(); ++i) {
            __copy<TC>(m.msize(), m.get() + i * m.ld(), 1, this->get() + i, this->ld());
        }
    }

    virtual type_proxy<TC,TR> _ij_proxy_val(tint i, tint j) {
        CVM_ASSERT(this->get(), (this->ld() * j + i + 1) * sizeof(TC))
        return type_proxy<TC,TR>(this->get()[this->ld() * j + i], false);
    }

    [[nodiscard]] virtual TC _ij_val(tint i, tint j) const {
        CVM_ASSERT(this->get(), (this->ld() * j + 1) * sizeof(TC))
        return this->get()[this->ld() * j + i];
    }

    virtual void _swap_rows(tint n1, tint n2) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, n1, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, n2, tint(), this->msize());
        if (n1 != n2) {
            __swap<TC>(this->nsize(), this->get() + n1,
                       this->ld(), this->get() + n2, this->ld());
        }
    }

    virtual void _swap_cols(tint n1, tint n2) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, n1, tint(), this->nsize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, n2, tint(), this->nsize());
        if (n1 != n2) {
            __swap<TC>(this->msize(), this->get() + n1 * this->ld(),
                       1, this->get() + n2 * this->ld(), 1);
        }
    }

    [[nodiscard]] virtual const TC* _pp(const Matrix& m) const {
        return m._pd();
    }

    // matrix cleaning (we ALWAYS have mincr = 1 for matrices)
    virtual void _vanish() {
        CVM_ASSERT(this->get(), this->size() * sizeof(TC))
        if (this->_continuous()) {
            memset(this->get(), 0, this->size() * sizeof(TC));
        } else for (tint i = 0; i < this->nsize(); ++i) {
            memset(this->get() + this->ld() * i, 0, this->msize() * sizeof(TC));
        }
    }

    void _msum(const Matrix& m1, const Matrix& m2) {
        if (this->_continuous() && m1._continuous() && m2._continuous()) {
            _sum<TR,TC>(this->get(), this->size(), this->incr(), _pp(m1), m1.incr(),
                        _pp(m2), m2.incr());
        } else for (tint i = 0; i < this->nsize(); ++i) {
            _sum<TR,TC>(this->get() + this->ld() * i, this->msize(), this->incr(),
                        _pp(m1) + m1._ldm() * i, m1.incr(), _pp(m2) + m2._ldm() * i, m2.incr());
        }
    }

    void _mdiff(const Matrix& m1, const Matrix& m2) {
        if (this->_continuous() && m1._continuous() && m2._continuous()) {
            _diff<TR,TC>(this->get(), this->size(), this->incr(), _pp(m1), m1.incr(),
                         _pp(m2), m2.incr());
        } else for (tint i = 0; i < this->nsize(); ++i) {
            _diff<TR,TC>(this->get() + this->ld() * i, this->msize(), this->incr(),
                         _pp(m1) + m1._ldm() * i, m1.incr(), _pp(m2) + m2._ldm() * i, m2.incr());
        }
    }

    void _mincr(const Matrix& m) {
        if (this->_continuous() && m._continuous()) {
            _incr<TR,TC>(this->get(), this->size(), this->incr(), _pp(m), m.incr());
        } else for (tint i = 0; i < this->nsize(); ++i) {
            _incr<TR,TC>(this->get() + this->ld() * i, this->msize(), this->incr(),
                         _pp(m) + m._ldm() * i, m.incr());
        }
    }

    void _mdecr(const Matrix& m) {
        if (this->_continuous() && m._continuous()) {
            _decr<TR,TC>(this->get(), this->size(), this->incr(), _pp(m), m.incr());
        } else for (tint i = 0; i < this->nsize(); ++i) {
            _decr<TR,TC>(this->get() + this->ld() * i, this->msize(), this->incr(),
                         _pp(m) + m._ldm() * i, m.incr());
        }
    }
//! @endcond

    public:
    friend std::ostream& operator << <> (std::ostream& os, const Matrix<TR,TC>& mOut);
    friend std::istream& operator >> <> (std::istream& is, Matrix<TR,TC>& mIn);
};


/**
@brief Generalized square matrix class (not end-user)

\c TR type stands for \ref treal, \c TC type stands for \ref tcomplex. Please use inherited matrix classes.
This one provides some member functions which are common for all square matrices.
@see Matrix
*/
template<typename TR, typename TC>
class SqMatrix
{
    using BaseMatrix = Matrix<TR,TC>;

protected:
    //! internal constructor
    SqMatrix() = default;

    virtual ~SqMatrix() = default;

//! @cond INTERNAL
    [[nodiscard]] virtual tint _size() const = 0;
    [[nodiscard]] virtual tint _msize() const = 0;
    [[nodiscard]] virtual tint _nsize() const = 0;
    [[nodiscard]] virtual tint _ld() const = 0;

    // it's the same as get, but let's keep get not virtual for performance sake
    [[nodiscard]] virtual const TC* _pv() const = 0;
    virtual       TC* _pv() = 0;

    // it differs from Matrix::_transp_m because in this case we can do it in-place.
    void _sq_transp() {
        const tint mm = this->_msize();
        const tint mld = this->_ld();
        TC* pd = this->_pv();
        if (mm > 1) {
            const tint nM1 = mld + 1, nM1m = mld - 1, nM2m = mm - 1;
            tint i = 1, j = 1, m;
            for (;;) {
                m = mm - i;
                __swap<TC>(m, pd + j, 1, pd + j + nM1m, mld);
                if (i >= nM2m) {
                    break;
                }
                ++i;
                j += nM1;
            }
        }
    }

    // plus identity
    void _sq_plus_plus() {
        TC* pd = this->_pv();
        const TC one(1.);
        const tint nSize = this->_size();
        const tint nNext = this->_msize() + 1;
        CVM_ASSERT(pd, nSize * sizeof(TC))
        for (tint i = 0; i < nSize; i += nNext) {
            pd[i] += one;
        }
    }

    // minus identity
    void _sq_minus_minus() {
        TC* pd = this->_pv();
        const TC one(1.);
        const tint nSize = this->_size();
        const tint nNext = this->_msize() + 1;
        CVM_ASSERT(pd, nSize * sizeof(TC))
        for (tint i = 0; i < nSize; i += nNext) {
            pd[i] -= one;
        }
    }

public:
    void _clean_low_triangle() {
        const tint mm = this->_msize();
        const tint mld = this->_ld();
        TC* pd = this->_pv();
        tint n = 1;
        const TR zero(0.);
        for (tint i = 1; i < mm; ++i) {
            __scal<TR,TC>(pd + n, mm - i, 1, zero);  // column by column
            n += mld + 1;
        }
    }
//! @endcond
};

/**
@brief End-user class encapsulating matrix of real numbers

\c TR type stands for \ref treal. Please use predefined \ref rmatrix class in your applications.
@see Matrix
*/
template<typename TR>
class basic_rmatrix : public Matrix<TR,TR>
{
    using TC = std::complex<TR>;  //!< complex number type
    using BaseArray = basic_array<TR,TR>;  //!< Base basic_array class
    using BaseMatrix = Matrix<TR,TR>;  //!< Base Matrix class
    using RVector = basic_rvector<TR>;  //!< \ref rvector class

    friend class basic_rvector<TR>;  // _multiply

public:
/**
@brief Default constructor

Creates empty matrix. No memory gets allocated.
\par Example:
\code
using namespace cvm;
rmatrix m;
std::cout << m.msize() << std::endl << m.nsize() << std::endl;
std::cout << m.size() << std::endl;
m.resize(2, 3);
std::cout << m;
\endcode
prints
\code
0
0
0
0 0 0
0 0 0
\endcode
*/
    basic_rmatrix() = default;

    ~basic_rmatrix() override = default;

/**
@brief Constructor

Creates \f$m\times n\f$ \ref rmatrix object where \f$m\f$ is passed in
\c nM parameter (number of rows) and \f$n\f$ is passed in \c nN (number of columns).
Constructor sets all elements to zero.
It throws \ref cvmexception in case of non-positive sizes passed or memory allocation failure.
Example:
\code
using namespace cvm;
rmatrix m(3, 4);
std::cout << m.msize() << std::endl << m.nsize()
          << std::endl << m.size() << std::endl << m;
\endcode
prints
\code
3
4
12
0 0 0 0
0 0 0 0
0 0 0 0
\endcode
@param[in] nM Number of rows.
@param[in] nN Number of columns.
*/
    basic_rmatrix(tint nM, tint nN)
      : BaseMatrix(nM, nN, nM, true)
    {}

/**
@brief Constructor

Creates \f$m\times n\f$ \ref rmatrix object where \f$m\f$ is passed in
\c nM parameter (number of rows) and \f$n\f$ is passed in \c nN (number of columns).
It throws \ref cvmexception in case of non-positive sizes passed.
Unlike others, this constructor <b>does not allocate memory</b>.
It just shares memory with an array pointed to by \c pd (for matrices \c nIncr=1 is always satisfied).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
double a[] = {1., 2., 3., 4., 5., 6.};
rmatrix m(a, 2, 3);
m(1,1) = 7.77;
std::cout << m << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << std::endl;
\endcode
prints
\code
7.77e+000 3.00e+000 5.00e+000
2.00e+000 4.00e+000 6.00e+000

7.77e+000 2.00e+000 3.00e+000
\endcode
@see http://cvmlib.com/faq.htm
@see basic_rvector::basic_rvector(TR*,tint,tint)
@param[in] pd Pointer to an array to share memory with.
@param[in] nM Number of rows.
@param[in] nN Number of columns.
*/
    basic_rmatrix(TR* pd, tint nM, tint nN)
      : BaseMatrix(pd, nM, nN, nM, nM * nN)
    {}

/**
@brief Constructor

Creates \f$m\times n\f$ \ref rmatrix object where \f$m\f$ is passed in
\c nM parameter (number of rows) and \f$n\f$ is passed in \c nN (number of columns).
Constructor throws \ref cvmexception in case of non-positive sizes passed.
This is const version,
it allocates memory and copies every element (deep copy) from external array pointed to by \c pd parameter.
It copies \c nM*nN elements total.
Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
const double a[] = {1., 2., 3., 4., 5., 6.};
rmatrix m(a, 2, 3);

m(1,1) = 7.77;
std::cout << m << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << std::endl;
\endcode
prints
\code
7.77e+000 3.00e+000 5.00e+000
2.00e+000 4.00e+000 6.00e+000

1.00e+000 2.00e+000 3.00e+000
\endcode
@see http://cvmlib.com/faq.htm
@see basic_rvector::basic_rvector(const TR*,tint,tint)
@param[in] pd Const pointer to external array.
@param[in] nM Number of rows.
@param[in] nN Number of columns.
*/
    basic_rmatrix(const TR* pd, tint nM, tint nN)
      : BaseMatrix(pd, nM, nN, nM, nM * nN)
    {}

/**
@brief Copy constructor

Creates \ref rmatrix object as a copy of a matrix \c m.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
double a[] = {1., 2., 3., 4., 5., 6.};
rmatrix m(a, 2, 3);
rmatrix mc(m);

m(1,1) = 7.77;
std::cout << m << std::endl << mc;
\endcode
prints
\code
7.77e+000 3.00e+000 5.00e+000
2.00e+000 4.00e+000 6.00e+000

1.00e+000 3.00e+000 5.00e+000
2.00e+000 4.00e+000 6.00e+000
\endcode
@param[in] m \ref rmatrix to copy from.
*/
    basic_rmatrix(const basic_rmatrix& m)
      : BaseMatrix(m.msize(), m.nsize(), m.msize(), false) {
        this->_massign(m);
    }

/**
@brief Move constructor

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to newly created object.
It's usually executed implicitly in cases like this:
\code
rvector a(b + c);
\endcode
or this
\code
rvector a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to newly created object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_rmatrix(basic_rmatrix&& m) noexcept
       : BaseMatrix(std::move(m))
    {}

/**
@brief Constructor

Creates \ref rmatrix object containing \c v.size() rows and
1 column if \c bBeColumn is \c true or 1 row and
\c v.size() columns otherwise.
After that it copies elements of a vector \c v to the matrix created.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
rvector v(3);
v(1) = 1.;
v(2) = 2.;
v(3) = 3.;

rmatrix mc(v);
rmatrix mr(v, false);

std::cout << mc << std::endl << mr;
\endcode
prints
\code
1.00e+000
2.00e+000
3.00e+000

1.00e+000 2.00e+000 3.00e+000
\endcode
@param[in] v \ref rvector to copy elements from.
@param[in] bBeColumn True to create column matrix.
*/
    explicit basic_rmatrix(const RVector& v, bool bBeColumn = true)
      : BaseMatrix(v, bBeColumn)
    {}

/**
@brief Submatrix constructor

Creates \ref rmatrix object as submatrix of a matrix \c m.
It means that the matrix object created shares memory with some part
of \c m. This part is defined by its upper left corner and its height and width (parameters
\c nHeight and \c nWidth).
\par Example:
\code
using namespace cvm;
rmatrix m(4,5);
rmatrix subm(m, 2, 2, 2, 2);
subm.set(1.);

std::cout << m;
\endcode
prints
\code
0 0 0 0 0
0 1 1 0 0
0 1 1 0 0
0 0 0 0 0
\endcode
@param[in] m Parent \ref rmatrix to attach to.
@param[in] nRow Row to start from.
@param[in] nCol Column to start from.
@param[in] nHeight Number of submatrix's rows.
@param[in] nWidth Number of submatrix's columns.
*/
    basic_rmatrix(basic_rmatrix& m, tint nRow, tint nCol, tint nHeight, tint nWidth)
      : BaseMatrix(m._sub_pointer(nRow, nCol, nHeight, nWidth),
                   nHeight, nWidth, m.ld(), nHeight * nWidth) {
        m._check_submatrix();
    }


// TODO dox, test
#if defined(CVM_USE_INITIALIZER_LISTS)
    basic_rmatrix(tint nM, tint nN, const std::initializer_list<TR>& list)
      : BaseMatrix(nM, nN, nM, false) {
        _check_ne(CVM_SIZESMISMATCH, this->size(), static_cast<tint>(list.size()));
        tint i = 0;
#ifdef CVM_USE_POOL_MANAGER
        TR* p = this->mpd;
#else
        TR* p = this->mp.get();
#endif
        for (auto it = list.begin(); it != list.end(); ++it) {
            p[i++] = *it;
        }
    }
#endif



/**
@brief Reference to element (l-value)

Operator provides access to a particular element of a calling matrix by its row and column index.
It returns \e l-value in order to make possible write access to an element.
Operator throws \ref cvmexception if \c nRow or \c nCol is out of boundaries.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const rmatrix m(a, 2, 3);
    rmatrix ms(m);

    std::cout << m(1,1) << " " << m(2,3) << std::endl << std::endl;

    ms(2,2) = 7.77;
    std::cout << ms;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.00e+00 6.00e+00

1.00e+00 3.00e+00 5.00e+00
2.00e+00 7.77e+00 6.00e+00
\endcode
@see http://cvmlib.com/faq.htm
@param[in] nRow Row index.
@param[in] nCol Column index.
@return \ref type_proxy Proxy to element (l-value).
*/
    type_proxy<TR,TR> operator () (tint nRow, tint nCol) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, nRow, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, nCol, tint(), this->nsize());
        return this->_ij_proxy_val(nRow, nCol);
    }

/**
@brief Value of element (\e not l-value)

Operator returns value of a particular element of a calling matrix by its row and column index.
Operator throws \ref cvmexception if \c nRow or \c nCol is out of boundaries.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const rmatrix m(a, 2, 3);

    std::cout << m(1,1) << " " << m(2,3) << std::endl;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.00e+00 6.00e+00
\endcode
@see http://cvmlib.com/faq.htm
@param[in] nRow Row index.
@param[in] nCol Column index.
@return TR \ref treal value.
*/
    TR operator () (tint nRow, tint nCol) const {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, nRow, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, nCol, tint(), this->nsize());
        return this->_ij_val(nRow, nCol);
    }

/**
@brief Column as l-value

Operator provides access to \c nCol-th column of a calling matrix by returning \ref rvector <b>sharing memory</b>
with it.
Operator throws \ref cvmexception if \c nCol is out of boundaries.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const rmatrix m(a, 2, 3);
    srmatrix ms(2);

    std::cout << m(2) << std::endl;

    ms(2) = m(3);
    std::cout << ms;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3.00e+00 4.00e+00

0.00e+00 5.00e+00
0.00e+00 6.00e+00
\endcode
@param[in] nCol Index of column.
@return \ref rvector Column as l-value.
*/
    RVector operator () (tint nCol) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nCol, tint(), this->nsize());
        return this->_col(nCol);
    }

/**
@brief Row as l-value

Operator provides access to \c nRow-th row of a calling matrix by returning \ref rvector <b>sharing memory</b>
with it.
Operator throws \ref cvmexception if \c nRow is out of boundaries.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const rmatrix m(a, 2, 3);
    srmatrix ms(3);

    std::cout << m[1] << std::endl;

    ms[1] = m[2];
    std::cout << ms;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.00e+00 3.00e+00 5.00e+00

2.00e+00 4.00e+00 6.00e+00
0.00e+00 0.00e+00 0.00e+00
0.00e+00 0.00e+00 0.00e+00
\endcode
@param[in] nRow Index of row.
@return \ref rvector Row as l-value.
*/
    RVector operator [] (tint nRow) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nRow, tint(), this->msize());
        return this->_row(nRow);
    }

/**
@brief Column as \em not l-value

Operator creates \ref rvector object as a copy of \c nCol-th column of a calling matrix.
Operator throws \ref cvmexception if \c nCol is out of boundaries.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const rmatrix m(a, 2, 3);
    std::cout << m(2) << std::endl;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3.00e+00 4.00e+00
\endcode
@param[in] nCol Index of column.
@return \ref rvector Column value.
*/
    RVector operator () (tint nCol) const {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nCol, tint(), this->nsize());
        return this->_col(nCol);
    }

/**
@brief Row as \em not l-value

Operator creates \ref rvector object as a copy of \c nRow-th row of a calling matrix.
Operator throws \ref cvmexception if \c nRow is out of boundaries.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const rmatrix m(a, 2, 3);
    std::cout << m[1] << std::endl;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.00e+00 3.00e+00 5.00e+00
\endcode
@param[in] nRow Index of row.
@return \ref rvector Row value.
*/
    const RVector operator [] (tint nRow) const {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nRow, tint(), this->msize());
        return this->_row(nRow);
    }

/**
@brief Diagonal as l-value

Operator provides access
to \c nDiag-th diagonal of a calling matrix
(here \c nDiag=0 for main diagonal, \c nDiag<0 for lower diagonals
and \c nDiag>0 for upper ones) by returning \ref rvector <b>sharing memory</b>
with it.
Operator throws \ref cvmexception if \c nDiag is out of boundaries.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    rmatrix m(2,3);
    m.diag(-1).set(1.);
    m.diag(0).set(2.);
    m.diag(1).set(3.);
    m.diag(2).set(4.);
    std::cout << m << std::endl;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
2 3 4
1 2 3
\endcode
@param[in] nDiag Index of diagonal (0 for main diagonal, negative for lower, positive for upper one).
@return \ref rvector Diagonal as l-value.
*/
    RVector diag(tint nDiag) {
        return this->_diag(nDiag);
    }

/**
@brief Diagonal (\em not l-value)

Operator creates \ref rvector object as a copy of \c nDiag-th diagonal of a calling matrix
where \c nDiag=0 for main diagonal, \c nDiag<0 for lower diagonals
and \c nDiag>0 for upper ones.
Operator throws \ref cvmexception if \c nDiag is out of boundaries.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    const rmatrix ms(a,3,3);
    std::cout << ms << std::endl;
    std::cout << ms.diag(0) << ms.diag(1);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1 4 7
2 5 8
3 6 9

1 5 9
4 8
\endcode
@param[in] nDiag Index of diagonal (0 for main diagonal, negative for lower, positive for upper one).
@return \ref rvector Diagonal value.
*/
    [[nodiscard]] RVector diag(tint nDiag) const {
        return this->_diag(nDiag);
    }

/**
@brief Assignment operator

Sets every element of a calling \ref rmatrix to be equal to
appropriate element of a matrix \c m and returns a reference to
the matrix changed.
Operator throws \ref cvmexception in case of different matrix dimensions.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const rmatrix m1(a, 3, 2);
    rmatrix m2(3, 2);
    m2 = m1;
    std::cout << m2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.00e+000 4.00e+000
2.00e+000 5.00e+000
3.00e+000 6.00e+000
\endcode
@param[in] m \ref rmatrix to assign from.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& operator = (const basic_rmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.nsize());
        this->_massign(m);
        return *this;
    }

/**
@brief Move assignment operator

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to a calling object.
It's usually executed implicitly in cases like this:
\code
a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to a calling object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_rmatrix& operator = (basic_rmatrix&& m) noexcept {
        // size check is in BaseMatrix
        BaseMatrix::operator = (std::move(m));
        return *this;
    }

/**
@brief Vector (as array) assignment

Sets every element of a calling matrix to be equal to appropriate element of \ref rvector \c v as an array.
Assignment is performed according to a matrix storage (by columns). It's assumed that vector passed is long
enough to fill calling matrix. Function throws \ref cvmexception otherwise.
\par Example:
\code
try {
    const double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
    const rvector v(a,8);
    rmatrix m(2,3);
    std::cout << v << std::endl;
    m.assign(v);
    std::cout << m;
}
catch(std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1 2 3 4 5 6 7 8

1 3 5
2 4 6
\endcode
@param[in] v \ref rvector to assign.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& assign(const RVector& v) {
        _check_gt(CVM_SIZESMISMATCH_GT, this->size(), v.size());
        this->_assign(v, v.incr());
        return *this;
    }

/**
@brief External array assignment

Sets every element of a calling matrix to be equal to
appropriate element of an array pointed to by parameter \c pd
and returns a reference to the matrix changed.
Assignment is performed according to a matrix storage (by columns).
It's assumed that array passed is long
enough to fill calling matrix.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
const double a[] = {1., 2., 3., 4., 5., 6.};
rmatrix m(2, 3);
m.assign(a);
std::cout << m;
\endcode
prints
\code
1.00e+000 3.00e+000 5.00e+000
2.00e+000 4.00e+000 6.00e+000
\endcode
@param[in] pd Const pointer to external array.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& assign(const TR* pd) {
        this->_assign(pd, 1);
        return *this;
    }

/**
@brief Assignment to submatrix

Sets submatrix of a calling matrix beginning with row
\c nRow and column \c nCol to a matrix \c m and
returns a reference to the matrix changed. Function throws
\ref cvmexception if \c nRow or \c nCol are not positive or matrix \c m doesn't fit.
\par Example:
\code
using namespace cvm;
rmatrix m1(4,5);
rmatrix m2(2,2);
m1.set(1.);
m2.set(2.);
m1.assign(2,3,m2);
std::cout << m1;
\endcode
prints
\code
1 1 1 1 1
1 1 2 2 1
1 1 2 2 1
1 1 1 1 1
\endcode
@param[in] nRow Row index.
@param[in] nCol Column index.
@param[in] m Reference to a matrix to assign.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& assign(tint nRow, tint nCol, const basic_rmatrix& m) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, nRow, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, nCol, tint(), this->nsize());
        _check_gt(CVM_SIZESMISMATCH_GT, m.msize() + nRow, this->msize());
        _check_gt(CVM_SIZESMISMATCH_GT, m.nsize() + nCol, this->nsize());
        this->_assign_shifted(this->_sub_pointer_nocheck(nRow, nCol),
                              m._pd(), m.msize(), m.nsize(), m.ld());
        return *this;
    }

/**
@brief Sets all elements to one value

Sets every element of a calling matrix to be equal to
parameter \c d and returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
rmatrix m(2, 3);
m.set(3.);
std::cout << m;
\endcode
prints
\code
3.00e+000 3.00e+000 3.00e+000
3.00e+000 3.00e+000 3.00e+000
\endcode
@param[in] d Value to set to.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& set(TR d) {
        this->_set(d);
        return *this;
    }

/**
@brief Changes dimensions

Changes dimensions of a calling matrix to to \c nNewM by \c nNewN
and returns a reference to the matrix changed.
In case of increasing of its size, the matrix
is filled up with zeroes.
Function throws \ref cvmexception
in case of negative dimension passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    rmatrix m(a, 2, 3);
    std::cout << m << std::endl;
    m.resize(2, 2);
    std::cout << m << std::endl;
    m.resize(3, 3);
    std::cout << m;
}
catch(std::exception& e) {
     std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.00e+000 3.00e+000 5.00e+000
2.00e+000 4.00e+000 6.00e+000

1.00e+000 3.00e+000
2.00e+000 4.00e+000

1.00e+000 3.00e+000 0.00e+000
2.00e+000 4.00e+000 0.00e+000
0.00e+000 0.00e+000 0.00e+000
\endcode
@param[in] nNewM New number of rows.
@param[in] nNewN New number of columns.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& resize(tint nNewM, tint nNewN) {
        this->_resize2(nNewM, nNewN);
        return *this;
    }

/**
@brief Matrix comparison

Operator compares calling matrix with a matrix \c m
and returns \c true if they have same sizes
and their appropriate elements differ by not more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4.};
rmatrix m1(a, 2, 2);
rmatrix m2(2, 2);
m2(1,1) = 1.; m2(1,2) = 3.;
m2(2,1) = 2.; m2(2,2) = 4.;
std::cout << (m1 == m2) << std::endl;
\endcode
prints
\code
1
\endcode
@see operator !=()
@param[in] m \ref rmatrix to compare to.
@return bool Result of comparison.
*/
    bool operator == (const basic_rmatrix& m) const {
        return this->msize() == m.msize() && this->nsize() == m.nsize() && this->_mequals(m);
    }

/**
@brief Matrix comparison

Operator compares calling matrix with a matrix \c m
and returns \c true if they have different sizes
or at least one of their appropriate elements differs by more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4.};
rmatrix m1(a, 2, 2);
rmatrix m2(2, 2);
m2(1,1) = 1.; m2(1,2) = 3.;
m2(2,1) = 2.; m2(2,2) = 4.;
std::cout << (m1 != m2) << std::endl;
\endcode
prints
\code
0
\endcode
@see operator ==()
@param[in] m \ref rmatrix to compare to.
@return bool Result of comparison.
*/
    bool operator != (const basic_rmatrix& m) const {
        return !operator == (m);
    }

/**
@brief Matrix replacement

Destroys calling matrix, creates a new one as a copy of \c m
and returns a reference to the matrix changed. Operator throws \ref cvmexception
in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    rmatrix m(3,4);
    rmatrix mc(1,1);
    m(1,2) = 1.;
    m(3,4) = 2.;
    std::cout << m << mc << std::endl;

    mc << m;
    std::cout << mc;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
0.00e+000 1.00e+000 0.00e+000 0.00e+000
0.00e+000 0.00e+000 0.00e+000 0.00e+000
0.00e+000 0.00e+000 0.00e+000 2.00e+000
0.00e+000

0.00e+000 1.00e+000 0.00e+000 0.00e+000
0.00e+000 0.00e+000 0.00e+000 0.00e+000
0.00e+000 0.00e+000 0.00e+000 2.00e+000
\endcode
@see operator =()
@param[in] m \ref rmatrix to replace by.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& operator << (const basic_rmatrix& m) {
        this->_replace(m);
        this->_massign(m);
        return *this;
    }

/**
@brief Addition operator

Creates an object of type \ref rmatrix as a sum of
a calling matrix and a matrix \c m.
Operator throws \ref cvmexception
in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const rmatrix ma(a,2,3);
    rmatrix mb(2,3);
    mb.set(1.);

    std::cout << ma + mb << std::endl;
    std::cout << ma + ma;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
2 4 6
3 5 7

2 6 10
4 8 12
\endcode
@see sum()
@param[in] m \ref rmatrix to add to a calling one.
@return Result object as a sum of matrices.
*/
    basic_rmatrix operator + (const basic_rmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.nsize());
        basic_rmatrix mSum(*this);
        mSum._mincr(m);
        return mSum;
    }

/**
@brief Subtraction operator

Creates an object of type \ref rmatrix as a difference of
a calling matrix and a matrix \c m.
It throws \ref cvmexception in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const rmatrix ma(a,2,3);
    rmatrix mb(2,3);
    mb.set(1.);

    std::cout << ma - mb << std::endl;
    std::cout << ma - ma;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
0 2 4
1 3 5

0 0 0
0 0 0
\endcode
@see diff()
@param[in] m \ref rmatrix to subtract from calling one.
@return Result object as a difference of matrices.
*/
    basic_rmatrix operator - (const basic_rmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.nsize());
        basic_rmatrix mDiff(*this);
        mDiff._mdecr(m);
        return mDiff;
    }

/**
@brief Sum of matrices

Assigns sum of
matrices \c m1 and \c m2 to a calling matrix
and returns a reference to the matrices changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const rmatrix m1(a, 2, 3);
    rmatrix m2(2, 3);
    rmatrix m(2, 3);
    m2.set(1.);
    std::cout << m.sum(m1, m2) << std::endl;
    std::cout << m.sum(m, m2);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
2 4 6
3 5 7

3 5 7
4 6 8
\endcode
@see operator +()
@param[in] m1 First \ref rmatrix summand.
@param[in] m2 Second \ref rmatrix summand.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& sum(const basic_rmatrix& m1, const basic_rmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m1.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m2.nsize());
        this->_msum(m1, m2);
        return *this;
    }

/**
@brief Difference of matrices

Assigns difference of
matrices \c m1 and \c m2 to a calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const rmatrix m1(a, 2, 3);
    rmatrix m2(2, 3);
    rmatrix m(2, 3);
    m2.set(1.);
    std::cout << m.diff(m1, m2) << std::endl;
    std::cout << m.diff(m, m2);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
0 2 4
1 3 5

-1 1 3
0 2 4
\endcode
@see operator -()
@param[in] m1 First \ref rmatrix subtrahend.
@param[in] m2 Second \ref rmatrix subtrahend.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& diff(const basic_rmatrix& m1,
                        const basic_rmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m1.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m2.nsize());
        this->_mdiff(m1, m2);
        return *this;
    }

/**
@brief Increment operator

Adds matrix \c m to a calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    rmatrix m1(2, 3);
    rmatrix m2(2, 3);
    m1.set(1.);
    m2.set(2.);

    m1 += m2;
    std::cout << m1 << std::endl;

    // well, you can do this too, but temporary object would be created
    m2 += m2;
    std::cout << m2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3 3 3
3 3 3

4 4 4
4 4 4
\endcode
@see operator +()
@see sum()
@param[in] m \ref rmatrix to increment by.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& operator += (const basic_rmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.nsize());
        this->_mincr(m);
        return *this;
    }

/**
@brief Decrement operator

Subtracts matrix \c m from calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    rmatrix m1(2, 3);
    rmatrix m2(2, 3);
    m1.set(1.);
    m2.set(2.);

    m1 -= m2;
    std::cout << m1 << std::endl;

    // well, you can do this too, but temporary object would be created
    m2 -= m2;
    std::cout << m2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1 -1 -1
-1 -1 -1

0 0 0
0 0 0
\endcode
@see operator -()
@see diff()
@param[in] m \ref rmatrix to decrement by.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& operator -= (const basic_rmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.nsize());
        this->_mdecr(m);
        return *this;
    }

/**
@brief Unary minus operator

Creates an object of type \ref rmatrix as
a calling matrix multiplied by \c -1.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.};
const rmatrix ma(a, 2, 3);
std::cout << - ma;
\endcode
prints
\code
-1 -3 -5
-2 -4 -6
\endcode
@return Result object.
*/
    basic_rmatrix operator - () const {
        const TR mone(-1.);
        basic_rmatrix mRes(*this);
        mRes._scalr(mone);
        return mRes;
    }

/**
@brief Multiply by number operator

Creates an object of type \ref rmatrix as a product of
a calling matrix and number \c dMult.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.};
rmatrix m(a, 2, 3);
std::cout << m * 2.;
\endcode
prints
\code
2 6 10
4 8 12
\endcode
@see operator *=()
@param[in] dMult Number to multiply by.
@return Result object.
*/
    basic_rmatrix operator * (TR dMult) const {
        basic_rmatrix mRes(*this);
        mRes._scalr(dMult);
        return mRes;
    }

/**
@brief Divide by number operator

Creates an object of type \ref rmatrix as a quotient of
a calling matrix and number \c dDiv.
It throws \ref cvmexception if \c dDiv has absolute value equal or less
than \ref cvmMachMin() (the smallest normalized positive number).
It also throws exception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    rmatrix m(a, 2, 3);
    std::cout << m / 2.;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
5.00e-01 1.50e+00 2.50e+00
1.00e+00 2.00e+00 3.00e+00
\endcode
@see operator /=()
@param[in] dDiv Number to divide by.
@return Result object.
*/
    basic_rmatrix operator / (TR dDiv) const {
        basic_rmatrix mRes(*this);
        mRes._div(dDiv);
        return mRes;
    }

/**
@brief Multiply by number and assign

Multiplies calling matrix by number \c dMult and returns a reference to
the matrix changed.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.};
rmatrix m(a, 2, 3);
m *= 2.;
std::cout << m;
\endcode
prints
\code
2 6 10
4 8 12
\endcode
@see operator *(TR) const
@param[in] dMult Number to multiply by.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& operator *= (TR dMult) {
        this->_scalr(dMult);
        return *this;
    }

/**
@brief Divide by number and assign

Divides calling matrix by number \c dDiv and returns a reference to
the matrix changed. It throws \ref cvmexception if \c dDiv
has absolute value equal or less than \ref cvmMachMin() (the
smallest normalized positive number).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);

try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    rmatrix m(a, 2, 3);
    m /= 2.;
    std::cout << m;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
5.00e-01 1.50e+00 2.50e+00
1.00e+00 2.00e+00 3.00e+00
\endcode
@see operator /(TR) const
@param[in] dDiv Number to divide by.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& operator /= (TR dDiv) {
        this->_div(dDiv);
        return *this;
    }

/**
@brief Matrix normalizer

Normalizes calling matrix so its Euclidean \ref norm()
becomes equal to 1 if it was greater than \ref cvmMachMin() (the
smallest normalized positive number) before the call.
Does nothing otherwise.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
double a[] = {1., 2., 3., 4., 5., 6.};
rmatrix m(a, 2, 3);
m.normalize();
std::cout << m << m.norm() << std::endl;
\endcode
prints
\code
1.05e-01 3.14e-01 5.24e-01
2.10e-01 4.19e-01 6.29e-01
1
\endcode
@return Reference to changed calling matrix.
*/
    basic_rmatrix& normalize() {
        this->_normalize();
        return *this;
    }

/**
@brief Matrix transposition

Creates an object of type \c rmatrix as transposed calling matrix.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    rmatrix m(a,2,3);
    std::cout << m << std::endl << ~m;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1 3 5
2 4 6

1 2
3 4
5 6
\endcode
@return Result object.
*/
    basic_rmatrix operator ~ () const {
        basic_rmatrix mRes(this->nsize(), this->msize());
        mRes._transp_m(*this);
        return mRes;
    }

/**
@brief Matrix transposition

Sets calling matrix to be equal to a matrix \c m transposed.
Function throws \ref cvmexception in case of not appropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    rmatrix m(a,2,3);
    rmatrix mt(3,2);
    std::cout << m << std::endl;
    mt.transpose(m);
    std::cout << mt;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1 3 5
2 4 6

1 2
3 4
5 6
\endcode
@param[in] m \ref rmatrix to transpose.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& transpose(const basic_rmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.msize());
        if (this->get() == m.get()) {
            basic_rmatrix mTmp(m);
            this->_transp_m(mTmp);
        } else {
            this->_transp_m(m);
        }
        return *this;
    }

/**
@brief Matrix transposition (in-place)

Makes calling matrix to be equal to transposed itself.
Function throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    rmatrix m(a,2,3);
    std::cout << m << std::endl;
    std::cout << m.transpose();
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1 3 5
2 4 6

1 2
3 4
5 6
\endcode
@return Reference to changed calling matrix.
*/
    basic_rmatrix& transpose() {
        basic_rmatrix mTmp(*this);
        this->_resize2(this->nsize(), this->msize());
        this->_transp_m(mTmp);
        return *this;
    }

/**
@brief Matrix-vector product

Creates an object of type \ref rvector as a product of a calling matrix and a vector \c v.
Function throws \ref cvmexception if the number of columns of the calling matrix
differs from size of the vector \c v. Use \ref basic_rvector::mult(const basic_rmatrix<TR>&,const basic_rvector<TR>&)
to avoid new object creation.
\par Example:
\code
using namespace cvm;
try {
    rmatrix m(2, 3);
    rvector v(3);
    m.set(1.);
    v.set(1.);
    std::cout << m * v;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3 3
\endcode
@see basic_rvector::mult(const basic_rmatrix<TR>&,const basic_rvector<TR>&)
@param[in] v \ref rvector to compute product with.
@return Result object.
*/
    RVector operator * (const RVector& v) const {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), v.size());
        RVector vRes(this->msize());
        this->_multiply(vRes, v, false);
        return vRes;
    }

/**
@brief Matrix-matrix product

Creates an object of type \ref rmatrix as a product of a calling matrix and a matrix \c m.
Operator throws \ref cvmexception if number of columns of a calling matrix
differs from number of rows of the matrix \c m.
Use \ref mult() to avoid new object creation.
\par Example:
\code
using namespace cvm;
try {
    rmatrix m1(2, 3);
    rmatrix m2(3, 2);
    m1.set(1.);
    m2.set(1.);
    std::cout << m1 * m2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3 3
3 3
\endcode
@param[in] m \ref rmatrix to compute product with.
@return Result object.
*/
    basic_rmatrix operator * (const basic_rmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.msize());
        basic_rmatrix mRes(this->msize(), m.nsize());
        mRes.mult(*this, m);
        return mRes;
    }

/**
@brief Matrix-matrix product

Sets calling matrix to be equal to product of a matrix \c m1 by matrix \c m2
and returns a reference to the matrix changed.
Function throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    rmatrix m1(2, 3);
    rmatrix m2(3, 2);
    rmatrix m(2, 2);
    m1.set(1.);
    m2.set(1.);
    std::cout << m.mult(m1, m2) << std::endl;
    std::cout << m1.mult(m, m1);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3 3
3 3

6 6 6
6 6 6
\endcode
@param[in] m1 \ref rmatrix multiplicand.
@param[in] m2 \ref rmatrix multiplier.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& mult(const basic_rmatrix& m1,
                        const basic_rmatrix& m2) {
        this->_mult(m1, m2);
        return *this;
    }

/**
@brief Rank-1 update

Sets calling matrix to be
a rank-1 update of vectors \c vCol and \c vRow.
Function throws \ref cvmexception if number of rows of a calling matrix
is not equal to size of \c vCol or number of columns of a calling matrix
is not equal to size of \c vRow.
The rank-1 update of vector-column \f$x\f$ of size \f$m\f$ and
vector-row \f$y\f$ of size \f$n\f$ is defined as \f$m\times n\f$ matrix
\f[\begin{pmatrix}
x_1 y_1 & x_1 y_2 & \cdots & x_1 y_n \\
x_2 y_1 & x_2 y_2 & \cdots & x_2 y_n \\
\hdotsfor{4} \\
x_m y_1 & x_m y_2 & \cdots & x_m y_n
\end{pmatrix} =
\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_m
\end{pmatrix}
\begin{pmatrix}
y_1 & y_2 & \cdots & y_n
\end{pmatrix}.\f]
\par Example:
\code
using namespace cvm;
try {
    rvector vc(3), vr(2);
    rmatrix m(3, 2);
    vc(1) = 1.;
    vc(2) = 2.;
    vc(3) = 3.;
    vr(1) = 4.;
    vr(2) = 5.;
    std::cout << m.rank1update(vc, vr);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
4 5
8 10
12 15
\endcode
@param[in] vCol Column \ref rvector.
@param[in] vRow Row \ref rvector.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& rank1update(const RVector& vCol,
                               const RVector& vRow) {
        const TR one(1.);
        this->_check_rank1update();
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vCol.size());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), vRow.size());
        this->_vanish();
        __ger<TR,basic_rmatrix, RVector>(*this, vCol, vRow, one);
        return *this;
    }

/**
@brief Rows swap

Swaps two rows of a calling matrix and returns a reference to
the matrix changed. \c n1 and \c n2 are indexes of rows to be swapped.
Function throws \ref cvmexception if one of the parameters is out of boundaries.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    rmatrix m(a, 3, 2);
    std::cout << m << std::endl;
    std::cout << m.swap_rows(2,3);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1 4
2 5
3 6

1 4
3 6
2 5
\endcode
@param[in] n1 Row index to swap.
@param[in] n2 Row index to swap.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& swap_rows(tint n1, tint n2) {
        this->_swap_rows(n1, n2);
        return *this;
    }

/**
@brief Columns swap

Swaps two columnss of a calling matrix and returns a reference to
the matrix changed. \c n1 and \c n2 are indexes of columns to be swapped.
Function throws \ref cvmexception if one of the parameters is out of boundaries.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    rmatrix m(a, 2, 3);
    std::cout << m << std::endl;
    std::cout << m.swap_cols(2,3);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1 3 5
2 4 6

1 5 3
2 6 4
\endcode
@param[in] n1 Column index to swap.
@param[in] n2 Column index to swap.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& swap_cols(tint n1, tint n2) {
        this->_swap_cols(n1, n2);
        return *this;
    }

/**
@brief Linear solver

Sets calling matrix to be equal to solution \f$X\f$ of
matrix linear equation \f$A*X=B\f$ where parameter \c mA is square matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$. Function returns a reference to the matrix changed.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    srmatrix ma(3);
    rmatrix  mb(3,4);
    rmatrix  mx(3,4);
    double dErr;
    ma.randomize(-10., 10.);
    mb.randomize(-10., 10.);
    mx.solve(ma, mb, dErr);
    std::cout << ma * mx - mb << dErr << std::endl;
}
catch(cvmexception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1.78e-015 +1.80e-016 -8.88e-016 +0.00e+000
+0.00e+000 -1.33e-015 +8.88e-016 +0.00e+000
+0.00e+000 +0.00e+000 -1.78e-015 +0.00e+000
+2.02e-015
\endcode
@see solve(const basic_srmatrix<TR>&,const basic_rmatrix<TR>&)
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& solve(const basic_srmatrix<TR>& mA, const basic_rmatrix& mB, TR& dErr) {
        return _solve_helper(mA, mB, dErr, 0);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Sets calling matrix to be equal to solution \f$X\f$ of
matrix linear equation \f$A^T*X=B\f$  (which is equivalent to \f$X^T*A=B^T\f$)
where parameter \c mA is square matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$. Function returns a reference to the matrix changed.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    srmatrix ma(3);
    rmatrix  mb(3,4);
    rmatrix  mx(3,4);
    double dErr;
    ma.randomize(-10., 10.);
    mb.randomize(-10., 10.);
    mx.solve_tran(ma, mb, dErr);
    std::cout << ~ma * mx - mb << dErr << std::endl;
    std::cout << ~mx * ma - ~mb;
}
catch(cvmexception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1.776e-015 -8.882e-016 -3.553e-015 +4.441e-016
+0.000e+000 +3.553e-015 +1.243e-014 -8.882e-016
+0.000e+000 +3.553e-015 -1.066e-014 +0.000e+000
+4.357e-015
-1.776e-015 +0.000e+000 +0.000e+000
-8.882e-016 +3.553e-015 +3.553e-015
-3.553e-015 +1.243e-014 -1.066e-014
+4.441e-016 -8.882e-016 +0.000e+000
\endcode
@see solve_tran(const basic_srmatrix<TR>&,const basic_rmatrix<TR>&)
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& solve_tran(const basic_srmatrix<TR>& mA, const basic_rmatrix& mB, TR& dErr) {
        return _solve_helper(mA, mB, dErr, 1);
    }

/**
@brief Linear solver

Sets calling matrix to be equal to solution \f$X\f$ of
matrix linear equation \f$A*X=B\f$ where parameter \c mA is square matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$. Function returns a reference to the matrix changed.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    srmatrix ma(3);
    rmatrix  mb(3,4);
    rmatrix  mx(3,4);
    ma.randomize(-10., 10.);
    mb.randomize(-10., 10.);
    mx.solve(ma, mb);
    std::cout << ma * mx - mb;
}
catch(cvmexception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1.78e-015 +1.80e-016 -8.88e-016 +0.00e+000
+0.00e+000 -1.33e-015 +8.88e-016 +0.00e+000
+0.00e+000 +0.00e+000 -1.78e-015 +0.00e+000
\endcode
@see solve(const basic_srmatrix<TR>&,const basic_rmatrix<TR>&)
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] mB \ref rmatrix \f$B\f$.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& solve(const basic_srmatrix<TR>& mA,
                         const basic_rmatrix& mB) {
        TR dErr(0.);
        return this->solve(mA, mB, dErr);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Sets calling matrix to be equal to solution \f$X\f$ of
matrix linear equation \f$A^T*X=B\f$  (which is equivalent to \f$X^T*A=B^T\f$)
where parameter \c mA is square matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$. Function returns a reference to the matrix changed.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    srmatrix ma(3);
    rmatrix  mb(3,4);
    rmatrix  mx(3,4);
    ma.randomize(-10., 10.);
    mb.randomize(-10., 10.);
    mx.solve_tran(ma, mb);
    std::cout << ~ma * mx - mb << std::endl;
    std::cout << ~mx * ma - ~mb;
}
catch(cvmexception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1.776e-015 -8.882e-016 -3.553e-015 +4.441e-016
+0.000e+000 +3.553e-015 +1.243e-014 -8.882e-016
+0.000e+000 +3.553e-015 -1.066e-014 +0.000e+000

-1.776e-015 +0.000e+000 +0.000e+000
-8.882e-016 +3.553e-015 +3.553e-015
-3.553e-015 +1.243e-014 -1.066e-014
+4.441e-016 -8.882e-016 +0.000e+000
\endcode
@see solve_tran(const basic_srmatrix<TR>&,const basic_rmatrix<TR>&)
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] mB \ref rmatrix \f$B\f$.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& solve_tran(const basic_srmatrix<TR>& mA,
                              const basic_rmatrix& mB) {
        TR dErr(0.);
        return this->solve_tran(mA, mB, dErr);
    }

/**
@brief LU factorization based linear solver

Sets calling matrix to be equal to solution \f$X\f$ of a matrix linear equation
\f$A*X=B\f$ where parameter \c mA is square matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref srmatrix::low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c mB is matrix \f$B\f$.
Function returns a reference to the matrix changed.
It also sets output parameter \c dErr to be equal to the norm of computation error.
This function is useful when you need to solve few linear equations
of kind \f$A*X=B\f$ with the same matrix \f$A\f$ and different matrices \f$B\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time. Throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    srmatrix ma(a,3);
    srmatrix mLU(3);
    rmatrix  mb1(3,2);
    rmatrix  mb2(3,2);
    rmatrix  mx1(3,2);
    rmatrix  mx2(3,2);
    iarray   nPivots(3);
    double   dErr = 0.;
    mb1.randomize(-1.,3.);
    mb2.randomize(2.,5.);

    mLU.low_up(ma, nPivots);
    std::cout << mx1.solve_lu(ma, mLU, nPivots, mb1, dErr);
    std::cout << dErr << std::endl;
    std::cout << mx2.solve_lu(ma, mLU, nPivots, mb2) << std::endl;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3.85e+00 5.90e-01
-4.23e+00 -3.67e+00
2.10e+00 2.55e+00
7.04e-15
9.49e+00 8.93e+00
-1.00e+01 -1.42e+01
4.21e+00 7.55e+00

0.00e+00 0.00e+00
0.00e+00 0.00e+00
4.44e-16 -1.11e-16

4.44e-16 0.00e+00
-4.44e-16 0.00e+00
8.88e-16 0.00e+00
\endcode
@see srmatrix::low_up()
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& solve_lu(const basic_srmatrix<TR>& mA,
                            const basic_srmatrix<TR>& mLU, const tint* pPivots,
                            const basic_rmatrix& mB, TR& dErr) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mA.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mB.nsize());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), mB.msize());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), mLU.msize());
        mA._solve(mB, *this, dErr, mLU, pPivots, 0);
        return *this;
    }

/**
@brief LU factorization based linear solver

Sets calling matrix to be equal to solution \f$X\f$ of a matrix linear equation
\f$A*X=B\f$ where parameter \c mA is square matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref srmatrix::low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c mB is matrix \f$B\f$.
Function returns a reference to the matrix changed.
This function is useful when you need to solve few linear equations
of kind \f$A*X=B\f$ with the same matrix \f$A\f$ and different matrices \f$B\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time. Throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    srmatrix ma(a,3);
    srmatrix mLU(3);
    rmatrix  mb1(3,2);
    rmatrix  mb2(3,2);
    rmatrix  mx1(3,2);
    rmatrix  mx2(3,2);
    iarray   nPivots(3);
    mb1.randomize(-1.,3.);
    mb2.randomize(2.,5.);

    mLU.low_up(ma, nPivots);
    std::cout << mx1.solve_lu(ma, mLU, nPivots, mb1);
    std::cout << std::endl;
    std::cout << mx2.solve_lu(ma, mLU, nPivots, mb2) << std::endl;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3.85e+00 5.90e-01
-4.23e+00 -3.67e+00
2.10e+00 2.55e+00

9.49e+00 8.93e+00
-1.00e+01 -1.42e+01
4.21e+00 7.55e+00

0.00e+00 0.00e+00
0.00e+00 0.00e+00
4.44e-16 -1.11e-16

4.44e-16 0.00e+00
-4.44e-16 0.00e+00
8.88e-16 0.00e+00
\endcode
@see srmatrix::low_up()
@param[in] mA \ref srmatrix \f$A\f$.
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] mB \ref rmatrix \f$B\f$.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& solve_lu(const basic_srmatrix<TR>& mA,
                            const basic_srmatrix<TR>& mLU, const tint* pPivots,
                            const basic_rmatrix& mB) {
        TR dErr(0.);
        return this->solve_lu(mA, mLU, pPivots, mB, dErr);
    }

/**
@brief Singular value decomposition

Creates \ref rvector of singular values
\f[
\sigma_1\ge\sigma_2\ge\dots\ge\sigma_{\min(m,n)}\ge 0
\f]
of \f$m\times n\f$ real matrix \f$A\f$ (calling matrix).
These values are the main diagonal of a matrix \f$\Sigma\f$ of the singular value decomposition
\f[
A=U\Sigma V^H
\f]
where \f$U\f$ and \f$V\f$ are orthogonal for real \f$A\f$ and unitary for complex \f$A\f$.
\f$V^H\f$ is transposed \f$V\f$ for real one and Hermitian conjugated \f$V\f$ for complex one.
First \f$\min(m, n)\f$ columns of matrices \f$U\f$ and \f$V\f$ are left and right singular
vectors of \f$A\f$ respectively. Singular values and singular vectors satisfy
\f[
Av_i=\sigma_i u_i\ \ \text{ and }\ \ A^Hu_i=\sigma_i v_i
\f]
where \f$u_i\f$ and \f$v_i\f$ are \f$i\f$-th columns of \f$U\f$ and \f$V\f$ respectively.
Function throws \ref cvmexception in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(5);
try {
    double m[] = {1., -1., 1., 2., -2., 1.,
                  3., -2., 1., 0., -2., 1.};
    rmatrix mA(m,4,3);
    std::cout << mA.svd();
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
4.95615e+000 2.50884e+000 3.77219e-001
\endcode
@return Result object (singular values in decreasing order).
*/
    [[nodiscard]] RVector svd() const {
        RVector vRes(_cvm_min<tint>(this->msize(), this->nsize()));
        this->_svd(vRes, nullptr, nullptr);
        return vRes;
    }

/**
@brief Singular value decomposition

Creates \ref rvector of singular values
\f[
\sigma_1\ge\sigma_2\ge\dots\ge\sigma_{\min(m,n)}\ge 0
\f]
of \f$m\times n\f$ real matrix \f$A\f$ (calling matrix).
These values are the main diagonal of a matrix \f$\Sigma\f$ of the singular value decomposition
\f[
A=U\Sigma V^H
\f]
where \f$U\f$ and \f$V\f$ are orthogonal for real \f$A\f$ and unitary for complex \f$A\f$.
\f$V^H\f$ is transposed \f$V\f$ for real one and Hermitian conjugated \f$V\f$ for complex one.
First \f$\min(m, n)\f$ columns of matrices \f$U\f$ and \f$V\f$ are left and right singular
vectors of \f$A\f$ respectively. Singular values and singular vectors satisfy
\f[
Av_i=\sigma_i u_i\ \ \text{ and }\ \ A^Hu_i=\sigma_i v_i
\f]
where \f$u_i\f$ and \f$v_i\f$ are \f$i\f$-th columns of \f$U\f$ and \f$V\f$ respectively.
Function sets output parameter \c mU to be equal to square matrix \f$U\f$ of size \f$m\times m\f$ and
\c mVH to be equal to square matrix \f$V^H\f$ of size \f$n\times n\f$.
Function throws \ref cvmexception
in case of inappropriate calling object size (it must be equal to \f$\min(m,n)\f$), matrix \c mU size
(must be \f$m\times m\f$), matrix \c mVH size (must be \f$n\times n\f$) or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double m[] = {1., -1., 1., 2., -2., 1.,
                  3., -2., 1., 0., -2., 1.};
    rmatrix mA(m,4,3);
    rmatrix mSigma(4,3);
    rvector v;
    srmatrix mU(4), mVH(3);

    v << mA.svd(mU, mVH);
    mSigma.diag(0) = v;

    std::cout << mU << std::endl;
    std::cout << mVH << std::endl;
    std::cout << mSigma << std::endl;

    std::cout << (mA * ~mVH - mU * mSigma).norm() << std::endl;
    std::cout << (~mA * mU - ~(mSigma * mVH)).norm() << std::endl;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-4.84e-01 1.95e-01 1.15e-02 -8.53e-01
2.17e-01 -3.41e-01 -8.89e-01 -2.13e-01
6.62e-01 7.16e-01 -6.18e-02 -2.13e-01
-5.29e-01 5.78e-01 -4.53e-01 4.26e-01

-2.21e-01 8.54e-01 -4.72e-01
9.59e-01 1.04e-01 -2.62e-01
-1.75e-01 -5.11e-01 -8.42e-01

4.96e+00 0.00e+00 0.00e+00
0.00e+00 2.51e+00 0.00e+00
0.00e+00 0.00e+00 3.77e-01
0.00e+00 0.00e+00 0.00e+00

1.37e-15
2.48e-15
\endcode
@param[out] mU \ref srmatrix \f$U\f$.
@param[out] mVH \ref srmatrix \f$V^H\f$.
@return Result object (singular values in decreasing order).
*/
    RVector svd(basic_srmatrix<TR>& mU,
                basic_srmatrix<TR>& mVH) const {
        RVector vRes(_cvm_min<tint>(this->msize(), this->nsize()));
        this->_svd(vRes, &mU, &mVH);
        return vRes;
    }

/**
@brief Pseudo (generalized) inversion

Creates an object of type \ref rmatrix as pseudo inverted calling matrix.
Matrix pseudo inversion (aka Moore-Penrose generalized inversion) definition:
\f$n\times m\f$ matrix \f$A^{+}\f$ is
<em>pseudo inversion</em> of \f$m\times n\f$ matrix \f$A\f$ if the following two equations
are satisfied:
\f[
AA^{+}A=A,\quad A^{+}=QA^H=A^HP
\f]
where \f$Q\f$ and \f$P\f$ are some matrices. To compute the pseudo inversion, we use
singular value decomposition
\f[
A = U\Sigma V^H
\f]
of a matrix \f$A\f$, thus
\f[
A^{+} = V\Sigma^{-1}U^{H},
\f]
where \f$\Sigma^{-1}\f$ is diagonal \f$n\times m\f$ matrix having inverted
diagonal values of a matrix \f$\Sigma\f$ if they are greater than some threshold,
and zeros otherwise. The \c threshold parameter sets  the minimum distinguishable
from zero singular value to be used to compute the pseudo inversion.
All values equal or less than the threshold are treated as zeros.
Function throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    rmatrix mA(3,4);
    mA(1,1) =  1.; mA(1,2) = -1.; mA(1,3) =  2.; mA(1,4) =  0.;
    mA(2,1) = -1.; mA(2,2) =  2.; mA(2,3) = -3.; mA(2,4) =  1.;
    mA(3,1) =  0.; mA(3,2) =  1.; mA(3,3) = -1.; mA(3,4) =  1.;
    rmatrix mX = mA.pinv(1.e-13);
    std::cout << mX << (mA * mX * mA - mA).norm2() << std::endl;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+3.3333333e-001 -2.1510571e-016 +3.3333333e-001
+1.1111111e-001 +1.1111111e-001 +2.2222222e-001
+2.2222222e-001 -1.1111111e-001 +1.1111111e-001
+4.4444444e-001 +1.1111111e-001 +5.5555556e-001
+2.5460202e-015
\endcode
@see svd()
@param[in] threshold Algorithm threshold.
@return Result object.
*/
    [[nodiscard]] basic_rmatrix pinv(TR threshold = basic_cvmMachSp<TR>()) const {
        basic_rmatrix mAx(this->nsize(), this->msize());
        this->_pinv(mAx, threshold);
        return mAx;
    }

/**
@brief Pseudo (generalized) inversion

Sets calling matrix to be equal to a matrix \c mA pseudo inverted.
Matrix pseudo inversion (aka Moore-Penrose generalized inversion) definition:
\f$n\times m\f$ matrix \f$A^{+}\f$ is
<em>pseudo inversion</em> of \f$m\times n\f$ matrix \f$A\f$ if the following two equations
are satisfied:
\f[
AA^{+}A=A,\quad A^{+}=QA^H=A^HP
\f]
where \f$Q\f$ and \f$P\f$ are some matrices. To compute the pseudo inversion, we use
singular value decomposition
\f[
A = U\Sigma V^H
\f]
of a matrix \f$A\f$, thus
\f[
A^{+} = V\Sigma^{-1}U^{H},
\f]
where \f$\Sigma^{-1}\f$ is diagonal \f$n\times m\f$ matrix having inverted
diagonal values of a matrix \f$\Sigma\f$ if they are greater than some threshold,
and zeros otherwise. The \c threshold parameter sets  the minimum distinguishable
from zero singular value to be used to compute the pseudo inversion.
All values equal or less than the threshold are treated as zeros.
Function throws \ref cvmexception in case of not appropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);
try {
    rmatrix mA(3,4);
    rmatrix mX(4,3);
    mA(1,1) =  1.; mA(1,2) = -1.; mA(1,3) =  2.; mA(1,4) =  0.;
    mA(2,1) = -1.; mA(2,2) =  2.; mA(2,3) = -3.; mA(2,4) =  1.;
    mA(3,1) =  0.; mA(3,2) =  1.; mA(3,3) = -1.; mA(3,4) =  1.;
    mX.pinv(mA, 1.e-13);
    std::cout << mX << (mA * mX * mA - mA).norm2() << std::endl;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+3.333e-001 -2.151e-016 +3.333e-001
+1.111e-001 +1.111e-001 +2.222e-001
+2.222e-001 -1.111e-001 +1.111e-001
+4.444e-001 +1.111e-001 +5.556e-001
+2.546e-015
\endcode
@see svd()
@param[in] mA Matrix to pseudo invert.
@param[in] threshold Algorithm threshold.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& pinv(const basic_rmatrix& mA, TR threshold = basic_cvmMachSp<TR>()) {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mA.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mA.nsize());
        mA._pinv(*this, threshold);
        return *this;
    }

/**
@brief Overdetermined or underdetermined linear solver

Creates an object of type \ref rmatrix as a
solution of overdetermined or underdetermined linear systems
\f[
A*x=b
\f]
for \f$m\times n\f$ matrix \f$A\f$ (or transposed one) where
\f$b\f$ is a vector of length \f$k\f$
combined to
\f[
A*X=B
\f]
for multiple vectors \f$b\f$ stored as columns of \f$k\times l\f$ matrix \f$B\f$ where
\f$k=m\f$ in non-transposed case and \f$k=n\f$ otherwise.
The algorithm uses QR or LQ factorization of \f$A\f$.
It is assumed that \f$A\f$ has full rank, infinity returned otherwise.
Internally function uses \c DGELS LAPACK routines.
If \f$m>n\f$ and \c transpose=false or \f$m<n\f$ and \c transpose=true, then
the system is overdetermined, thus the algorithm tries to find the least squares solution \f$x\f$
of the problem
\f[
\|A*x-b\|_2\to\min\quad\text{or}\quad\|A^H*x-b\|_2\to\min\
\f]
respectively. Real number \c dErr (or vector \c vErr for multiple vector \f$b\f$ case) returns residual sum of squares.
The system is underdetermined otherwise, and the algorithm finds its minimum norm solution.
In this case \c bErr is set to zero. In both cases the solution computed
satisfies \f$\newcommand{\pinv}{\operatorname{pinv}} x=\pinv(A)*b\f$, but this algorithm is faster than pseudo inversion.
Function throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix a(7, 5);
rmatrix b(7, 2);
rmatrix bt(5, 2);
rvector bv(5);
rvector vErr(2);
treal dErr;
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bt.randomize(-10., 10.);
bv.randomize(-10., 10.);

rmatrix x = a.gels(false, b, vErr);
rvector vt = a.gels(true, bv, dErr);
rmatrix xt(7,2);
xt.gels(true, a, bt, vErr);

std::cout << (a.pinv()*b - x).norm() << std::endl;
std::cout << (~a.pinv()*bv - vt).norm() << std::endl;
std::cout << (~a.pinv()*bt - xt).norm() << std::endl;
\endcode
prints
\code
+2.6295387e-015
+5.8515615e-015
+6.6462869e-015
\endcode
@see pinv()
@param[in] transpose True to compute for transposed matrix \f$A\f$ (calling matrix).
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] vErr Norms of computation errors.
@return Result object.
*/
    basic_rmatrix gels(bool transpose, const basic_rmatrix& mB,
                       basic_rvector<TR>& vErr) const {
        _check_ne(CVM_SIZESMISMATCH, mB.nsize(), vErr.size());
        _check_ne(CVM_SIZESMISMATCH, mB.msize(), transpose ? this->nsize() : this->msize());
        basic_rmatrix mA(*this);  // this algorithm overrides A
        basic_rmatrix mX;
        __gels(transpose, mA, mB, mX, vErr);
        return mX;
    }

/**
@brief Overdetermined or underdetermined linear solver

Sets calling matrix to a
solution of overdetermined or underdetermined linear systems
\f[
A*x=b
\f]
for \f$m\times n\f$ matrix \f$A\f$ (or transposed one, parameter \c mA) where
\f$b\f$ is a vector of length \f$k\f$
combined to
\f[
A*X=B
\f]
for multiple vectors \f$b\f$ stored as columns of \f$k\times l\f$ matrix \f$B\f$ where
\f$k=m\f$ in non-transposed case and \f$k=n\f$ otherwise.
The algorithm uses QR or LQ factorization of \f$A\f$.
It is assumed that \f$A\f$ has full rank, infinity returned otherwise.
Internally function uses \c DGELS LAPACK routines.
If \f$m>n\f$ and \c transpose=false or \f$m<n\f$ and \c transpose=true, then
the system is overdetermined, thus the algorithm tries to find the least squares solution \f$x\f$
of the problem
\f[
\|A*x-b\|_2\to\min\quad\text{or}\quad\|A^H*x-b\|_2\to\min\
\f]
respectively. Real number \c dErr (or vector \c vErr for multiple vector \f$b\f$ case) returns residual sum of squares.
The system is underdetermined otherwise, and the algorithm finds its minimum norm solution.
In this case \c bErr is set to zero. In both cases the solution computed
satisfies \f$\newcommand{\pinv}{\operatorname{pinv}} x=\pinv(A)*b\f$, but this algorithm is faster than pseudo inversion.
Function throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix a(7, 5);
rmatrix b(7, 2);
rmatrix bt(5, 2);
rvector bv(5);
rvector vErr(2);
treal dErr;
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bt.randomize(-10., 10.);
bv.randomize(-10., 10.);

rmatrix x = a.gels(false, b, vErr);
rvector vt = a.gels(true, bv, dErr);
rmatrix xt(7,2);
xt.gels(true, a, bt, vErr);

std::cout << (a.pinv()*b - x).norm() << std::endl;
std::cout << (~a.pinv()*bv - vt).norm() << std::endl;
std::cout << (~a.pinv()*bt - xt).norm() << std::endl;
\endcode
prints
\code
+2.6295387e-015
+5.8515615e-015
+6.6462869e-015
\endcode
@see pinv()
@param[in] transpose True to compute for transposed matrix \f$A\f$ (calling matrix).
@param[in] mA \ref rmatrix \f$A\f$.
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] vErr Norms of computation errors.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& gels(bool transpose, const basic_rmatrix& mA, const basic_rmatrix& mB,
                        basic_rvector<TR>& vErr) {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mB.nsize());
        _check_ne(CVM_SIZESMISMATCH, mB.nsize(), vErr.size());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), transpose ? mA.msize() : mA.nsize());
        _check_ne(CVM_SIZESMISMATCH, mB.msize(), transpose ? mA.nsize() : mA.msize());
        basic_rmatrix mA2(mA);  // this algorithm overrides A
        __gels(transpose, mA2, mB, *this, vErr);
        return *this;
    }

/**
@brief Overdetermined or underdetermined linear solver

Creates an object of type \ref rvector as a
solution of overdetermined or underdetermined linear system
\f[
A*x=b
\f]
for \f$m\times n\f$ matrix \f$A\f$ (or transposed one) where
\f$b\f$ is a vector of length \f$k\f$
where
\f$k=m\f$ in non-transposed case and \f$k=n\f$ otherwise.
The algorithm uses QR or LQ factorization of \f$A\f$.
It is assumed that \f$A\f$ has full rank, infinity returned otherwise.
Internally function uses \c DGELS LAPACK routines.
If \f$m>n\f$ and \c transpose=false or \f$m<n\f$ and \c transpose=true, then
the system is overdetermined, thus the algorithm tries to find the least squares solution \f$x\f$
of the problem
\f[
\|A*x-b\|_2\to\min\quad\text{or}\quad\|A^H*x-b\|_2\to\min\
\f]
respectively. Real number \c dErr returns residual sum of squares.
The system is underdetermined otherwise, and the algorithm finds its minimum norm solution.
In this case \c bErr is set to zero. In both cases the solution computed
satisfies \f$\newcommand{\pinv}{\operatorname{pinv}} x=\pinv(A)*b\f$, but this algorithm is faster than pseudo inversion.
Function throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix a(7, 5);
rmatrix b(7, 2);
rmatrix bt(5, 2);
rvector bv(5);
rvector vErr(2);
treal dErr;
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bt.randomize(-10., 10.);
bv.randomize(-10., 10.);

rmatrix x = a.gels(false, b, vErr);
rvector vt = a.gels(true, bv, dErr);
rmatrix xt(7,2);
xt.gels(true, a, bt, vErr);

std::cout << (a.pinv()*b - x).norm() << std::endl;
std::cout << (~a.pinv()*bv - vt).norm() << std::endl;
std::cout << (~a.pinv()*bt - xt).norm() << std::endl;
\endcode
prints
\code
+2.6295387e-015
+5.8515615e-015
+6.6462869e-015
\endcode
@see pinv()
@param[in] transpose True to compute for transposed matrix \f$A\f$ (calling matrix).
@param[in] vB \ref rvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    basic_rvector<TR> gels(bool transpose, const basic_rvector<TR>& vB,
                           TR& dErr) const {
        _check_ne(CVM_SIZESMISMATCH, vB.size(), transpose ? this->nsize() : this->msize());
        basic_rmatrix mA(*this);  // this algorithm overrides A
        basic_rmatrix mB(vB, vB.size(), 1);
        basic_rmatrix mX;
        basic_rvector<TR> vErr(1);
        __gels(transpose, mA, mB, mX, vErr);
        dErr = vErr(0);
        const TR* pResult = mX;
        return basic_rvector<TR>(pResult, mX.msize());
    }

/**
@brief Linear least squares problem

Function creates \ref rmatrix object with the minimum-norm solutions to linear least squares problems
\f[
\|A*x-b\|_2\to\min
\f]
using complete orthogonal factorization of \f$m\times n\f$ calling matrix \f$A\f$.
Here \f$b\f$ is a vector of length \f$m\f$.
Multiple vectors \f$b\f$ are stored as columns of \f$m\times l\f$ matrix \f$B\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c DGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix a(4, 5);
rmatrix b(4, 2);
rvector bv(4);
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bv.randomize(-10., 10.);
tint rank;

rmatrix x = a.gelsy(b, rank);
rvector xv = a.gelsy(bv, rank);
rmatrix x2(5,2);
x2.gelsy(a, b, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*x2 - b).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+3.3539762e-014
+5.2545344e-015
+3.3539762e-014
+4 +4
\endcode
@see gelss()
@see gelsd()
@see rvector::gelsy()
@see rank()
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Result object.
*/
    basic_rmatrix gelsy(const basic_rmatrix& mB, tint& rank,
                        TR tol = basic_cvmMachSp<TR>()) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mB.msize());
        basic_rmatrix mA(*this);  // this algorithm overrides A
        basic_rmatrix mX;
        __gelsy(mA, mB, mX, tol, rank);
        return mX;
    }

/**
@brief Linear least squares problem

Function sets calling matrix to the minimum-norm solutions to linear least squares problems
\f[
\|A*x-b\|_2\to\min
\f]
using complete orthogonal factorization of \f$m\times n\f$ matrix \f$A\f$ (parameter \c mA).
Here \f$b\f$ is a vector of length \f$m\f$.
Multiple vectors \f$b\f$ are stored as columns of \f$m\times l\f$ matrix \f$B\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c DGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix a(4, 5);
rmatrix b(4, 2);
rvector bv(4);
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bv.randomize(-10., 10.);
tint rank;

rmatrix x = a.gelsy(b, rank);
rvector xv = a.gelsy(bv, rank);
rmatrix x2(5,2);
x2.gelsy(a, b, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*x2 - b).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+3.3539762e-014
+5.2545344e-015
+3.3539762e-014
+4 +4
\endcode
@see gelss()
@see gelsd()
@see rvector::gelsy()
@see rank()
@param[in] mA \ref rmatrix \f$A\f$.
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& gelsy(const basic_rmatrix& mA, const basic_rmatrix& mB,
                         tint& rank, TR tol = basic_cvmMachSp<TR>()) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mA.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mB.nsize());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), mB.msize());
        basic_rmatrix mA2(mA);  // this algorithm overrides A
        __gelsy(mA2, mB, *this, tol, rank);
        return *this;
    }

/**
@brief Linear least squares problem

Function creates \ref rvector object with the minimum-norm solution to linear least squares problem
\f[
\|A*x-b\|_2\to\min
\f]
using complete orthogonal factorization of \f$m\times n\f$ calling matrix \f$A\f$.
Here \f$b\f$ is a vector of length \f$m\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c DGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix a(4, 5);
rmatrix b(4, 2);
rvector bv(4);
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bv.randomize(-10., 10.);
tint rank;

rmatrix x = a.gelsy(b, rank);
rvector xv = a.gelsy(bv, rank);
rmatrix x2(5,2);
x2.gelsy(a, b, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*x2 - b).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+3.3539762e-014
+5.2545344e-015
+3.3539762e-014
+4 +4
\endcode
@see gelss()
@see gelsd()
@see rvector::gelsy()
@see rank()
@param[in] vB \ref rvector \f$b\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Result object.
*/
    basic_rvector<TR> gelsy(const basic_rvector<TR>& vB, tint& rank,
                            TR tol = basic_cvmMachSp<TR>()) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vB.size());
        basic_rmatrix mA(*this);  // this algorithm overrides A
        basic_rmatrix mB(vB, vB.size(), 1);
        basic_rmatrix mX;
        __gelsy(mA, mB, mX, tol, rank);
        const TR* pResult = mX;
        return basic_rvector<TR>(pResult, mX.msize());
    }

/**
@brief Linear least squares problem

Function creates \ref rmatrix object with the minimum-norm solutions to linear least squares problems
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ calling matrix \f$A\f$.
Here \f$b\f$ is a vector of length \f$m\f$.
Multiple vectors \f$b\f$ are stored as columns of \f$m\times l\f$ matrix \f$B\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c DGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix a(4, 5);
rmatrix b(4, 2);
rvector bv(4);
rvector sv(4);
tint rank;
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bv.randomize(-10., 10.);

rmatrix x = a.gelss(b, sv, rank);
rvector xv = a.gelss(bv, sv, rank);
rmatrix xt(5,2);
xt.gelss(a, b, sv, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*xt - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+1.9169279e-014
+8.9260826e-015
+1.9169279e-014
+8.1402897e-015
+4 +4
\endcode
@see gelsy()
@see gelsd()
@see rvector::gelss()
@see rank()
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] sv Singular values of \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Result object.
*/
    basic_rmatrix gelss(const basic_rmatrix& mB, basic_rvector<TR>& sv, tint& rank,
                        TR tol = basic_cvmMachSp<TR>()) const {
        return _gels_sd(true, mB, sv, rank, tol);
    }

/**
@brief Linear least squares problem

Function sets calling matrix to the minimum-norm solutions to linear least squares problems
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ matrix \f$A\f$ (parameter \c mA).
Here \f$b\f$ is a vector of length \f$m\f$.
Multiple vectors \f$b\f$ are stored as columns of \f$m\times l\f$ matrix \f$B\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c DGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix a(4, 5);
rmatrix b(4, 2);
rvector bv(4);
rvector sv(4);
tint rank;
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bv.randomize(-10., 10.);

rmatrix x = a.gelss(b, sv, rank);
rvector xv = a.gelss(bv, sv, rank);
rmatrix xt(5,2);
xt.gelss(a, b, sv, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*xt - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+1.9169279e-014
+8.9260826e-015
+1.9169279e-014
+8.1402897e-015
+4 +4
\endcode
@see gelsy()
@see gelsd()
@see rvector::gelss()
@see rank()
@param[in] mA \ref rmatrix \f$A\f$.
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] sv Singular values of \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& gelss(const basic_rmatrix& mA, const basic_rmatrix& mB, basic_rvector<TR>& sv,
                         tint& rank, TR tol = basic_cvmMachSp<TR>()) {
        _gels_sd(true, mA, mB, sv, rank, tol);
        return *this;
    }

/**
@brief Linear least squares problem

Function creates \ref rvector object with the minimum-norm solution to linear least squares problem
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ calling matrix \f$A\f$.
Here \f$b\f$ is a vector of length \f$m\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c DGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix a(4, 5);
rmatrix b(4, 2);
rvector bv(4);
rvector sv(4);
tint rank;
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bv.randomize(-10., 10.);

rmatrix x = a.gelss(b, sv, rank);
rvector xv = a.gelss(bv, sv, rank);
rmatrix xt(5,2);
xt.gelss(a, b, sv, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*xt - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+1.9169279e-014
+8.9260826e-015
+1.9169279e-014
+8.1402897e-015
+4 +4
\endcode
@see gelsy()
@see gelsd()
@see rvector::gelss()
@see rank()
@param[in] vB \ref rvector \f$b\f$.
@param[out] sv Singular values of \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Result object.
*/
    basic_rvector<TR> gelss(const basic_rvector<TR>& vB, basic_rvector<TR>& sv,
                            tint& rank,
                            TR tol = basic_cvmMachSp<TR>()) const {
        return _gels_sd(true, vB, sv, rank, tol);
    }

/**
@brief Linear least squares problem

Function creates \ref rmatrix object with the minimum-norm solutions to linear least squares problems
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ calling matrix \f$A\f$ and divide and conquer method.
Here \f$b\f$ is a vector of length \f$m\f$.
Multiple vectors \f$b\f$ are stored as columns of \f$m\times l\f$ matrix \f$B\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c DGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix a(4, 5);
rmatrix b(4, 2);
rvector bv(4);
rvector sv(4);
tint rank;
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bv.randomize(-10., 10.);

rmatrix x = a.gelsd(b, sv, rank);
rvector xv = a.gelsd(bv, sv, rank);
rmatrix xt(5,2);
xt.gelsd(a, b, sv, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*xt - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+1.0341178e-014
+6.0443462e-015
+1.0341178e-014
+8.9260826e-015
+4 +4
\endcode
@see gelsy()
@see gelss()
@see rvector::gelss()
@see rank()
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] sv Singular values of \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Result object.
*/
    basic_rmatrix gelsd(const basic_rmatrix& mB, basic_rvector<TR>& sv,
                        tint& rank,
                        TR tol = basic_cvmMachSp<TR>()) const {
        return _gels_sd(false, mB, sv, rank, tol);
    }

/**
@brief Linear least squares problem

Function sets calling matrix to the minimum-norm solutions to linear least squares problems
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ matrix \f$A\f$ (parameter \c mA) and divide and conquer method.
Here \f$b\f$ is a vector of length \f$m\f$.
Multiple vectors \f$b\f$ are stored as columns of \f$m\times l\f$ matrix \f$B\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c DGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix a(4, 5);
rmatrix b(4, 2);
rvector bv(4);
rvector sv(4);
tint rank;
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bv.randomize(-10., 10.);

rmatrix x = a.gelsd(b, sv, rank);
rvector xv = a.gelsd(bv, sv, rank);
rmatrix xt(5,2);
xt.gelsd(a, b, sv, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*xt - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+1.0341178e-014
+6.0443462e-015
+1.0341178e-014
+8.9260826e-015
+4 +4
\endcode
@see gelsy()
@see gelss()
@see rvector::gelss()
@see rank()
@param[in] mA \ref rmatrix \f$A\f$.
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] sv Singular values of \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& gelsd(const basic_rmatrix& mA,
                         const basic_rmatrix& mB, basic_rvector<TR>& sv,
                         tint& rank, TR tol = basic_cvmMachSp<TR>()) {
        _gels_sd(false, mA, mB, sv, rank, tol);
        return *this;
    }

/**
@brief Linear least squares problem

Function creates \ref rvector object with the minimum-norm solution to linear least squares problem
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ calling matrix \f$A\f$ and divide and conquer method.
Here \f$b\f$ is a vector of length \f$m\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c DGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;

rmatrix a(4, 5);
rmatrix b(4, 2);
rvector bv(4);
rvector sv(4);
tint rank;
a.randomize(-10., 10.);
b.randomize(-10., 10.);
bv.randomize(-10., 10.);

rmatrix x = a.gelsd(b, sv, rank);
rvector xv = a.gelsd(bv, sv, rank);
rmatrix xt(5,2);
xt.gelsd(a, b, sv, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*xt - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+1.0341178e-014
+6.0443462e-015
+1.0341178e-014
+8.9260826e-015
+4 +4
\endcode
@see gelsy()
@see gelss()
@see rvector::gelss()
@see rank()
@param[in] vB \ref rvector \f$b\f$.
@param[out] sv Singular values of \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Result object.
*/
    basic_rvector<TR> gelsd(const basic_rvector<TR>& vB, basic_rvector<TR>& sv,
                            tint& rank,
                            TR tol = basic_cvmMachSp<TR>()) const {
        return _gels_sd(false, vB, sv, rank, tol);
    }

/**
@brief Matrix rank

Returns rank of a calling matrix as number of
singular values with normalized absolute value greater than or
equal to parameter \c tol (this is the <em>largest relative spacing</em> by default).
Function throws \ref cvmexception in case of convergence error.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    rmatrix m(a,3,4);

    std::cout << m << m.rank() << std::endl;
    m(3,4) = 13.;
    std::cout << m.rank() << std::endl;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1 4 7 10
2 5 8 11
3 6 9 12
2
3
\endcode
@see rvector::svd()
@see rvector::normalize()
@see cvmMachSp()
@param[in] tol Rank computation tolerance.
@return tint Rank as integer.
*/
    [[nodiscard]] tint rank(TR tol = basic_cvmMachSp<TR>()) const {
        tint nRank = 0;
        RVector vS(_cvm_min<tint>(this->msize(), this->nsize()));
        this->_svd(vS, nullptr, nullptr);
        vS.normalize();
        for (; nRank < vS.size(); ++nRank) {
            if (vS[nRank * this->incr()] < tol) break;
        }
        return nRank;
    }

// QR factorization
// Case 1: "economy" mode, A is (m x n) and Q is (m x n) and R is (n x n)
/**
@brief QR factorization ("economy" mode)

Computes QR factorization as
\f[
M=QR
\f]
where
\f$M\f$ is calling matrix, orthogonal matrix \f$Q\f$
and upper triangular (trapezoidal) matrix \f$R\f$ are \c mQ and \c mR output parameters
respectively. This version implements so-called "economy" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times n\f$ matrix \f$Q\f$
and \f$n\times n\f$ matrix \f$R\f$. See also \ref qr(basic_srmatrix<TR>&,basic_rmatrix<TR>&)const  "full" version.
Function throws \ref cvmexception in case if inappropriate
sizes of the operands passed.
\par Example:
\code
using namespace cvm;

treal a[] = {1., 2., 3., 4., 5., 6.};
const cvm::rmatrix mh(a, 2, 3);
const cvm::rmatrix mv(a, 3, 2);
cvm::srmatrix s2(2), s3(3);
cvm::rmatrix  h(2,3), v(3,2);

mh.qr(h,s3);
std::cout << (eye_real(2) - ~rmatrix(h,1,1,2,2)*rmatrix(h,1,1,2,2)).norm()
          << " " << (mh - h * s3).norm() << std::endl;
mh.qr(s2,h);
std::cout << (eye_real(2) - ~s2 * s2).norm()
          << " " << (mh - s2 * h).norm() << std::endl;
mv.qr(v,s2);
std::cout << (eye_real(2) - ~v * v).norm()
          << " " << (mv - v * s2).norm() << std::endl;
mv.qr(s3,v);
std::cout << (eye_real(3) - ~s3 * s3).norm()
          << " " << (mv - s3 * v).norm() << std::endl;
\endcode
prints
\code
+4.6933177e-16 +2.2342807e-15
+4.6933177e-16 +2.2342807e-15
+5.1302953e-16 +1.4432899e-15
+5.2889959e-16 +1.4432899e-15
\endcode
@param[out] mQ \ref rmatrix \f$Q\f$.
@param[out] mR \ref srmatrix \f$R\f$.
*/
    void qr(basic_rmatrix<TR>& mQ, basic_srmatrix<TR>& mR) const {
        this->_qr_rs(mQ, mR);
    }

// Case 2: full mode, A is (m x n) and Q is (m x m) and R is (m x n)
/**
@brief QR factorization ("full" mode)

Computes QR factorization as
\f[
M=QR
\f]
where
\f$M\f$ is calling matrix, orthogonal matrix \f$Q\f$
and upper triangular (trapezoidal) matrix \f$R\f$ are \c mQ and \c mR output parameters
respectively. This version implements so-called "full" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times m\f$ matrix \f$Q\f$ and \f$m\times n\f$ matrix \f$R\f$.
See also \ref qr(basic_rmatrix<TR>&,basic_srmatrix<TR>&)const  "economy" version.
Function throws \ref cvmexception in case if inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;

treal a[] = {1., 2., 3., 4., 5., 6.};
const cvm::rmatrix mh(a, 2, 3);
const cvm::rmatrix mv(a, 3, 2);
cvm::srmatrix s2(2), s3(3);
cvm::rmatrix  h(2,3), v(3,2);

mh.qr(h,s3);
std::cout << (eye_real(2) - ~rmatrix(h,1,1,2,2)*rmatrix(h,1,1,2,2)).norm()
          << " " << (mh - h * s3).norm() << std::endl;
mh.qr(s2,h);
std::cout << (eye_real(2) - ~s2 * s2).norm()
          << " " << (mh - s2 * h).norm() << std::endl;
mv.qr(v,s2);
std::cout << (eye_real(2) - ~v * v).norm()
          << " " << (mv - v * s2).norm() << std::endl;
mv.qr(s3,v);
std::cout << (eye_real(3) - ~s3 * s3).norm()
          << " " << (mv - s3 * v).norm() << std::endl;
\endcode
prints
\code
+4.6933177e-16 +2.2342807e-15
+4.6933177e-16 +2.2342807e-15
+5.1302953e-16 +1.4432899e-15
+5.2889959e-16 +1.4432899e-15
\endcode
@param[out] mQ \ref srmatrix \f$Q\f$.
@param[out] mR \ref rmatrix \f$R\f$.
*/
    void qr(basic_srmatrix<TR>& mQ, basic_rmatrix<TR>& mR) const {
        this->_qr_sr(mQ, mR);
    }

// LQ factorization
// Case 1: "economy" mode, A is (m x n) and L is (m x m) and Q is (m x n)
/**
@brief LQ factorization ("economy" mode)

Computes LQ factorization as
\f[
M=LQ
\f]
where \f$M\f$ is calling matrix, lower triangular (trapezoidal) matrix \f$L\f$
and orthogonal matrix \f$Q\f$ are \c mL and \c mQ output parameters respectively.
This version implements so-called "economy" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times m\f$ matrix \f$L\f$
and \f$m\times n\f$ matrix \f$Q\f$. See also \ref lq(basic_rmatrix<TR>&,basic_srmatrix<TR>&)const  "full" version.
Function throws \ref cvmexception in case of inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;

treal a[] = {1., 2., 3., 4., 5., 6.};
const cvm::rmatrix mh(a, 2, 3);
const cvm::rmatrix mv(a, 3, 2);
cvm::srmatrix s2(2), s3(3);
cvm::rmatrix h(2,3), v(3,2);

mh.lq(s2,h);
std::cout << (eye_real(2) - h * ~h).norm() << " " << (mh - s2 * h)
             .norm() << std::endl;
mv.lq(s3,v);
std::cout << (eye_real(2) - ~rmatrix(v,1,1,2,2) * rmatrix(v,1,1,2,2))
             .norm() << " " << (mv - s3 * v).norm() << std::endl;
mh.lq(h,s3);
std::cout << (eye_real(3) - s3 * ~s3).norm() << " " << (mh - h * s3)
             .norm() << std::endl;
mv.lq(v,s2);
std::cout << (eye_real(2) - s2 * ~s2).norm() << " " << (mv - v * s2)
             .norm() << std::endl;
\endcode
prints
\code
+8.6355085e-016 +3.3893638e-015
+1.9229627e-016 +1.6011864e-015
+1.0030483e-015 +3.3893638e-015
+1.9229627e-016 +1.6011864e-015
\endcode
@param[out] mL \ref srmatrix \f$L\f$.
@param[out] mQ \ref rmatrix \f$Q\f$.
*/
    void lq(basic_srmatrix<TR>& mL, basic_rmatrix<TR>& mQ) const {
        this->_lq_sr(mL, mQ);
    }

// Case 2: full mode, A is (m x n) and L is (m x n) and Q is (n x n)
/**
@brief LQ factorization ("full" mode)

Computes LQ factorization as
\f[
M=LQ
\f]
where \f$M\f$ is calling matrix, lower triangular (trapezoidal) matrix \f$L\f$
and orthogonal matrix \f$Q\f$ are \c mL and \c mQ output parameters respectively.
This version implements so-called "full" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times n\f$ matrix \f$L\f$ and \f$n\times n\f$ matrix \f$Q\f$.
See also \ref lq(basic_srmatrix<TR>&,basic_rmatrix<TR>&)const  "economy" version.
Function throws \ref cvmexception in case of inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;

treal a[] = {1., 2., 3., 4., 5., 6.};
const cvm::rmatrix mh(a, 2, 3);
const cvm::rmatrix mv(a, 3, 2);
cvm::srmatrix s2(2), s3(3);
cvm::rmatrix h(2,3), v(3,2);

mh.lq(s2,h);
std::cout << (eye_real(2) - h * ~h).norm() << " " << (mh - s2 * h)
             .norm() << std::endl;
mv.lq(s3,v);
std::cout << (eye_real(2) - ~rmatrix(v,1,1,2,2) * rmatrix(v,1,1,2,2))
             .norm() << " " << (mv - s3 * v).norm() << std::endl;
mh.lq(h,s3);
std::cout << (eye_real(3) - s3 * ~s3).norm() << " " << (mh - h * s3)
             .norm() << std::endl;
mv.lq(v,s2);
std::cout << (eye_real(2) - s2 * ~s2).norm() << " " << (mv - v * s2)
             .norm() << std::endl;
\endcode
prints
\code
+8.6355085e-016 +3.3893638e-015
+1.9229627e-016 +1.6011864e-015
+1.0030483e-015 +3.3893638e-015
+1.9229627e-016 +1.6011864e-015
\endcode
@param[out] mL \ref rmatrix \f$L\f$.
@param[out] mQ \ref srmatrix \f$Q\f$.
*/
    void lq(basic_rmatrix<TR>& mL, basic_srmatrix<TR>& mQ) const {
        this->_lq_rs(mL, mQ);
    }

// RQ factorization
// Case 1: "economy" mode, A is (m x n) and R is (m x m) and Q is (m x n)
/**
@brief RQ factorization ("economy" mode)

Computes RQ factorization as
\f[
M=RQ
\f]
where \f$M\f$ is calling matrix, upper triangular matrix \f$R\f$
and orthogonal matrix \f$Q\f$ are \c mR and \c mQ output parameters respectively.
This version implements so-called "economy" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times m\f$ matrix \f$R\f$
and \f$m\times n\f$ matrix \f$Q\f$. See also \ref rq(basic_rmatrix<TR>&,basic_srmatrix<TR>&)const  "full" version.
Following <a href="http://www.netlib.org/scalapack/slug/node57.html" target="_blank">this definition</a>
the implementation assumes that \f$m\le n\f$ is satisfied and throws \ref cvmexception otherwise.
Function also throws \ref cvmexception in case of inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;

treal a[] = {1., 2., 3., 4., 5., 6.};
const cvm::rmatrix mh(a, 2, 3);
const cvm::rmatrix mv(a, 3, 2);
cvm::srmatrix s2(2), s3(3);
cvm::rmatrix  h(2,3), v(3,2);

mh.rq(h,s3);
std::cout << (eye_real(2) - rmatrix(s3,2,1,2,3) * ~rmatrix(s3,2,1,2,3))
             .norm() << " " << (mh - h * s3).norm() << std::endl;

mh.rq(s2,h);
std::cout << (eye_real(2) - h * ~h).norm()
          << " " << (mh - s2 * h).norm() << std::endl;
\endcode
prints
\code
+5.5511151e-016 +2.0471501e-015
+5.5511151e-016 +2.0471501e-015
\endcode
@param[out] mR \ref srmatrix \f$R\f$.
@param[out] mQ \ref rmatrix \f$Q\f$.
*/
    void rq(basic_srmatrix<TR>& mR, basic_rmatrix<TR>& mQ) const {
        this->_rq_sr(mR, mQ);
    }

// Case 2: full mode, A is (m x n) and R is (m x n) and Q is (n x n)
/**
@brief RQ factorization ("full" mode)

Computes RQ factorization as
\f[
M=RQ
\f]
where \f$M\f$ is calling matrix, upper triangular matrix \f$R\f$
and orthogonal matrix \f$Q\f$ are \c mR and \c mQ output parameters respectively.
This version implements so-called "full" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times n\f$ matrix \f$R\f$ and \f$n\times n\f$ matrix \f$Q\f$.
See also \ref rq(basic_srmatrix<TR>&,basic_rmatrix<TR>&)const  "economy" version.
Following <a href="http://www.netlib.org/scalapack/slug/node57.html" target="_blank">this definition</a>
the implementation assumes that \f$m\le n\f$ is satisfied and throws \ref cvmexception otherwise.
Function also throws \ref cvmexception in case of inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;

treal a[] = {1., 2., 3., 4., 5., 6.};
const cvm::rmatrix mh(a, 2, 3);
const cvm::rmatrix mv(a, 3, 2);
cvm::srmatrix s2(2), s3(3);
cvm::rmatrix  h(2,3), v(3,2);

mh.rq(h,s3);
std::cout << (eye_real(2) - rmatrix(s3,2,1,2,3) * ~rmatrix(s3,2,1,2,3))
             .norm() << " " << (mh - h * s3).norm() << std::endl;

mh.rq(s2,h);
std::cout << (eye_real(2) - h * ~h).norm()
          << " " << (mh - s2 * h).norm() << std::endl;
\endcode
prints
\code
+5.5511151e-016 +2.0471501e-015
+5.5511151e-016 +2.0471501e-015
\endcode
@param[out] mR \ref rmatrix \f$R\f$.
@param[out] mQ \ref srmatrix \f$Q\f$.
*/
    void rq(basic_rmatrix<TR>& mR, basic_srmatrix<TR>& mQ) const {
        this->_rq_rs(mR, mQ);
    }

// QL factorization
// Case 1: "economy" mode, A is (m x n) and Q is (m x n) and L is (n x n)
/**
@brief QL factorization ("economy" mode)

Computes QL factorization as
\f[
M=QL
\f]
where \f$M\f$ is calling matrix, orthogonal matrix \f$Q\f$
and lower triangular matrix \f$L\f$ are \c mQ and \c mL output parameters respectively.
This version implements so-called "economy" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times n\f$ matrix \f$Q\f$
and \f$n\times n\f$ matrix \f$L\f$. See also \ref ql(basic_srmatrix<TR>&,basic_rmatrix<TR>&)const  "full" version.
Following <a href="http://www.netlib.org/scalapack/slug/node57.html" target="_blank">this definition</a>
the implementation assumes that \f$m\ge n\f$ is satisfied and throws \ref cvmexception otherwise.
Function also throws \ref cvmexception in case of inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;

treal a[] = {1., 2., 3., 4., 5., 6.};
const cvm::rmatrix mv(a, 3, 2);
cvm::srmatrix s2(2), s3(3);
cvm::rmatrix v(3,2);

mv.ql(v,s2);
std::cout << (eye_real(2) - ~v * v).norm()
          << " " << (mv - v * s2).norm() << std::endl;

mv.ql(s3,v);
std::cout << (eye_real(2) - ~rmatrix(s3,1,2,3,2) * rmatrix(s3,1,2,3,2))
             .norm() << " " << (mv - s3 * v).norm() << std::endl;
\endcode
prints
\code
+0.0000000e+000 +2.0947646e-015
+0.0000000e+000 +2.0947646e-015
\endcode
@param[out] mQ \ref rmatrix \f$Q\f$.
@param[out] mL \ref srmatrix \f$L\f$.
*/
    void ql(basic_rmatrix<TR>& mQ, basic_srmatrix<TR>& mL) const {
        this->_ql_rs(mQ, mL);
    }

// Case 2: full mode, A is (m x n) and Q is (m x m) and L is (m x n)
/**
@brief QL factorization ("full" mode)

Computes QL factorization as
\f[
M=QL
\f]
where \f$M\f$ is calling matrix, orthogonal matrix \f$Q\f$
and lower triangular matrix \f$L\f$ are \c mQ and \c mL output parameters respectively.
This version implements so-called "full" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times m\f$ matrix \f$Q\f$ and \f$m\times n\f$ matrix \f$L\f$.
See also \ref ql(basic_rmatrix<TR>&,basic_srmatrix<TR>&)const  "economy" version.
Following <a href="http://www.netlib.org/scalapack/slug/node57.html" target="_blank">this definition</a>
the implementation assumes that \f$m\ge n\f$ is satisfied and throws \ref cvmexception otherwise.
Function also throws \ref cvmexception in case of inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;

treal a[] = {1., 2., 3., 4., 5., 6.};
const cvm::rmatrix mv(a, 3, 2);
cvm::srmatrix s2(2), s3(3);
cvm::rmatrix v(3,2);

mv.ql(v,s2);
std::cout << (eye_real(2) - ~v * v).norm()
          << " " << (mv - v * s2).norm() << std::endl;

mv.ql(s3,v);
std::cout << (eye_real(2) - ~rmatrix(s3,1,2,3,2) * rmatrix(s3,1,2,3,2))
             .norm() << " " << (mv - s3 * v).norm() << std::endl;
\endcode
prints
\code
+0.0000000e+000 +2.0947646e-015
+0.0000000e+000 +2.0947646e-015
\endcode
@param[out] mQ \ref srmatrix \f$Q\f$.
@param[out] mL \ref rmatrix \f$L\f$.
*/
    void ql(basic_srmatrix<TR>& mQ, basic_rmatrix<TR>& mL) const {
        this->_ql_sr(mQ, mL);
    }

// this += alpha * v_col * v_row (rank-1 update)
/**
@brief Rank-1 update matrix-vector operation

Calls one of \c DGER routines of the \c BLAS library
performing rank-1 update matrix-vector operation defined as
\f[
M=\alpha\,\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_m
\end{pmatrix}
\begin{pmatrix}
y_1 & y_2 & \cdots & y_n
\end{pmatrix} + M,
\f]
where \f$\alpha\f$ is real number (parameter \c alpha),
\f$M\f$ is calling matrix and \f$x\f$ and \f$y\f$ are real vectors (parameters \c vCol and \c vRow respectively).
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
Function is <b>not applicable</b> to objects of the classes \ref srbmatrix and \ref srsmatrix
(i.e. \ref cvmexception would be thrown).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(4);
try {
    double alpha = 1.3;
    rmatrix m(3,4);
    rvector vc(3);
    rvector vr(4);
    m.randomize(-1., 2.); vc.randomize(-1., 3.); vr.randomize(0., 2.);

    std::cout << m + vc.rank1update(vr) * alpha << std::endl;
    std::cout << m.ger(alpha, vc, vr);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1.7127e-01 2.9410e+00 1.3449e+00 3.6055e+00
1.9057e+00 2.6726e+00 1.7134e+00 2.2154e+00
1.7217e-01 1.3508e+00 8.8949e-01 2.2551e+00

-1.7127e-01 2.9410e+00 1.3449e+00 3.6055e+00
1.9057e+00 2.6726e+00 1.7134e+00 2.2154e+00
1.7217e-01 1.3508e+00 8.8949e-01 2.2551e+00
\endcode
@see http://www.netlib.org/blas
@see rank1update()
@see basic_rvector<TR>::rank1update()
@param[in] alpha Multiplier \f$\alpha\f$.
@param[in] vCol \ref rvector \f$x\f$.
@param[in] vRow \ref rvector \f$y\f$.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& ger(TR alpha, const RVector& vCol,
                       const RVector& vRow) {
        this->_check_ger();
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vCol.size());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), vRow.size());
        __ger<TR,basic_rmatrix, RVector>(*this, vCol, vRow, alpha);
        return *this;
    }

// this = alpha * m1 * m2 + beta * this
/**
@brief Generic matrix-matrix operation

Calls one of \c DGEMM routines of the BLAS library
performing matrix-matrix operation defined as
\f[
M=\alpha\,\mathcal{T}(M_1)\cdot\mathcal{T}(M_2) + \beta M,
\f]
where \f$\alpha\f$ and \f$\beta\f$ are real numbers
(parameters \c dAlpha and \c dBeta), \f$M\f$ is calling matrix
and \f$M_1\f$ and \f$M_2\f$ are matrices (parameters \c m1
and \c m2 respectively). Function \f$\mathcal{T}(M_i)\f$
transposes matrix \f$M_i\f$ if appropriate boolean
parameter \c bTrans* is equal to \c true and does nothing otherwise.
Function returns a reference to the matrix changed and throws
\ref cvmexception in case of inappropriate sizes of the operands.
Function is <b>not applicable</b> to objects of the classes
\ref srbmatrix and \ref srsmatrix (i.e. exception of
type \ref cvmexception would be thrown).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(4);
try {
    double alpha = 1.3;
    double beta = -0.7;
    rmatrix m1(4,3); rmatrix m2(4,3);
    rmatrix m(3,3);
    m.randomize(-1., 2.); m1.randomize(-1., 3.); m2.randomize(0., 2.);
    std::cout << ~m1 * m2 * alpha + m * beta << std::endl;
    std::cout << m.gemm(m1, true, m2, false, alpha, beta);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
5.0504e+00 6.8736e+00 3.1171e+00
2.3915e+00 2.2544e+00 3.9205e+00
3.4607e+00 3.5351e+00 4.8622e+00

5.0504e+00 6.8736e+00 3.1171e+00
2.3915e+00 2.2544e+00 3.9205e+00
3.4607e+00 3.5351e+00 4.8622e+00
\endcode
@see http://www.netlib.org/blas
@param[in] m1 \ref rmatrix \f$M_1\f$.
@param[in] bTrans1 Transpose \ref rmatrix \f$M_1\f$.
@param[in] m2 \ref rmatrix \f$M_2\f$.
@param[in] bTrans2 Transpose \ref rmatrix \f$M_2\f$.
@param[in] dAlpha Multiplier \f$\alpha\f$.
@param[in] dBeta Multiplier \f$\beta\f$.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& gemm(const basic_rmatrix& m1, bool bTrans1, const basic_rmatrix& m2,
                        bool bTrans2, TR dAlpha, TR dBeta) {
        this->_check_gemm();
        _check_ne(CVM_SIZESMISMATCH, this->msize(), bTrans1 ? m1.nsize() : m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), bTrans2 ? m2.msize() : m2.nsize());
        _check_ne(CVM_SIZESMISMATCH, bTrans1 ? m1.msize() : m1.nsize(), bTrans2 ? m2.nsize() : m2.msize());
        this->_gemm(bTrans1, m1, bTrans2, m2, dAlpha, dBeta);
        return *this;
    }

// this = alpha*a*b + beta*this or this = alpha*b*a + beta*this  where a is symmetric
/**
@brief Generic symmetric matrix-matrix operation

Calls one of \c DSYMM routines of the BLAS library performing one of
matrix-matrix operations defined as
\f[
M=\alpha\,M_s\cdot M_1 + \beta M\quad\text{or}\quad M=\alpha\,M_1\cdot M_s + \beta M,
\f]
where \f$\alpha\f$ and \f$\beta\f$ are real numbers
(parameters \c dAlpha and \c dBeta), \f$M\f$ is calling matrix,
\f$M_s\f$ is symmetric matrix and \f$M_1\f$ is real matrix (parameters \c ms
and \c m respectively).
First operation is performed if \c bLeft passed is \c true and second one otherwise.
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
Function is <b>not applicable</b> to objects of the class \ref srbmatrix
(i.e. \ref cvmexception would be thrown).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(4);
try {
    double alpha = 1.3;
    double beta = -0.7;
    rmatrix m1(3,4);
    rmatrix m2(4,3);
    srsmatrix ms(3);
    rmatrix m(3,4);
    m.randomize(-1., 2.); m1.randomize(-1., 3.); m2.randomize(0., 2.);
    ms.randomize(-3., 1.);

    std::cout << ms * m1 * alpha + m * beta << std::endl;
    std::cout << m.symm(true, ms, m1, alpha, beta) << std::endl;

    m.resize(4,3);
    std::cout << m2 * ms * alpha + m * beta << std::endl;
    std::cout << m.symm(false, ms, m2, alpha, beta);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-3.3733e+00 -5.0566e+00 -6.3018e+00 -5.4907e+00
-1.8629e+00 -1.5133e+00 -1.1372e+00 -2.5557e+00
-3.5695e+00 -1.0012e+01 -1.4239e+00 -6.1786e-01

-3.3733e+00 -5.0566e+00 -6.3018e+00 -5.4907e+00
-1.8629e+00 -1.5133e+00 -1.1372e+00 -2.5557e+00
-3.5695e+00 -1.0012e+01 -1.4239e+00 -6.1786e-01

-6.4072e+00 7.0534e-01 1.5349e+00
-4.8219e+00 -6.9891e+00 -5.1766e+00
6.8503e-01 3.5828e+00 -3.2174e+00
2.3469e-01 -9.3921e-01 -2.1961e+00

-6.4072e+00 7.0534e-01 1.5349e+00
-4.8219e+00 -6.9891e+00 -5.1766e+00
6.8503e-01 3.5828e+00 -3.2174e+00
2.3469e-01 -9.3921e-01 -2.1961e+00
\endcode
@see http://www.netlib.org/blas
@param[in] bLeft Perfoem left-side operation.
@param[in] ms \ref srsmatrix \f$M_s\f$.
@param[in] m \ref rmatrix \f$M_1\f$.
@param[in] dAlpha Multiplier \f$\alpha\f$.
@param[in] dBeta Multiplier \f$\beta\f$.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& symm(bool bLeft, const basic_srsmatrix<TR>& ms,
                        const basic_rmatrix& m,
                        TR dAlpha, TR dBeta) {
        this->_check_symm();
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.nsize());
        _check_ne(CVM_SIZESMISMATCH, bLeft ? this->msize() : this->nsize(), ms.msize());
        this->_symm(bLeft, ms, m, dAlpha, dBeta);
        return *this;
    }

/**
@brief Set matrix to zero

Sets every element of a calling matrix to be equal to zero
and returns a reference to the matrix changed. This function is faster
than, for example, set(TR) with zero parameter passed.
\par Example:
\code
using namespace cvm;

rmatrix m(3, 4);
m.randomize(0.,1.);

std::cout << m << std::endl;
std::cout << m.vanish();
\endcode
prints
\code
0.856532 0.938261 0.275704 0.186834
0.651173 0.812159 0.100467 0.536912
0.0726646 0.695914 0.661824 0.554613

0 0 0 0
0 0 0 0
0 0 0 0
\endcode
@return Reference to changed calling matrix.
*/
    basic_rmatrix& vanish() {
        this->_vanish();
        return *this;
    }

/**
@brief Randomizer

Fills calling matrix with pseudo-random numbers distributed between \c dFrom and \c dTo.
Function returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(7);

rmatrix m(3,4);
m.randomize(-2.,3.);
std::cout << m;
\endcode
prints
\code
9.6853542e-01 2.7761467e+00 2.3791009e+00 -3.4452345e-01
2.9029511e+00 -9.5519883e-01 -4.9131748e-01 -1.2561113e+00
1.5219886e+00 -1.4494461e+00 2.8193304e+00 4.8817408e-01
\endcode
@param[in] dFrom First limit.
@param[in] dTo Second limit.
@return Reference to changed calling matrix.
*/
    basic_rmatrix& randomize(TR dFrom, TR dTo) {
        this->_randomize(dFrom, dTo);
        return *this;
    }

    // 2-norm (maximum singular value)
    [[nodiscard]] TR norm2() const override {
        RVector vS(_cvm_min<tint>(this->msize(), this->nsize()));
        this->_svd(vS, nullptr, nullptr);
        return vS[0];
    }

//! @cond INTERNAL
    // ?gemm routines perform a matrix-matrix operation with general matrices.
    // The operation is defined as
    // c := alpha*op(a)*op(b) + beta*c,
    // where: op(x) is one of op(x) = x or op(x) = x' or op(x) = conjg(x'),
    void _gemm(bool bTrans1, const basic_rmatrix& m1,
               bool bTrans2, const basic_rmatrix& m2,
               TR dAlpha, TR dBeta) {  // this = m1 * m2
        basic_rmatrix mTmp1, mTmp2;
        const TR* pD1 = m1.get();
        const TR* pD2 = m2.get();
        if (this->get() == pD1) mTmp1 << m1;
        if (this->get() == pD2) mTmp2 << m2;
        __gemm<TR,basic_rmatrix>(this->get() == pD1 ? mTmp1 : m1, bTrans1,
                                 this->get() == pD2 ? mTmp2 : m2,
                                  bTrans2, dAlpha, *this, dBeta);
    }

    // this = alpha*a*b + beta*this or this = alpha*b*a + beta*this  where a is symmetric
    void _symm(bool bLeft, const basic_srsmatrix<TR>& ms,
               const basic_rmatrix& m, TR dAlpha, TR dBeta) {
        basic_rmatrix mTmp;
        basic_srsmatrix<TR> msTmp;
        const TR* pD1 = ms.get();
        const TR* pD2 = m._pd();
        if (this->get() == pD1) msTmp << ms;
        if (this->get() == pD2) mTmp << m;
        __symm<TR,basic_srsmatrix<TR>,
            basic_rmatrix>(bLeft, this->get() == pD1 ? msTmp : ms,
                           this->get() == pD2 ? mTmp : m, dAlpha, *this, dBeta);
    }

    // singular values in decreasing order
    virtual void _svd(RVector& vRes, basic_srmatrix<TR>* pmU,
                      basic_srmatrix<TR>* pmVH) const {
        if (pmU != nullptr && pmVH != nullptr) {
            _check_ne(CVM_SIZESMISMATCH, this->msize(), pmU->msize());
            _check_ne(CVM_SIZESMISMATCH, this->nsize(), pmVH->msize());
        }
        __svd<TR,basic_rmatrix, basic_srmatrix<TR>> (vRes, vRes.size(),
                                                     vRes.incr(), *this, pmU, pmVH);
    }

    virtual void _pinv(basic_rmatrix& mX, TR threshold) const {
        __pinv<TR,basic_rmatrix, basic_rmatrix>(mX, *this, threshold);
    }

    virtual void _check_submatrix() const {
    }

protected:
    // protected constructors for inherited stuff
    basic_rmatrix(tint nM, tint nN, tint nLD, bool bZeroMemory)
      : BaseMatrix(nM, nN, nLD, bZeroMemory)
    {}

    basic_rmatrix(tint size, tint incr, tint msize, tint nsize, tint ld)
      : BaseMatrix(size, incr, msize, nsize, ld)
    {}

    // non-const version shares memory
    basic_rmatrix(TR* pd, tint nM, tint nN, tint nLD, tint nSize)
      : BaseMatrix(pd, nM, nN, nLD, nSize)
    {}

    // const version makes a copy
    basic_rmatrix(const TR* pd, tint nM, tint nN, tint nLD, tint nSize)
      : BaseMatrix(pd, nM, nN, nLD, nSize)
    {}

    // returns diagonal which IS l-value (shares memory)
    // 0 - main, negative - low, positive - up
    virtual RVector _diag(tint nDiag) {
        tint nShift = 0;
        tint nSize = 0;
        this->_diag_helper(nDiag, nShift, nSize);
        return RVector(this->get() + nShift, nSize, this->ld() + 1);
    }

    // returns diagonal which IS NOT l-value (creates a copy)
    // 0 - main, negative - low, positive - up
    [[nodiscard]] virtual RVector _diag(tint nDiag) const {
        tint nShift = 0;
        tint nSize = 0;
        this->_diag_helper(nDiag, nShift, nSize);
        return RVector(this->get() + nShift, nSize, this->ld() + 1);
    }

    // compares matrix elements (equal sizes assumed)
    [[nodiscard]] bool _mequals(const basic_rmatrix& m) const {
        return ((*this) - m).norminf() <= basic_cvmMachMin<TR>();
    }

    // ?gemv routines perform a matrix-vector operation defined as
    // vRes = alpha*m*v + beta * vRes or vRes = alpha*v'*m + beta * vRes
    // not virtual since __gemv calls all virtual methods inside
    void _gemv(bool bLeft, TR dAlpha, const RVector& v,
               TR dBeta, RVector& vRes) const {
        RVector vTmp;
        basic_rmatrix mTmp;
        const TR* pDv = v;
        if (vRes.get() == pDv) vTmp << v;
        if (vRes.get() == this->get()) mTmp << *this;
        __gemv<TR,basic_rmatrix,
            RVector>(bLeft,
                     vRes.get() == this->get() ? mTmp : *this, dAlpha,
                     vRes.get() == pDv ? vTmp : v, dBeta, vRes);
    }

    // 0-based, returns l-value sharing memory
    virtual RVector _row(tint m) {
        return RVector(this->get() + m, this->nsize(), this->ld());
    }

    // 0-based, returns NOT l-value (copies memory)
    // looks like cut-n-paste, but it's not
    [[nodiscard]] virtual RVector _row(tint m) const {
        return RVector(this->get() + m, this->nsize(), this->ld());
    }

    // 0-based, returns l-value sharing memory
    virtual RVector _col(tint n) {
        return RVector(this->get() + this->ld() * n, this->msize());
    }

    // 0-based, returns NOT l-value (copies memory)
    // looks like cut-n-paste, but it's not
    [[nodiscard]] virtual RVector _col(tint n) const {
        return RVector(this->get() + this->ld() * n, this->msize());
    }

    virtual void _mult(const basic_rmatrix& m1,
                       const basic_rmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m2.nsize());
        _check_ne(CVM_SIZESMISMATCH, m1.nsize(), m2.msize());
        const TR zero = TR(0.);
        const TR one = TR(1.);
        this->_gemm(false, m1, false, m2, one, zero);
    }

    virtual void _multiply(RVector& vRes, const RVector& v, bool bLeft) const {
        const TR zero = TR(0.);
        const TR one = TR(1.);
        this->_gemv(bLeft, one, v, zero, vRes);
    }

    virtual void _randomize(TR dFrom, TR dTo) {
        if (this->_continuous()) {
            __randomize<TR>(this->get(), this->size(), this->incr(), dFrom, dTo);
        } else for (tint i = 0; i < this->nsize(); ++i) {
            __randomize<TR>(this->get() + this->ld() * i, this->msize(), this->incr(), dFrom, dTo);
        }
    }

    // QR factorization
    // Case 1: "economy" mode, A is (m x n) and Q is (m x n) and R is (n x n)
    void _qr_rs(basic_rmatrix<TR>& mQ, basic_srmatrix<TR>& mR) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mQ.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mR.msize());
        __qre<basic_rmatrix, basic_srmatrix<TR>> (*this, mQ, mR);
    }

    // Case 2: full mode, A is (m x n) and Q is (m x m) and R is (m x n)
    void _qr_sr(basic_srmatrix<TR>& mQ, basic_rmatrix<TR>& mR) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mR.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mR.nsize());
        __qrf<basic_rmatrix, basic_srmatrix<TR>> (*this, mQ, mR);
    }

    // RQ factorization
    // Case 1: "economy" mode, A is (m x n) and R is (m x m) and Q is (m x n)
    void _rq_sr(basic_srmatrix<TR>& mR, basic_rmatrix<TR>& mQ) const {
        _check_gt(CVM_SIZESMISMATCH_GT, this->msize(), this->nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mQ.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mR.msize());
        __rqe<basic_rmatrix, basic_srmatrix<TR>> (*this, mR, mQ);
    }

    // Case 2: full mode, A is (m x n) and R is (m x n) and Q is (n x n)
    void _rq_rs(basic_rmatrix<TR>& mR, basic_srmatrix<TR>& mQ) const {
        _check_gt(CVM_SIZESMISMATCH_GT, this->msize(), this->nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mR.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mR.nsize());
        __rqf<basic_rmatrix, basic_srmatrix<TR>> (*this, mR, mQ);
    }

    // LQ factorization
    // Case 1: "economy" mode, A is (m x n) and L is (m x m) and Q is (m x n)
    void _lq_sr(basic_srmatrix<TR>& mL, basic_rmatrix<TR>& mQ) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mL.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mQ.nsize());
        __lqe<basic_rmatrix, basic_srmatrix<TR>> (*this, mL, mQ);
    }

    // Case 2: full mode, A is (m x n) and L is (m x n) and Q is (n x n)
    void _lq_rs(basic_rmatrix<TR>& mL, basic_srmatrix<TR>& mQ) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mL.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mL.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mQ.nsize());
        __lqf<basic_rmatrix, basic_srmatrix<TR>> (*this, mL, mQ);
    }

    // QL factorization
    // Case 1: "economy" mode, A is (m x n) and Q is (m x n) and L is (n x n)
    void _ql_rs(basic_rmatrix<TR>& mQ, basic_srmatrix<TR>& mL) const {
        _check_lt(CVM_SIZESMISMATCH_LT, this->msize(), this->nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mQ.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mL.msize());
        __qle<basic_rmatrix, basic_srmatrix<TR>> (*this, mQ, mL);
    }

    // Case 2: full mode, A is (m x n) and Q is (m x m) and L is (m x n)
    void _ql_sr(basic_srmatrix<TR>& mQ, basic_rmatrix<TR>& mL) const {
        _check_lt(CVM_SIZESMISMATCH_LT, this->msize(), this->nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mL.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mL.nsize());
        __qlf<basic_rmatrix, basic_srmatrix<TR>> (*this, mQ, mL);
    }

    virtual void _check_ger() {}
    virtual void _check_rank1update() {}
    virtual void _check_gemm() {}
    virtual void _check_symm() {}

private:
    basic_rmatrix& _solve_helper(const basic_srmatrix<TR>& mA, const basic_rmatrix& mB,
                                 TR& dErr, int transp_mode) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mA.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mB.nsize());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), mB.msize());
        mA._solve(mB, *this, dErr, nullptr, nullptr, transp_mode);
        return *this;
    }

    // helper for svd and divide&conquer methods
    basic_rmatrix _gels_sd(bool svd, const basic_rmatrix& mB, basic_rvector<TR>& sv,
                           tint& rank, TR tol) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mB.msize());
        _check_ne(CVM_SIZESMISMATCH, sv.size(), _cvm_min<tint>(this->msize(), this->nsize()));
        basic_rmatrix mA(*this);  // this algorithm overrides A
        basic_rmatrix mX;
        basic_rvector<TR> sv1(sv.size());  // to ensure that incr=1
        if (svd) {
            __gelss(mA, mB, mX, tol, sv1, rank);
        } else {
            __gelsd(mA, mB, mX, tol, sv1, rank);
        }
        sv = sv1;
        return mX;
    }

    void _gels_sd(bool svd, const basic_rmatrix& mA, const basic_rmatrix& mB,
                  basic_rvector<TR>& sv,
                  tint& rank, TR tol) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mA.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mB.nsize());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), mB.msize());
        _check_ne(CVM_SIZESMISMATCH, sv.size(), _cvm_min<tint>(mA.msize(), mA.nsize()));
        basic_rmatrix mA2(mA);  // this algorithm overrides A
        basic_rvector<TR> sv1(sv.size());  // to ensure that incr=1
        if (svd) {
            __gelss(mA2, mB, *this, tol, sv1, rank);
        } else {
            __gelsd(mA2, mB, *this, tol, sv1, rank);
        }
        sv = sv1;
    }

    basic_rvector<TR> _gels_sd(bool svd, const basic_rvector<TR>& vB, basic_rvector<TR>& sv,
                               tint& rank, TR tol) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vB.size());
        _check_ne(CVM_SIZESMISMATCH, _cvm_min<tint>(this->msize(), this->nsize()), sv.size());
        basic_rmatrix mA(*this);  // this algorithm overrides A
        basic_rmatrix mB(vB, vB.size(), 1);
        basic_rmatrix mX;
        basic_rvector<TR> sv1(sv.size());  // to ensure that incr=1
        if (svd) {
            __gelss(mA, mB, mX, tol, sv1, rank);
        } else {
            __gelsd(mA, mB, mX, tol, sv1, rank);
        }
        sv = sv1;
        const TR* pResult = mX;
        return basic_rvector<TR>(pResult, mX.msize());
    }
//! @endcond
};


/**
@brief End-user class encapsulating square matrix of real numbers

\c TR type stands for \ref treal. Please use predefined \ref srmatrix class in your applications.
@see Matrix
*/
template<typename TR>
class basic_srmatrix : public basic_rmatrix<TR>, public SqMatrix<TR,TR>
{
    using TC = std::complex<TR>;  //!< complex number type
    using RVector = basic_rvector<TR>;  //!< \ref rvector
    using CVector = basic_cvector<TR,TC>;  //!< \ref cvector
    using BaseArray = basic_array<TR,TR>;  //!< Base basic_array class
    using BaseMatrix = Matrix<TR,TR>;  //!< Base Matrix class
    using BaseSqMatrix = SqMatrix<TR,TR>;  //!< Base SqMatrix class
    using BaseRMatrix = basic_rmatrix<TR>;  //!< \ref rmatrix class

public:
/**
@brief Default constructor

Creates empty square matrix. No memory gets allocated.
\par Example:
\code
using namespace cvm;

srmatrix m;
std::cout << m.msize() << std::endl << m.nsize() << std::endl;
std::cout << m.size() << std::endl;

m.resize(3);
std::cout << m;
\endcode
prints
\code
0
0
0
0 0 0
0 0 0
0 0 0
\endcode
*/
    basic_srmatrix() = default;

    ~basic_srmatrix() override = default;

/**
@brief Constructor

Creates \f$n\times n\f$ \ref srmatrix object where \f$n\f$ is passed in
\c nDim parameter. Constructor sets all elements to zero.
It throws \ref cvmexception in case of non-positive size passed or memory allocation failure.
Example:
\code
using namespace cvm;

srmatrix m(4);
std::cout << m.msize() << std::endl << m.nsize()
          << std::endl << m.size() << std::endl << m;
\endcode
prints
\code
4
4
16
0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
\endcode
@param[in] nDim Number of rows and columns.
*/
    explicit basic_srmatrix(tint nDim)
      : BaseRMatrix(nDim, nDim)
    {}



// TODO dox, test
#if defined(CVM_USE_INITIALIZER_LISTS)
    basic_srmatrix(tint nDim, const std::initializer_list<TR>& list)
      : BaseRMatrix(nDim, nDim, list)
    {}
#endif



/**
@brief Constructor

Creates \f$n\times n\f$ \ref srmatrix object where \f$n\f$ is passed in \c nDim parameter.
It throws \ref cvmexception in case of non-positive size passed.
Unlike others, this constructor <b>does not allocate memory</b>.
It just shares memory with an array pointed to by \c pd (for matrices \c nIncr=1 is always satisfied).
\par Example:
\code
using namespace cvm;
double a[] = {1., 1., 1., 1., 1., 1., 1., 1., 1.};
srmatrix m(a, 3);

m(1,1) = 5.;
std::cout << m << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << std::endl;
\endcode
prints
\code
5 1 1
1 1 1
1 1 1

5 1 1
\endcode
@see http://cvmlib.com/faq.htm
@see basic_rmatrix::basic_rmatrix(TR*,tint,tint)
@param[in] pd Pointer to an array to share memory with.
@param[in] nDim Number of rows and columns.
*/
    basic_srmatrix(TR* pd, tint nDim)
      : BaseRMatrix(pd, nDim, nDim)
    {}

/**
@brief Constructor

Creates \f$n\times n\f$ \ref srmatrix object where \f$n\f$ is passed in \c nDim parameter.
Constructor throws \ref cvmexception in case of non-positive sizes passed.
This is const version,
it allocates memory and copies every element (deep copy) from external array pointed to by \c pd parameter.
It copies \c nDim*nDim elements total.
Example:
\code
using namespace cvm;
const double a[] = {1., 1., 1., 1., 1., 1., 1., 1., 1.};
srmatrix m(a, 3);

m(1,1) = 5.;
std::cout << m << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << std::endl;
\endcode
prints
\code
5 1 1
1 1 1
1 1 1

1 1 1
\endcode
@see http://cvmlib.com/faq.htm
@see basic_rmatrix::basic_rmatrix(const TR*,tint,tint)
@param[in] pd Const pointer to external array.
@param[in] nDim Number of rows and columns.
*/
    basic_srmatrix(const TR* pd, tint nDim)
      : BaseRMatrix(pd, nDim, nDim)
    {}

/**
@brief Copy constructor

Creates \ref srmatrix object as a copy of a matrix \c m.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;

double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
srmatrix m(a, 3);
srmatrix mc(m);

m(1,1) = 7.77;
std::cout << m << std::endl << mc;
\endcode
prints
\code
7.77 4 7
2 5 8
3 6 9

1 4 7
2 5 8
3 6 9
\endcode
@param[in] m \ref srmatrix to copy from.
*/
    basic_srmatrix(const basic_srmatrix& m)
      : BaseRMatrix(m.msize(), m.nsize(), m.msize(), false), BaseSqMatrix() {
        this->_massign(m);
    }

/**
@brief Move constructor

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to newly created object.
It's usually executed implicitly in cases like this:
\code
rvector a(b + c);
\endcode
or this
\code
rvector a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to newly created object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_srmatrix(basic_srmatrix&& m) noexcept
       : BaseRMatrix(std::move(m))
    {}

/**
@brief Constructor

Creates \ref srmatrix object as a copy of a matrix \c m.
It's assumed that \f$m\times n\f$ matrix \c m must have equal
sizes, i.e. \f$m = n\f$ is satisfied.
Constructor throws \ref cvmexception if this is not true or in case of memory allocation failure.
Please note that this constructor is <em>not explicit</em>.
\par Example:
\code
using namespace cvm;

double a[] = {1., 2., 3., 4., 5., 6.};
rmatrix m(a, 2, 3);
std::cout << m << std::endl;

m.resize(3, 3);
srmatrix ms(m);
std::cout << ms;
\endcode
prints
\code
1 3 5
2 4 6

1 3 5
2 4 6
0 0 0
\endcode
@param[in] m \ref rmatrix to copy from.
*/
    basic_srmatrix(const BaseRMatrix& m)
      : BaseRMatrix(m.msize(), m.nsize(), m.msize(), false) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), this->nsize());
        this->_massign(m);
    }

/**
@brief Constructor

Creates \ref srmatrix object of size \c v.size() by \c v.size()
and assigns vector \c v to its main diagonal.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;

double a[] = {1., 2., 3., 4., 5.};
rvector v(a, 5);
srmatrix m(v);
std::cout << m;
\endcode
prints
\code
1 0 0 0 0
0 2 0 0 0
0 0 3 0 0
0 0 0 4 0
0 0 0 0 5
\endcode
@param[in] v \ref rvector to copy main diagonal from.
*/
    explicit basic_srmatrix(const RVector& v)
      : BaseRMatrix(v.size(), v.size(), v.size(), true) {
        __copy<TR>(this->msize(), v, v.incr(), this->get(), this->msize() + 1);
    }

/**
@brief Submatrix constructor

Creates \ref srmatrix object as submatrix of a matrix \c m.
It means that the object created shares memory with some part
of \c m. This part is defined by its upper left corner and its dimension (parameter
\c nDim).
\par Example:
\code
using namespace cvm;
rmatrix m(4,5);
srmatrix subm(m, 2, 2, 2);
subm.set(1.);
std::cout << m;
\endcode
prints
\code
0 0 0 0 0
0 1 1 0 0
0 1 1 0 0
0 0 0 0 0
\endcode
@param[in] m Parent \ref rmatrix to attach to.
@param[in] nRow Row to start from.
@param[in] nCol Column to start from.
@param[in] nDim Dimension of square submatrix.
*/
    basic_srmatrix(BaseRMatrix& m, tint nRow, tint nCol, tint nDim)
      : BaseRMatrix(m, nRow, nCol, nDim, nDim) {
        m._check_submatrix();
    }

/**
@brief Assignment operator

Sets every element of a calling \ref srmatrix to be equal to
appropriate element of smatrix \c m and returns a reference to
the matrix changed.
Operator throws \ref cvmexception in case of different matrix dimensions.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    const srmatrix m1(a, 3);
    srmatrix m2(3);

    m2 = m1;
    std::cout << m2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.00e+00 4.00e+00 7.00e+00
2.00e+00 5.00e+00 8.00e+00
3.00e+00 6.00e+00 9.00e+00
\endcode
@param[in] m \ref srmatrix to assign from.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& operator = (const basic_srmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        this->_massign(m);
        return *this;
    }

/**
@brief Move assignment operator

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to a calling object.
It's usually executed implicitly in cases like this:
\code
a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to a calling object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_srmatrix& operator = (basic_srmatrix&& m) noexcept {
        // size check is in BaseRMatrix
        BaseRMatrix::operator = (std::move(m));
        return *this;
    }

    // assigns vector
    basic_srmatrix& assign(const RVector& v) {
        _check_ne(CVM_SIZESMISMATCH, this->size(), v.size());
        this->_assign(v, v.incr());
        return *this;
    }

    // assigns external array (nIncr = 1)
    basic_srmatrix& assign(const TR* pd) {
        this->_assign(pd, 1);
        return *this;
    }

/**
@brief Assignment to submatrix

Sets submatrix of a calling matrix beginning with row
\c nRow and column \c nCol to a matrix \c m and
returns a reference to the matrix changed. Function throws
\ref cvmexception if \c nRow or \c nCol are not positive or matrix \c m doesn't fit.
\par Example:
\code
using namespace cvm;
srmatrix m1(5);
rmatrix m2(2,3);
m1.set(1.);
m2.set(2.);
m1.assign(2,3,m2);
std::cout << m1;
\endcode
prints
\code
1 1 1 1 1
1 1 2 2 2
1 1 2 2 2
1 1 1 1 1
1 1 1 1 1
\endcode
@param[in] nRow Row index.
@param[in] nCol Column index.
@param[in] m Reference to \ref rmatrix to assign.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& assign(tint nRow, tint nCol, const BaseRMatrix& m) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, nRow, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, nCol, tint(), this->nsize());
        _check_gt(CVM_SIZESMISMATCH_GT, m.msize() + nRow, this->msize());
        _check_gt(CVM_SIZESMISMATCH_GT, m.nsize() + nCol, this->nsize());
        this->_assign_shifted(this->_sub_pointer_nocheck(nRow, nCol),
                              m._pd(), m.msize(), m.nsize(), m.ld());
        return *this;
    }

    // fills content
    basic_srmatrix& set(TR d) {
        this->_set(d);
        return *this;
    }

/**
@brief Changes dimension

Changes dimension of a calling square matrix to \c nNewDim
and returns a reference to the matrix changed.
In case of increasing of its size, the matrix
is filled up with zeroes.
Function throws \ref cvmexception
in case of negative dimension passed or memory allocation failure.
 \par Example:
 \code
 using namespace cvm;
 try {
     double a[] = {1., 2., 3., 4.};
     srmatrix m(a, 2);
     std::cout << m << std::endl;
     m.resize(3);
     std::cout << m;
 }
 catch(std::exception& e) {
     std::cout << "Exception " << e.what() << std::endl;
 }
 \endcode
 prints
 \code
 1 3
 2 4

 1 3 0
 2 4 0
 0 0 0
 \endcode
@param[in] nNewDim New dimension.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& resize(tint nNewDim) {
        this->_resize2(nNewDim, nNewDim);
        return *this;
    }

/**
@brief Matrix replacement

Destroys calling matrix, creates a new one as a copy of \c m
and returns a reference to the matrix changed. Operator throws \ref cvmexception
in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    srmatrix m(3);
    srmatrix mc(1);
    m(1,2) = 1.;
    m(2,3) = 2.;
    std::cout << m << std::endl << mc << std::endl;
    mc << m;
    std::cout << mc;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
0.00e+00 1.00e+00 0.00e+00
0.00e+00 0.00e+00 2.00e+00
0.00e+00 0.00e+00 0.00e+00

0.00e+00

0.00e+00 1.00e+00 0.00e+00
0.00e+00 0.00e+00 2.00e+00
0.00e+00 0.00e+00 0.00e+00
\endcode
@see operator =()
@param[in] m \ref srmatrix to replace by.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& operator << (const basic_srmatrix& m) {
        this->_replace(m);
        this->_massign(m);
        return *this;
    }

/**
@brief Addition operator

Creates an object of type \ref srmatrix as a sum of
a calling matrix and a matrix \c m.
Operator throws \ref cvmexception
in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double b[] = {10., 20., 30., 40., 50., 60., 70., 80., 90.};
    srmatrix m1(a, 3);
    srmatrix m2(b, 3);
    std::cout << m1 + m2 << std::endl << m1 + m1;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
11 44 77
22 55 88
33 66 99

2 8 14
4 10 16
6 12 18
\endcode
@see sum()
@param[in] m \ref srmatrix to add to a calling one.
@return Sum of matrices.
*/
    basic_srmatrix operator + (const basic_srmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        basic_srmatrix mSum(*this);
        mSum._mincr(m);
        return mSum;
    }

/**
@brief Subtraction operator

Creates an object of type \ref srmatrix as a difference of
a calling matrix and a matrix \c m.
It throws \ref cvmexception in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double b[] = {10., 20., 30., 40., 50., 60., 70., 80., 90.};
    srmatrix m1(a, 3);
    srmatrix m2(b, 3);
    std::cout << m2 - m1 << std::endl << m1 - m1;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
9 36 63
18 45 72
27 54 81

0 0 0
0 0 0
0 0 0
\endcode
@see diff()
@param[in] m \ref srmatrix to subtract from calling one.
@return Difference of matrices.
*/
    basic_srmatrix operator - (const basic_srmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        basic_srmatrix mDiff(*this);
        mDiff._mdecr(m);
        return mDiff;
    }

/**
@brief Sum of matrices

Assigns sum of square matrices \c m1 and \c m2 to a calling matrix
and returns a reference to the matrices changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    const srmatrix m1(a, 3);
    srmatrix m2(3);
    srmatrix m(3);
    m2.set(1.);
    std::cout << m.sum(m1, m2) << std::endl;
    std::cout << m.sum(m, m2);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
2 5 8
3 6 9
4 7 10

3 6 9
4 7 10
5 8 11
\endcode
@see operator +()
@param[in] m1 First \ref srmatrix summand.
@param[in] m2 Second \ref srmatrix summand.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& sum(const basic_srmatrix& m1,
                        const basic_srmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
        this->_msum(m1, m2);
        return *this;
    }

/**
@brief Difference of matrices

Assigns difference of square matrices \c m1 and \c m2 to a calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    const srmatrix m1(a, 3);
    srmatrix m2(3);
    srmatrix m(3);
    m2.set(1.);
    std::cout << m.diff(m1, m2) << std::endl;
    std::cout << m.diff(m, m2);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
0 3 6
1 4 7
2 5 8

-1 2 5
0 3 6
1 4 7
\endcode
@see operator -()
@param[in] m1 First \ref srmatrix subtrahend.
@param[in] m2 Second \ref srmatrix subtrahend.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& diff(const basic_srmatrix& m1,
                         const basic_srmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
        this->_mdiff(m1, m2);
        return *this;
    }

/**
@brief Increment operator

Adds \ref srmatrix \c m to a calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    srmatrix m1(3);
    srmatrix m2(3);
    m1.set(1.);
    m2.set(2.);
    m1 += m2;
    std::cout << m1 << std::endl;
    // well, you can do this too, but temporary object would be created
    m2 += m2;
    std::cout << m2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3 3 3
3 3 3
3 3 3

4 4 4
4 4 4
4 4 4
\endcode
@see operator +()
@see sum()
@param[in] m \ref srmatrix to increment by.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& operator += (const basic_srmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        this->_mincr(m);
        return *this;
    }

/**
@brief Decrement operator

Subtracts \ref srmatrix \c m from calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    srmatrix m1(3);
    srmatrix m2(3);
    m1.set(1.);
    m2.set(2.);

    m1 -= m2;
    std::cout << m1 << std::endl;

    // well, you can do this too, but temporary object would be created
    m2 -= m2;
    std::cout << m2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1 -1 -1
-1 -1 -1
-1 -1 -1

0 0 0
0 0 0
0 0 0
\endcode
@see operator -()
@see diff()
@param[in] m \ref srmatrix to decrement by.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& operator -= (const basic_srmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        this->_mdecr(m);
        return *this;
    }

/**
@brief Unary minus operator

Creates an object of type \ref srmatrix as
a calling matrix multiplied by \c -1.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
srmatrix m(a, 3);
std::cout << -m;
\endcode
prints
\code
-1 -4 -7
-2 -5 -8
-3 -6 -9
\endcode
@return Result object.
*/
    basic_srmatrix operator - () const {
        const TR mone(-1.);
        basic_srmatrix mRes(*this);
        mRes._scalr(mone);
        return mRes;
    }

/**
@brief Plus identity, prefix

Adds identity matrix to a calling square matrix and returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm; 
srmatrix m(3, {1., 2., 3., 4., 5., 6., 7., 8., 9.});
std::cout << m << std::endl; 
std::cout << ++m << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
1 4 7 
2 5 8 
3 6 9 

2 4 7 
2 6 8 
3 6 10 

2 4 7 
2 6 8 
3 6 10 
\endcode
@return Reference to changed calling matrix.
*/
    basic_srmatrix& operator ++ () {
        this->_plus_plus();
        return *this;
    }

/**
@brief Plus identity, postfix

Adds identity matrix to a calling square matrix and returns a 
copy of the original calling matrix. 
\par Example:
\code
using namespace cvm;
srmatrix m(3, {1., 2., 3., 4., 5., 6., 7., 8., 9.});
std::cout << m << std::endl; 
std::cout << m++ << std::endl; 
std::cout << m << std::endl; 
\endcode
prints
\code
1 4 7 
2 5 8 
3 6 9 

1 4 7 
2 5 8 
3 6 9 

2 4 7 
2 6 8 
3 6 10 
\endcode
@return Copy of the original calling matrix.
*/
    basic_srmatrix operator ++ (int) {
        basic_srmatrix mRes(*this);
        this->_plus_plus();
        return mRes;
    }

/**
@brief Minus identity, prefix

Subtracts identity matrix from calling square matrix and 
returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
srmatrix m(3, {1., 2., 3., 4., 5., 6., 7., 8., 9.}); 
std::cout << m << std::endl;
std::cout << --m << std::endl;
std::cout << m << std::endl;
\endcode
prints
\code
1 4 7 
2 5 8 
3 6 9 

0 4 7 
2 4 8 
3 6 8 

0 4 7 
2 4 8 
3 6 8 
\endcode
@return Reference to changed calling matrix.
*/
    basic_srmatrix& operator -- () {
        this->_minus_minus();
        return *this;
    }

/**
@brief Minus identity, postfix

Subtracts identity matrix from calling square matrix and returns
a copy of the original calling matrix. 
\par Example:
\code
using namespace cvm;
srmatrix m(3, {1., 2., 3., 4., 5., 6., 7., 8., 9.}); 
std::cout << m << std::endl;
std::cout << m-- << std::endl;
std::cout << m << std::endl;
\endcode
prints
\code
1 4 7 
2 5 8 
3 6 9 

1 4 7 
2 5 8 
3 6 9 

0 4 7 
2 4 8 
3 6 8 
\endcode
@return Copy of the original calling matrix.
*/
    basic_srmatrix operator -- (int) {
        basic_srmatrix mRes(*this);
        this->_minus_minus();
        return mRes;
    }

/**
@brief Multiply by number operator

Creates an object of type \ref srmatrix as a product of
a calling square matrix and number \c dMult.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
srmatrix m(3, {1., 2., 3., 4., 5., 6., 7., 8., 9.}); 
std::cout << m * 5.;
\endcode
prints
\code
5 20 35
10 25 40
15 30 45
\endcode
@see operator *=()
@param[in] dMult Number to multiply by.
@return Result object.
*/
    basic_srmatrix operator * (TR dMult) const {
        basic_srmatrix mRes(*this);
        mRes._scalr(dMult);
        return mRes;
    }

/**
@brief Divide by number operator

Creates an object of type \ref srmatrix as a quotient of
a calling square matrix and number \c dDiv.
It throws \ref cvmexception if \c dDiv has absolute value equal or less
than \ref cvmMachMin() (the smallest normalized positive number).
It also throws exception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    srmatrix m(a, 3);
    std::cout << m / 4.;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
0.25 1 1.75
0.5 1.25 2
0.75 1.5 2.25
\endcode
@see operator /=()
@param[in] dDiv Number to divide by.
@return Result object.
*/
    basic_srmatrix operator / (TR dDiv) const {
        basic_srmatrix mRes(*this);
        mRes._div(dDiv);
        return mRes;
    }

    // TODO dox
    basic_srmatrix& operator *= (TR dMult) {
        this->_scalr(dMult);
        return *this;
    }

    basic_srmatrix& operator /= (TR dDiv) {
        this->_div(dDiv);
        return *this;
    }

    basic_srmatrix& normalize() {
        this->_normalize();
        return *this;
    }

/**
@brief Matrix transposition

Creates an object of type \c srmatrix as transposed calling matrix.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    srmatrix m(a,3);
    srmatrix mt(3);
    std::cout << ~m << std::endl ;
    mt.transpose(m);
    std::cout << mt << std::endl;
    mt.transpose();
    std::cout << mt;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1 2 3
4 5 6
7 8 9

1 2 3
4 5 6
7 8 9

1 4 7
2 5 8
3 6 9
\endcode
@return Result object.
*/
    basic_srmatrix operator ~ () const {
        basic_srmatrix mRes(*this);
        return mRes.transpose();
    }

/**
@brief Matrix transposition

Sets calling matrix to be equal to square matrix \c m transposed.
Function throws \ref cvmexception in case of not appropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    srmatrix m(a,3);
    srmatrix mt(3);
    std::cout << ~m << std::endl ;
    mt.transpose(m);
    std::cout << mt << std::endl;
    mt.transpose();
    std::cout << mt;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1 2 3
4 5 6
7 8 9

1 2 3
4 5 6
7 8 9

1 4 7
2 5 8
3 6 9
\endcode
@param[in] m \ref srmatrix to transpose.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& transpose(const basic_srmatrix& m) {
        (*this) = m;
        return this->transpose();
    }

    // TODO dox
    basic_srmatrix& transpose() {
        this->_transp();
        return *this;
    }

    RVector operator * (const RVector& v) const {
        return this->BaseRMatrix::operator * (v);
    }

// special exclusion since matrix product is not commutative
/**
@brief Matrix-matrix product

Creates an object of type \ref rmatrix as a product of a calling square matrix and a matrix \c m.
Operator throws \ref cvmexception if number of columns of a calling matrix
differs from number of rows of the matrix \c m.
Use \ref mult() to avoid new object creation.
\par Example:
\code
using namespace cvm;
try {
    srmatrix ms(3);
    rmatrix m(3,2);
    ms.set(1.);
    m.set(1.);
    std::cout << ms * m;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3 3
3 3
3 3
\endcode
@param[in] m \ref rmatrix to compute product with.
@return Result object.
*/
    BaseRMatrix operator * (const BaseRMatrix& m) const {
        return this->BaseRMatrix::operator * (m);
    }

/**
@brief Matrix-matrix product

Creates an object of type \ref srmatrix as a product of a calling matrix and square matrix \c m.
Operator throws \ref cvmexception if number of columns of a calling matrix
differs from number of rows of the matrix \c m.
Use \ref mult() to avoid new object creation.
\par Example:
\code
using namespace cvm;
try {
    srmatrix m1(3);
    srmatrix m2(3);
    m1.set(1.);
    m2.set(1.);
    std::cout << m1 * m2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3 3 3
3 3 3
3 3 3
\endcode
@param[in] m \ref srmatrix to compute product with.
@return Result object.
*/
    basic_srmatrix operator * (const basic_srmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        basic_srmatrix mRes(this->msize());
        mRes.mult(*this, m);
        return mRes;
    }

/**
@brief Matrix-matrix product with assignment

Sets calling matrix to be equal to product of itself and square matrix \c m
and returns a reference to the object it changes.
Operator throws \ref cvmexception in case of different dimensions of the operands.
\par Example:
\code
using namespace cvm;
try {
    srmatrix m1(3);
    srmatrix m2(3);
    m1.set(1.);
    m2.set(1.);
    m1 *= m2;
    std::cout << m1 << std::endl;
    m1 *= m1;
    std::cout << m1;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
3 3 3
3 3 3
3 3 3

27 27 27
27 27 27
27 27 27
\endcode
@param[in] m \ref srmatrix to compute product with.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& operator *= (const basic_srmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        const basic_srmatrix mTmp(*this);
        this->mult(mTmp, m);
        return *this;
    }

    // TODO dox
    basic_srmatrix& swap_rows(tint n1, tint n2) {
        this->_swap_rows(n1, n2);
        return *this;
    }

    basic_srmatrix& swap_cols(tint n1, tint n2) {
        this->_swap_cols(n1, n2);
        return *this;
    }

// linear solvers Ax=b. Also return solution flavor.
/**
@brief Linear solver

Creates \ref rvector object as solution \f$x\f$ of linear equation
\f$A*x=b\f$ where calling matrix is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
It also sets output parameter \c dErr to be equal
to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix ma(a, 3);
    rmatrix  mb(3,4);
    rmatrix  mx(3,4);
    double dErr;

    mb(1).set(1.);
    mb(2).set(2.);
    mb(3).set(3.);
    mb(1,4) = 1.; mb(2,4) = 2.; mb(3,4) = 3.;

    mx = ma.solve(mb, dErr);
    std::cout << mx << dErr
              << std::endl << ma * mx - mb << std::endl;

    rvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve(vb, dErr);
    std::cout << vx << dErr << std::endl << ma * vx - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-3.333e-01 -6.667e-01 -1.000e+00 1.000e+00
3.333e-01 6.667e-01 1.000e+00 0.000e+00
6.661e-16 1.332e-15 0.000e+00 0.000e+00
3.301e-14
0.000e+00 0.000e+00 0.000e+00 0.000e+00
-1.110e-16 -2.220e-16 0.000e+00 0.000e+00
2.220e-16 4.441e-16 0.000e+00 0.000e+00

-6.667e-01 6.667e-01 1.332e-15
3.301e-14
0.000e+00 -2.220e-16 4.441e-16
\endcode
@see solve(const RVector&)const
@param[in] vB \ref rvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    RVector solve(const RVector& vB, TR& dErr) const {
        return _solve_helper(vB, dErr, 0);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Creates \ref rvector object as solution \f$x\f$ of linear equation
\f$A^T*x=b\f$ (which is equivalent to \f$x*A=b\f$) where calling matrix is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
It also sets output parameter \c dErr to be equal
to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix ma(a, 3);
    rmatrix  mb(3,4);
    rmatrix  mx(3,4);
    double dErr;

    mb(1).set(1.);
    mb(2).set(2.);
    mb(3).set(3.);
    mb(1,4) = 1.; mb(2,4) = 2.; mb(3,4) = 3.;

    mx = ma.solve_tran(mb, dErr);
    std::cout << mx << dErr
              << std::endl << ~ma * mx - mb << std::endl;

    rvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve_tran(vb, dErr);
    std::cout << vx << dErr << std::endl << vx * ma - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1.000e+000 -2.000e+000 -3.000e+000 -3.333e-001
+1.000e+000 +2.000e+000 +3.000e+000 +6.667e-001
+0.000e+000 +0.000e+000 -1.332e-015 +0.000e+000
+3.513e-014
+0.000e+000 +0.000e+000 +0.000e+000 +0.000e+000
+0.000e+000 +0.000e+000 +8.882e-016 -2.220e-016
+0.000e+000 +0.000e+000 -2.665e-015 +0.000e+000

-2.000e+000 +2.000e+000 +0.000e+000
+3.168e-014
+0.000e+000 +0.000e+000 +0.000e+000
\endcode
@see solve_tran(const RVector&)const
@param[in] vB \ref rvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    RVector solve_tran(const RVector& vB, TR& dErr) const {
        return _solve_helper(vB, dErr, 1);
    }

/**
@brief Linear solver

Creates \ref rvector object as solution \f$x\f$ of linear equation
\f$A*x=b\f$ where calling matrix is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix ma(a, 3);
    rmatrix  mb(3,4);
    rmatrix  mx(3,4);

    mb(1).set(1.);
    mb(2).set(2.);
    mb(3).set(3.);
    mb(1,4) = 1.; mb(2,4) = 2.; mb(3,4) = 3.;

    mx = ma.solve(mb);
    std::cout << mx << std::endl << ma * mx - mb << std::endl;

    rvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve(vb);
    std::cout << vx << std::endl << ma * vx - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-3.333e-01 -6.667e-01 -1.000e+00 1.000e+00
3.333e-01 6.667e-01 1.000e+00 0.000e+00
6.661e-16 1.332e-15 0.000e+00 0.000e+00

0.000e+00 0.000e+00 0.000e+00 0.000e+00
-1.110e-16 -2.220e-16 0.000e+00 0.000e+00
2.220e-16 4.441e-16 0.000e+00 0.000e+00

-6.667e-01 6.667e-01 1.332e-15

0.000e+00 -2.220e-16 4.441e-16
\endcode
@see solve(const RVector&,TR&)const
@param[in] vB \ref rvector \f$b\f$.
@return Result object.
*/
    [[nodiscard]] RVector solve(const RVector& vB) const {
        TR dErr(0.);
        return this->solve(vB, dErr);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Creates \ref rvector object as solution \f$x\f$ of linear equation
\f$A^T*x=b\f$ (which is equivalent to \f$x*A=b\f$) where calling matrix is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix ma(a, 3);
    rmatrix  mb(3,4);
    rmatrix  mx(3,4);

    mb(1).set(1.);
    mb(2).set(2.);
    mb(3).set(3.);
    mb(1,4) = 1.; mb(2,4) = 2.; mb(3,4) = 3.;

    mx = ma.solve_tran(mb, dErr);
    std::cout << mx << std::endl << ~ma * mx - mb << std::endl;

    rvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve_tran(vb, dErr);
    std::cout << vx << std::endl << vx * ma - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1.000e+000 -2.000e+000 -3.000e+000 -3.333e-001
+1.000e+000 +2.000e+000 +3.000e+000 +6.667e-001
+0.000e+000 +0.000e+000 -1.332e-015 +0.000e+000

+0.000e+000 +0.000e+000 +0.000e+000 +0.000e+000
+0.000e+000 +0.000e+000 +8.882e-016 -2.220e-016
+0.000e+000 +0.000e+000 -2.665e-015 +0.000e+000

-2.000e+000 +2.000e+000 +0.000e+000

+0.000e+000 +0.000e+000 +0.000e+000
\endcode
@see solve_tran(const RVector&,TR&)const
@param[in] vB \ref rvector \f$b\f$.
@return Result object.
*/
    [[nodiscard]] RVector solve_tran(const RVector& vB) const {
        TR dErr(0.);
        return this->solve_tran(vB, dErr);
    }

/**
@brief Linear solver

Creates \ref rmatrix object as solution \f$X\f$ of
matrix linear equation \f$A*X=B\f$ where calling square matrix is matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix ma(a, 3);
    rmatrix  mb(3,4);
    rmatrix  mx(3,4);
    double dErr;

    mb(1).set(1.);
    mb(2).set(2.);
    mb(3).set(3.);
    mb(1,4) = 1.; mb(2,4) = 2.; mb(3,4) = 3.;

    mx = ma.solve(mb, dErr);
    std::cout << mx << dErr
              << std::endl << ma * mx - mb << std::endl;

    rvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve(vb, dErr);
    std::cout << vx << dErr << std::endl << ma * vx - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-3.333e-01 -6.667e-01 -1.000e+00 1.000e+00
3.333e-01 6.667e-01 1.000e+00 0.000e+00
6.661e-16 1.332e-15 0.000e+00 0.000e+00
3.301e-14
0.000e+00 0.000e+00 0.000e+00 0.000e+00
-1.110e-16 -2.220e-16 0.000e+00 0.000e+00
2.220e-16 4.441e-16 0.000e+00 0.000e+00

-6.667e-01 6.667e-01 1.332e-15
3.301e-14
0.000e+00 -2.220e-16 4.441e-16
\endcode
@see solve(const BaseRMatrix&)const
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    BaseRMatrix solve(const BaseRMatrix& mB, TR& dErr) const {
        return _solve_helper(mB, dErr, 0);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Creates \ref rmatrix object as solution \f$X\f$ of
matrix linear equation \f$A^T*X=B\f$  (which is equivalent to \f$X^T*A=B^T\f$)
where calling matrix is square matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix ma(a, 3);
    rmatrix  mb(3,4);
    rmatrix  mx(3,4);

    mb(1).set(1.);
    mb(2).set(2.);
    mb(3).set(3.);
    mb(1,4) = 1.; mb(2,4) = 2.; mb(3,4) = 3.;

    mx = ma.solve_tran(mb, dErr);
    std::cout << mx << std::endl << ~ma * mx - mb << std::endl;

    rvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve_tran(vb, dErr);
    std::cout << vx << std::endl << vx * ma - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1.000e+000 -2.000e+000 -3.000e+000 -3.333e-001
+1.000e+000 +2.000e+000 +3.000e+000 +6.667e-001
+0.000e+000 +0.000e+000 -1.332e-015 +0.000e+000

+0.000e+000 +0.000e+000 +0.000e+000 +0.000e+000
+0.000e+000 +0.000e+000 +8.882e-016 -2.220e-016
+0.000e+000 +0.000e+000 -2.665e-015 +0.000e+000

-2.000e+000 +2.000e+000 +0.000e+000

+0.000e+000 +0.000e+000 +0.000e+000
\endcode
@see solve_tran(const BaseRMatrix&)const
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    BaseRMatrix solve_tran(const BaseRMatrix& mB, TR& dErr) const {
        return _solve_helper(mB, dErr, 1);
    }

/**
@brief Linear solver

Creates \ref rmatrix object as solution \f$X\f$ of
matrix linear equation \f$A*X=B\f$ where calling square matrix is matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix ma(a, 3);
    rmatrix  mb(3,4);
    rmatrix  mx(3,4);

    mb(1).set(1.);
    mb(2).set(2.);
    mb(3).set(3.);
    mb(1,4) = 1.; mb(2,4) = 2.; mb(3,4) = 3.;

    mx = ma.solve(mb);
    std::cout << mx << std::endl << ma * mx - mb << std::endl;

    rvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve(vb);
    std::cout << vx << std::endl << ma * vx - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-3.333e-01 -6.667e-01 -1.000e+00 1.000e+00
3.333e-01 6.667e-01 1.000e+00 0.000e+00
6.661e-16 1.332e-15 0.000e+00 0.000e+00

0.000e+00 0.000e+00 0.000e+00 0.000e+00
-1.110e-16 -2.220e-16 0.000e+00 0.000e+00
2.220e-16 4.441e-16 0.000e+00 0.000e+00

-6.667e-01 6.667e-01 1.332e-15

0.000e+00 -2.220e-16 4.441e-16
\endcode
@see solve(const BaseRMatrix&,TR&)const
@param[in] mB \ref rmatrix \f$B\f$.
@return Result object.
*/
    [[nodiscard]] BaseRMatrix solve(const BaseRMatrix& mB) const {
        TR dErr(0.);
        return this->solve(mB, dErr);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Creates \ref rmatrix object as solution \f$X\f$ of
matrix linear equation \f$A^T*X=B\f$  (which is equivalent to \f$X^T*A=B^T\f$)
where calling matrix is square matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix ma(a, 3);
    rmatrix  mb(3,4);
    rmatrix  mx(3,4);

    mb(1).set(1.);
    mb(2).set(2.);
    mb(3).set(3.);
    mb(1,4) = 1.; mb(2,4) = 2.; mb(3,4) = 3.;

    mx = ma.solve_tran(mb, dErr);
    std::cout << mx << std::endl << ~ma * mx - mb << std::endl;

    rvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve_tran(vb, dErr);
    std::cout << vx << std::endl << vx * ma - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-1.000e+000 -2.000e+000 -3.000e+000 -3.333e-001
+1.000e+000 +2.000e+000 +3.000e+000 +6.667e-001
+0.000e+000 +0.000e+000 -1.332e-015 +0.000e+000

+0.000e+000 +0.000e+000 +0.000e+000 +0.000e+000
+0.000e+000 +0.000e+000 +8.882e-016 -2.220e-016
+0.000e+000 +0.000e+000 -2.665e-015 +0.000e+000

-2.000e+000 +2.000e+000 +0.000e+000

+0.000e+000 +0.000e+000 +0.000e+000
\endcode
@see solve_tran(const BaseRMatrix&,TR&)const
@param[in] mB \ref rmatrix \f$B\f$.
@return Result object.
*/
    [[nodiscard]] BaseRMatrix solve_tran(const BaseRMatrix& mB) const {
        TR dErr(0.);
        return this->solve_tran(mB, dErr);
    }

// 6.1: reversed MATLAB-style operator B/A returning solution of X*A=B equation
/**
@brief Linear solver operator (transposed)

Creates \ref rvector object as solution \f$x\f$ of linear equation
\f$A^T*x=b\f$ (which is equivalent to \f$x*A=b\f$) where calling matrix is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Operator throws \ref cvmexception in case of inappropriate sizes
of the operands or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(12);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    double b[] = {1., 2., 3.};
    srmatrix ma(m, 3);
    rvector  vb(b, 3);
    rvector  vx(3);

    vx = ma % vb;

    std::cout << vx * ma - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+0.000000000000e+000 +0.000000000000e+000 +0.000000000000e+000
\endcode
@param[in] vB \ref rvector \f$b\f$.
@return Result object.
*/
    RVector operator % (const RVector& vB) const {
        return vB / (*this);
    }

// 6.1: reversed vector operator % returns solution of A*X=B equation
/**
@brief Linear solver operator

Creates \ref rvector object as solution \f$x\f$ of linear equation
\f$A*x=b\f$ where calling matrix is square matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Operator throws \ref cvmexception in case of inappropriate sizes
of the operands or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(12);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    double b[] = {1., 2., 3.};
    srmatrix ma(m, 3);
    rvector  vb(b, 3);
    rvector  vx(3);

    vx = ma / vb;

    std::cout << ma * vx - vb;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+0.000000000000e+000 +0.000000000000e+000 +0.000000000000e+000
\endcode
@param[in] vB \ref rvector \f$b\f$.
@return Result object.
*/
    RVector operator / (const RVector& vB) const {
        return vB % (*this);
    }

/**
@brief LU factorization based linear solver

Creates an object of type \ref rvector as
solution \f$x\f$ of linear equation
\f$A*x=b\f$ where calling matrix is square matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c vB is vector \f$b\f$.
Function also sets output parameter \c dErr to be equal to the norm of computation error.
This function is useful when you need to solve few linear equations
of kind \f$A*x=b\f$ with the same matrix \f$A\f$ and different vectors \f$b\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time.
It also sets output parameter \c dErr to be equal to the norm of computation error
and throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double a[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    srmatrix ma(a,3);
    srmatrix mLU(3);
    rmatrix  mb1(3,2); rvector vb1(3);
    rmatrix  mb2(3,2); rvector vb2(3);
    rmatrix  mx1(3,2); rvector vx1(3);
    rmatrix  mx2(3,2); rvector vx2(3);
    iarray   nPivots(3);
    double   dErr = 0.;
    mb1.randomize(-1.,3.); vb1.randomize(-2.,4.);
    mb2.randomize(-2.,5.); vb2.randomize(-3.,1.);

    mLU.low_up(ma, nPivots);
    mx1 = ma.solve_lu(mLU, nPivots, mb1, dErr);
    std::cout << mx1 << dErr << std::endl;
    mx2 = ma.solve_lu(mLU, nPivots, mb2);
    std::cout << mx2 << std::endl;;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;

    vx1 = ma.solve_lu(mLU, nPivots, vb1, dErr);
    std::cout << vx1 << dErr << std::endl;
    vx2 = ma.solve_lu(mLU, nPivots, vb2);
    std::cout << vx2 << std::endl;;
    std::cout << ma * vx1 - vb1 << std::endl << ma * vx2 - vb2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
2.807e+00 1.107e+00
-3.651e-01 -4.843e+00
-5.412e-01 3.095e+00
6.438e-15
-7.639e-01 1.082e+01
-2.869e-01 -1.110e+01
4.890e-01 3.443e+00

0.000e+00 -4.441e-16
1.110e-16 -4.441e-16
-4.441e-16 4.441e-16

0.000e+00 -4.441e-16
0.000e+00 8.882e-16
0.000e+00 -4.441e-16
-1.651e+00 2.361e-01 -6.384e-02
3.828e-15
-5.886e+00 7.038e+00 -3.125e+00

0.000e+00 0.000e+00 0.000e+00

0.000e+00 0.000e+00 2.220e-16
\endcode
@see low_up()
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] vB \ref rvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    RVector solve_lu(const basic_srmatrix& mLU, const tint* pPivots,
                     const RVector& vB, TR& dErr) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vB.size());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mLU.msize());
        RVector vX(this->msize());
        this->_solve(vB, vX, dErr, mLU, pPivots, 0);
        return vX;
    }

/**
@brief LU factorization based linear solver

Creates an object of type \ref rvector as
solution \f$x\f$ of linear equation
\f$A*x=b\f$ where calling matrix is square matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c vB is vector \f$b\f$.
Function also sets output parameter \c dErr to be equal to the norm of computation error.
This function is useful when you need to solve few linear equations
of kind \f$A*x=b\f$ with the same matrix \f$A\f$ and different vectors \f$b\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time.
It throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double a[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    srmatrix ma(a,3);
    srmatrix mLU(3);
    rmatrix  mb1(3,2); rvector vb1(3);
    rmatrix  mb2(3,2); rvector vb2(3);
    rmatrix  mx1(3,2); rvector vx1(3);
    rmatrix  mx2(3,2); rvector vx2(3);
    iarray   nPivots(3);
    double   dErr = 0.;
    mb1.randomize(-1.,3.); vb1.randomize(-2.,4.);
    mb2.randomize(-2.,5.); vb2.randomize(-3.,1.);

    mLU.low_up(ma, nPivots);
    mx1 = ma.solve_lu(mLU, nPivots, mb1, dErr);
    std::cout << mx1 << dErr << std::endl;
    mx2 = ma.solve_lu(mLU, nPivots, mb2);
    std::cout << mx2 << std::endl;;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;

    vx1 = ma.solve_lu(mLU, nPivots, vb1, dErr);
    std::cout << vx1 << dErr << std::endl;
    vx2 = ma.solve_lu(mLU, nPivots, vb2);
    std::cout << vx2 << std::endl;;
    std::cout << ma * vx1 - vb1 << std::endl << ma * vx2 - vb2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
2.807e+00 1.107e+00
-3.651e-01 -4.843e+00
-5.412e-01 3.095e+00
6.438e-15
-7.639e-01 1.082e+01
-2.869e-01 -1.110e+01
4.890e-01 3.443e+00

0.000e+00 -4.441e-16
1.110e-16 -4.441e-16
-4.441e-16 4.441e-16

0.000e+00 -4.441e-16
0.000e+00 8.882e-16
0.000e+00 -4.441e-16
-1.651e+00 2.361e-01 -6.384e-02
3.828e-15
-5.886e+00 7.038e+00 -3.125e+00

0.000e+00 0.000e+00 0.000e+00

0.000e+00 0.000e+00 2.220e-16
\endcode
@see low_up()
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] vB \ref rvector \f$b\f$.
@return Result object.
*/
    RVector solve_lu(const basic_srmatrix& mLU,
                     const tint* pPivots, const RVector& vB) const {
        TR dErr(0.);
        return this->solve_lu(mLU, pPivots, vB, dErr);
    }

/**
@brief LU factorization based linear solver

Creates an object of type \ref rmatrix as
solution \f$X\f$ of a matrix linear equation
\f$A*X=B\f$ where calling matrix is square matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c mB is matrix \f$B\f$.
This function is useful when you need to solve few linear equations
of kind \f$A*X=B\f$ with the same matrix \f$A\f$ and different matrices \f$B\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time.
Function also sets output parameter \c dErr to be equal to the norm of computation error
and throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double a[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    srmatrix ma(a,3);
    srmatrix mLU(3);
    rmatrix  mb1(3,2); rvector vb1(3);
    rmatrix  mb2(3,2); rvector vb2(3);
    rmatrix  mx1(3,2); rvector vx1(3);
    rmatrix  mx2(3,2); rvector vx2(3);
    iarray   nPivots(3);
    double   dErr = 0.;
    mb1.randomize(-1.,3.); vb1.randomize(-2.,4.);
    mb2.randomize(-2.,5.); vb2.randomize(-3.,1.);

    mLU.low_up(ma, nPivots);
    mx1 = ma.solve_lu(mLU, nPivots, mb1, dErr);
    std::cout << mx1 << dErr << std::endl;
    mx2 = ma.solve_lu(mLU, nPivots, mb2);
    std::cout << mx2 << std::endl;;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;

    vx1 = ma.solve_lu(mLU, nPivots, vb1, dErr);
    std::cout << vx1 << dErr << std::endl;
    vx2 = ma.solve_lu(mLU, nPivots, vb2);
    std::cout << vx2 << std::endl;;
    std::cout << ma * vx1 - vb1 << std::endl << ma * vx2 - vb2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
2.807e+00 1.107e+00
-3.651e-01 -4.843e+00
-5.412e-01 3.095e+00
6.438e-15
-7.639e-01 1.082e+01
-2.869e-01 -1.110e+01
4.890e-01 3.443e+00

0.000e+00 -4.441e-16
1.110e-16 -4.441e-16
-4.441e-16 4.441e-16

0.000e+00 -4.441e-16
0.000e+00 8.882e-16
0.000e+00 -4.441e-16
-1.651e+00 2.361e-01 -6.384e-02
3.828e-15
-5.886e+00 7.038e+00 -3.125e+00

0.000e+00 0.000e+00 0.000e+00

0.000e+00 0.000e+00 2.220e-16
\endcode
@see low_up()
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] mB \ref rmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    BaseRMatrix solve_lu(const basic_srmatrix& mLU,
                         const tint* pPivots, const BaseRMatrix& mB,
                         TR& dErr) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mB.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mLU.msize());
        BaseRMatrix mX(mB.msize(), mB.nsize());
        this->_solve(mB, mX, dErr, mLU, pPivots, 0);
        return mX;
    }

/**
@brief LU factorization based linear solver

Creates an object of type \ref rmatrix as
solution \f$X\f$ of a matrix linear equation
\f$A*X=B\f$ where calling matrix is square matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c mB is matrix \f$B\f$.
This function is useful when you need to solve few linear equations
of kind \f$A*X=B\f$ with the same matrix \f$A\f$ and different matrices \f$B\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time.
Function throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double a[] = {1., -1., 1., 2., -2., 1., 3., -2., 1.};
    srmatrix ma(a,3);
    srmatrix mLU(3);
    rmatrix  mb1(3,2); rvector vb1(3);
    rmatrix  mb2(3,2); rvector vb2(3);
    rmatrix  mx1(3,2); rvector vx1(3);
    rmatrix  mx2(3,2); rvector vx2(3);
    iarray   nPivots(3);
    double   dErr = 0.;
    mb1.randomize(-1.,3.); vb1.randomize(-2.,4.);
    mb2.randomize(-2.,5.); vb2.randomize(-3.,1.);

    mLU.low_up(ma, nPivots);
    mx1 = ma.solve_lu(mLU, nPivots, mb1, dErr);
    std::cout << mx1 << dErr << std::endl;
    mx2 = ma.solve_lu(mLU, nPivots, mb2);
    std::cout << mx2 << std::endl;;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;

    vx1 = ma.solve_lu(mLU, nPivots, vb1, dErr);
    std::cout << vx1 << dErr << std::endl;
    vx2 = ma.solve_lu(mLU, nPivots, vb2);
    std::cout << vx2 << std::endl;;
    std::cout << ma * vx1 - vb1 << std::endl << ma * vx2 - vb2;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
2.807e+00 1.107e+00
-3.651e-01 -4.843e+00
-5.412e-01 3.095e+00
6.438e-15
-7.639e-01 1.082e+01
-2.869e-01 -1.110e+01
4.890e-01 3.443e+00

0.000e+00 -4.441e-16
1.110e-16 -4.441e-16
-4.441e-16 4.441e-16

0.000e+00 -4.441e-16
0.000e+00 8.882e-16
0.000e+00 -4.441e-16
-1.651e+00 2.361e-01 -6.384e-02
3.828e-15
-5.886e+00 7.038e+00 -3.125e+00

0.000e+00 0.000e+00 0.000e+00

0.000e+00 0.000e+00 2.220e-16
\endcode
@see low_up()
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] mB \ref rmatrix \f$B\f$.
@return Result object.
*/
    BaseRMatrix solve_lu(const basic_srmatrix& mLU,
                         const tint* pPivots,
                         const BaseRMatrix& mB) const {
        TR dErr(0.);
        return this->solve_lu(mLU, pPivots, mB, dErr);
    }

/**
@brief Matrix determinant

Returns determinant of a calling matrix.
It uses the LU factorization internally and may throw the same exceptions as the factorizer.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix m(a, 3);
    std::cout << m << std::endl << m.det() << std::endl;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.000e+00 4.000e+00 7.000e+00
2.000e+00 5.000e+00 8.000e+00
3.000e+00 6.000e+00 1.000e+01

-3.000e+00
\endcode
@see low_up()
@return Determinant value.
*/
    [[nodiscard]] TR det() const {
        return this->_det();
    }

/**
@brief Low-up (LU) factorization

Compute LU factorization of square matrix \f$A\f$ as
\f[
A=PLU
\f]
where \f$P\f$ is permutation matrix, \f$L\f$ is lower
triangular matrix with unit diagonal
elements and \f$U\f$ is upper triangular matrix.
Function stores result as the matrix \f$L\f$ without
main diagonal combined with \f$U\f$. Function
returns pivot indices as  array of integers
(it should support at least \ref msize() elements)
pointed to by \c nPivots so \f$i\f$-th row
was interchanged with \c nPivots[\f$i\f$]-th row.
This version sets calling matrix to be equal to matrix
\c m's LU factorization.
Function throws \ref cvmexception in case of inappropriate
sizes of the operands or when the matrix to be factorized is close to
singular. It is recommended to use \ref iarray for pivot values.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix m(a, 3);
    srmatrix mLU(3), mLo(3), mUp(3);
    iarray naPivots(3);

    mLU.low_up(m, naPivots);

    mLo.identity();

    mLo.diag(-2) = mLU.diag(-2);
    mLo.diag(-1) = mLU.diag(-1);
    mUp.diag(0) = mLU.diag(0);
    mUp.diag(1) = mLU.diag(1);
    mUp.diag(2) = mLU.diag(2);

    std::cout << mLo << std::endl << mUp
              << std::endl << naPivots << std::endl;

    mLU = mLo * mUp;
    for (int i = 3; i >= 1; i--) {
        mLU.swap_rows(i, naPivots[i]);
    }
    std::cout << mLU;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.000e+00 0.000e+00 0.000e+00
3.333e-01 1.000e+00 0.000e+00
6.667e-01 5.000e-01 1.000e+00

3.000e+00 6.000e+00 1.000e+01
0.000e+00 2.000e+00 3.667e+00
0.000e+00 0.000e+00 -5.000e-01

3 3 3

1.000e+00 4.000e+00 7.000e+00
2.000e+00 5.000e+00 8.000e+00
3.000e+00 6.000e+00 1.000e+01
\endcode
@param[in] m \ref srmatrix to compute LU factorization for.
@param[out] nPivots %Array of pivot indices.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& low_up(const basic_srmatrix& m,
                           tint* nPivots) {
        (*this) = m;
        this->_low_up(nPivots);
        return *this;
    }

/**
@brief Low-up (LU) factorization

Compute LU factorization of square matrix \f$A\f$ as
\f[
A=PLU
\f]
where \f$P\f$ is permutation matrix, \f$L\f$ is lower
triangular matrix with unit diagonal
elements and \f$U\f$ is upper triangular matrix.
Function stores result as the matrix \f$L\f$ without
main diagonal combined with \f$U\f$. Function
returns pivot indices as  array of integers
(it should support at least \ref msize() elements)
pointed to by \c nPivots so \f$i\f$-th row
was interchanged with \c nPivots[\f$i\f$]-th row.
This version creates an object of type \ref srmatrix as calling matrix LU factorization.
Function throws \ref cvmexception in case of inappropriate
sizes of the operands or when the matrix to be factorized is close to
singular. It is recommended to use \ref iarray for pivot values.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix m(a, 3);
    srmatrix mLU(3), mLo(3), mUp(3);
    iarray naPivots(3);

    mLU = m.low_up(naPivots);

    mLo.identity();
    mLo.diag(-2) = mLU.diag(-2);
    mLo.diag(-1) = mLU.diag(-1);
    mUp.diag(0) = mLU.diag(0);
    mUp.diag(1) = mLU.diag(1);
    mUp.diag(2) = mLU.diag(2);
    std::cout << mLo << std::endl << mUp
              << std::endl << naPivots << std::endl;
    mLU = mLo * mUp;
    for (int i = 3; i >= 1; i--) {
        mLU.swap_rows(i, naPivots[i]);
    }
    std::cout << mLU;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
+1.000e+000 +0.000e+000 +0.000e+000
+3.333e-001 +1.000e+000 +0.000e+000
+6.667e-001 +5.000e-001 +1.000e+000

+3.000e+000 +6.000e+000 +1.000e+001
+0.000e+000 +2.000e+000 +3.667e+000
+0.000e+000 +0.000e+000 -5.000e-001

+3 +3 +3

+1.000e+000 +4.000e+000 +7.000e+000
+2.000e+000 +5.000e+000 +8.000e+000
+3.000e+000 +6.000e+000 +1.000e+001
\endcode
@param[out] nPivots %Array of pivot indices.
@return Result object.
*/
    basic_srmatrix low_up(tint* nPivots) const {
        basic_srmatrix mRes(*this);
        mRes._low_up(nPivots);
        return mRes;
    }

/**
@brief Condition number reciprocal

Returns condition number reciprocal of
a calling matrix \f$A\f$ in the infinity-norm
\f[
\kappa_\infty=\|A\|_\infty \|A^{-1}\|_\infty.
\f]
Less value returned means that matrix \f$A\f$ is closer to singular.
Zero value returned means estimation underflow or
that matrix \f$A\f$ is singular.
The condition number is used for error analysis of systems of linear equations.
Function throws \ref cvmexception in case of LAPACK subroutines failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    srmatrix m(a, 3);
    std::cout << m.cond() << std::endl
              << m.det() << std::endl << std::endl;
    m(3,3) = 10.;
    std::cout << m.cond() << std::endl << m.det() << std::endl;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
0.000e+00
0.000e+00

7.519e-03
-3.000e+00
\endcode
@see basic_array::norminf()
@return Result value.
*/
    [[nodiscard]] TR cond() const {
        TR dCondNum(0.);
        __cond_num<TR,basic_srmatrix>(*this, dCondNum);  // universal method, no need to virtualize
        return dCondNum;
    }

/**
@brief Matrix inversion

This version sets calling matrix to be equal to square matrix \c m inverted.
Function throws \ref cvmexception in case of inappropriate
sizes of the operands or when the matrix to be inverted is close to singular.
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(10);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix m(a, 3);
    srmatrix mi(3);
    mi.inv(m);
    std::cout << mi << std::endl << mi * m - eye_real(3);
    std::cout << std::endl << mi.inv() * mi - eye_real(3);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-6.6666666667e-01 -6.6666666667e-01 1.0000000000e+00
-1.3333333333e+00 3.6666666667e+00 -2.0000000000e+00
1.0000000000e+00 -2.0000000000e+00 1.0000000000e+00

0.0000000000e+00 0.0000000000e+00 1.7763568394e-15
1.7763568394e-15 3.5527136788e-15 0.0000000000e+00
0.0000000000e+00 0.0000000000e+00 1.7763568394e-15

0.0000000000e+00 1.7763568394e-15 -1.7763568394e-15
-8.8817841970e-16 3.5527136788e-15 -3.5527136788e-15
0.0000000000e+00 0.0000000000e+00 -1.7763568394e-15
\endcode
@param[in] m \ref srmatrix to invert.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& inv(const basic_srmatrix& m) {
        __inv<basic_srmatrix>(*this, m);  // overridden in srsmatrix, no need to virtualize
        return *this;
    }

/**
@brief Matrix inversion

This version creates \ref srmatrix object equal to a calling matrix inverted.
Function throws \ref cvmexception in case of memory allocation failure
or when the matrix to be inverted is close to singular.
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(10);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    srmatrix m(a, 3);
    srmatrix mi(3);
    mi.inv(m);
    std::cout << mi << std::endl << mi * m - eye_real(3);
    std::cout << std::endl << mi.inv() * mi - eye_real(3);
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-6.6666666667e-01 -6.6666666667e-01 1.0000000000e+00
-1.3333333333e+00 3.6666666667e+00 -2.0000000000e+00
1.0000000000e+00 -2.0000000000e+00 1.0000000000e+00

0.0000000000e+00 0.0000000000e+00 1.7763568394e-15
1.7763568394e-15 3.5527136788e-15 0.0000000000e+00
0.0000000000e+00 0.0000000000e+00 1.7763568394e-15

0.0000000000e+00 1.7763568394e-15 -1.7763568394e-15
-8.8817841970e-16 3.5527136788e-15 -3.5527136788e-15
0.0000000000e+00 0.0000000000e+00 -1.7763568394e-15
\endcode
@return Result object.
*/
    [[nodiscard]] basic_srmatrix inv() const {
        basic_srmatrix mRes(this->msize());
        __inv<basic_srmatrix>(mRes, *this);  // overridden in srsmatrix, no need to virtualize
        return mRes;
    }

/**
@brief Matrix exponent

Computes exponent of square matrix using Pade approximation defined as
\f[
R_{pq}(z)=D_{pq}(z)^{-1}N_{pq}(z)=1+z+\dots+z^p/p!\,,
\f]
where
\f[\begin{aligned}
N_{pq}(z)&=\sum_{k=0}^p\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}z^k,\\
D_{pq}(z)&=\sum_{k=0}^q\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}(-z)^k
\end{aligned}\f]
along with the matrix normalizing as described in
<em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 572.
Function uses \ref DMEXP (or \ref SMEXP for \c float version)
\c FORTRAN subroutine implementing the algorithm.
This version sets calling matrix to be equal to
exponent of \c m and returns a reference to the matrix changed.
The algorithm uses parameter \c tol as \f$\varepsilon(p,q)\f$ in order to choose constants \f$p\f$ and \f$q\f$
so that
\f[
\varepsilon(p,q)\ge 2^{3-(p+q)}\frac{p!q!}{(p+q)!(p+q+1)!}.
\f]
This parameter is equal to the <em>largest relative spacing</em> (see cvmMachSp() ) by default.
Function throws \ref cvmexception in case of
inappropriate sizes of the operands or when LAPACK subroutine fails.
\par Example
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(15);
try {
    srmatrix m(2), me(2);
    m(1,1) = -49.;
    m(1,2) = 24.;
    m(2,1) = -64.;
    m(2,2) = 31.;
    me.exp(m);
    std::cout << m << std::endl << me;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-4.900000000000000e+001 2.400000000000000e+001
-6.400000000000000e+001 3.100000000000000e+001

-7.357587581448284e-001 5.518190996581556e-001
-1.471517599088415e+000 1.103638240715692e+000
\endcode
Matlab output:
\code
-7.357587581446907e-001    5.518190996580505e-001
-1.471517599088136e+000    1.103638240715478e+000
\endcode
@param[in] m \ref srmatrix to compute exponent for.
@param[in] tol Computation tolerance.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& exp(const basic_srmatrix& m,
                        TR tol = basic_cvmMachSp<TR>()) {
        // uses universal code inside - no need to virtualize
        __exp<basic_srmatrix, TR>(*this, m, tol);
        return *this;
    }

/**
@brief Matrix exponent

Computes exponent of square matrix using Pade approximation defined as
\f[
R_{pq}(z)=D_{pq}(z)^{-1}N_{pq}(z)=1+z+\dots+z^p/p!\,,
\f]
where
\f[\begin{aligned}
N_{pq}(z)&=\sum_{k=0}^p\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}z^k,\\
D_{pq}(z)&=\sum_{k=0}^q\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}(-z)^k
\end{aligned}\f]
along with the matrix normalizing as described in
<em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 572.
Function uses \ref DMEXP (or \ref SMEXP for \c float version)
\c FORTRAN subroutine implementing the algorithm.
This version creates an object of type \c srmatrix as exponent of a calling matrix.
The algorithm uses parameter \c tol as \f$\varepsilon(p,q)\f$ in order to choose constants \f$p\f$ and \f$q\f$
so that
\f[
\varepsilon(p,q)\ge 2^{3-(p+q)}\frac{p!q!}{(p+q)!(p+q+1)!}.
\f]
This parameter is equal to the <em>largest relative spacing</em> (see cvmMachSp() ) by default.
Function throws \ref cvmexception in case of
inappropriate sizes of the operands or when LAPACK subroutine fails.
\par Example
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(15);
try {
    srmatrix m(2);
    m(1,1) = -49.;
    m(1,2) = 24.;
    m(2,1) = -64.;
    m(2,2) = 31.;
    std::cout << m << std::endl << m.exp();
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-4.900000000000000e+01 2.400000000000000e+01
-6.400000000000000e+01 3.100000000000000e+01

-7.357587581448284e-01 5.518190996581556e-01
-1.471517599088415e+00 1.103638240715692e+00
\endcode
Matlab output:
\code
-7.357587581446907e-001    5.518190996580505e-001
-1.471517599088136e+000    1.103638240715478e+000
\endcode
@param[in] tol Computation tolerance.
@return Result object.
*/
    [[nodiscard]] basic_srmatrix exp(TR tol = basic_cvmMachSp<TR>()) const {
        basic_srmatrix mRes(this->msize());
        __exp<basic_srmatrix, TR>(mRes, *this, tol);
        return mRes;
    }

// this = v(1)*I + v(2)*m + v(3)*m^2 + ... + v(N)*m^(N-1)
/**
@brief Matrix polynomial

Computes matrix polynomial defined as
\f[
p(A)=b_0I+b_1A+\dots+b_qA^q
\f]
using the Horner's rule:
\f[
\newcommand{\floor}{\operatorname{floor}}p(A)=\sum_{k=0}^r B_k(A^s)^k,\quad s=\floor(\!\sqrt{q}\,),\ r=\floor(q/s)
\f]
where
\f[
B_k=\begin{cases}
\sum\limits_{i=0}^{s-1}b_{sk+i} A^i, & k=0,1,\dots,r-1\\
\sum\limits_{i=0}^{q-sr}b_{sr+i} A^i, & k=r.
\end{cases}
\f]
See also <em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 568.
The coefficients \f$b_0,b_1,\dots,b_q\f$ are passed in parameter \c v,
where \f$q\f$ is equal to \c v.size()-1, so the function
computes matrix polynomial equal to
\f[
\mathtt{v[1]*I + v[2]*m +\cdots + v[v.size()]*m^{v.size()-1}}
\f]
This version sets calling matrix to be equal to the polynomial of \c m.
Function uses \ref DPOLY (or \ref SPOLY for \c float version) \c FORTRAN subroutine implementing the Horner's algorithm.
Function throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(15);
try {
    double a[] = {2.2, 1.3, 1.1, -0.9, 0.2,
                 -0.45, 45, -30, 10, 3, 3.2};
    const rvector v(a, 11);
    srmatrix m(2), mp(2);
    m(1,1) = 1.;
    m(1,2) = 0.5;
    m(2,1) = -1.;
    m(2,2) = 0.3;
    mp.polynom(m, v);
    std::cout << mp;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-7.963641665999998e+00 -7.551532476200001e+00
1.510306495240000e+01 2.608503800680002e+00
\endcode
Matlab output:
\code
-7.963641665999999e+000   -7.551532476200002e+000
 1.510306495240000e+001    2.608503800680002e+000
\endcode
@param[in] m \ref srmatrix to compute polynomial for.
@param[in] v Vector of coefficients.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& polynom(const basic_srmatrix& m,
                            const RVector& v) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        RVector v1;
        if (v.incr() > 1) v1 << v;  // to make sure incr = 1
        __polynom<TR,RVector>(this->get(), this->ld(), this->msize(),
                              m._pd(), m._ldm(), v.incr() > 1 ? v1 : v);
        return *this;
    }

    // returns v(1)*I + v(2)*this + v(3)*this^2 + ... + v(N)*this^(N-1)
/**
@brief Matrix polynomial

Computes matrix polynomial defined as
\f[
p(A)=b_0I+b_1A+\dots+b_qA^q
\f]
using the Horner's rule:
\f[
\newcommand{\floor}{\operatorname{floor}}p(A)=\sum_{k=0}^r B_k(A^s)^k,\quad s=\floor(\!\sqrt{q}\,),\ r=\floor(q/s)
\f]
where
\f[
B_k=\begin{cases}
\sum\limits_{i=0}^{s-1}b_{sk+i} A^i, & k=0,1,\dots,r-1\\
\sum\limits_{i=0}^{q-sr}b_{sr+i} A^i, & k=r.
\end{cases}
\f]
See also <em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 568.
The coefficients \f$b_0,b_1,\dots,b_q\f$ are passed in parameter \c v,
where \f$q\f$ is equal to \c v.size()-1, so the function
computes matrix polynomial equal to
\f[
\mathtt{v[1]*I + v[2]*m +\cdots + v[v.size()]*m^{v.size()-1}}
\f]
This version creates an object of type \ref srmatrix as the polynomial of a calling matrix.
Function uses \ref DPOLY (or \ref SPOLY for \c float version) \c FORTRAN subroutine implementing the Horner's algorithm.
Function throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(15);
try {
    double a[] = {2.2, 1.3, 1.1, -0.9, 0.2,
                 -0.45, 45, -30, 10, 3, 3.2};
    const rvector v(a, 11);
    srmatrix m(2);
    m(1,1) = 1.;
    m(1,2) = 0.5;
    m(2,1) = -1.;
    m(2,2) = 0.3;
    srmatrix mp = m.polynom(v);
    std::cout << mp;
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
-7.963641665999998e+000 -7.551532476200001e+000
1.510306495240000e+001 2.608503800680002e+000
\endcode
Matlab output:
\code
-7.963641665999999e+000   -7.551532476200002e+000
 1.510306495240000e+001    2.608503800680002e+000
\endcode
@param[in] v Vector of coefficients.
@return Result object.
*/
    [[nodiscard]] basic_srmatrix polynom(const RVector& v) const {
        basic_srmatrix mRes(this->msize());
        RVector v1;
        if (v.incr() > 1) v1 << v;  // to make sure incr = 1
        __polynom<TR,RVector>(mRes.get(), mRes.ld(), this->msize(),
                              this->get(), this->ld(), v.incr() > 1 ? v1 : v);
        return mRes;
    }

/**
@brief Eigenvalues and eigenvectors

Solves eigenvalue problem and creates \ref cvector object equal to eigenvalues
of a calling matrix.
The eigenvalue problem is defined as follows: given square matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
Some eigenvalues may be complex even for real matrix \f$A\f$.
Moreover, if real nonsymmetric matrix has a complex eigenvalue \f$a+bi\f$
corresponding to an eigenvector \f$z\f$, then \f$a-bi\f$ is also an eigenvalue.
The eigenvalue \f$a-bi\f$ corresponds to the eigenvector whose elements
are complex conjugate to the elements of \f$z\f$.
Function sets output parameter \c mEigVect to be equal to square matrix containing eigenvectors as columns.
Function also computes "left" eigenvectors if parameter \c bRightVect is set to \c false.
Left eigencectors satisfy
\f[
z^HA = \lambda z^H.
\f]
Function throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;
try {
    scmatrix m(3), me(3);
    cvector vl(3);

    m(1,1) = 0.1;  m(1,2) = 0.2;  m(1,3) = 0.1;
    m(2,1) = 0.11; m(2,2) = -2.9; m(2,3) = -8.4;
    m(3,1) = 0.;   m(3,2) = 2.91; m(3,3) = 8.2;

    vl = m.eig(me);
    std::cout << vl;

    m(2,2) = 2.9;
    vl = m.eig(me);
    std::cout << vl << std::endl;

    std::cout.setf(std::ios::scientific | std::ios::showpos);
    std::cout.precision(1);

    std::cout << m * me(1) - me(1) * vl(1);
    std::cout << m * me(2) - me(2) * vl(2);
    std::cout << m * me(3) - me(3) * vl(3);
}
catch(std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(-0.0555784,0) (0.285327,0) (5.17025,0)
(0.0968985,-1.38778e-017) (5.55155,4.1733) (5.55155,-4.1733)

(+1.4e-017,+2.8e-017) (-1.0e-016,-5.4e-017) (+3.9e-017,+4.3e-017)
(-5.0e-016,+1.7e-016) (-7.1e-015,+2.9e-015) (+3.6e-015,+2.7e-015)
(-3.1e-016,+2.8e-017) (-2.7e-015,-8.9e-016) (+8.9e-016,+3.6e-015)
\endcode
@see cvector::eig()
@param[out] mEigVect Eigenvectors of a calling matrix.
@param[in] bRightVect \c true (default) to compute right eigenvectors.
@return Result object.
*/
    CVector eig(basic_scmatrix<TR,TC>& mEigVect, bool bRightVect = true) const {
        CVector vEig(this->msize());
        this->_eig(vEig, &mEigVect, bRightVect);
        return vEig;
    }

/**
@brief Eigenvalues

Solves eigenvalue problem and creates \ref cvector object equal to eigenvalues
of a calling matrix.
The eigenvalue problem is defined as follows: given square matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
Some eigenvalues may be complex even for real matrix \f$A\f$.
Moreover, if real nonsymmetric matrix has a complex eigenvalue \f$a+bi\f$
corresponding to an eigenvector \f$z\f$, then \f$a-bi\f$ is also an eigenvalue.
The eigenvalue \f$a-bi\f$ corresponds to the eigenvector whose elements
are complex conjugate to the elements of \f$z\f$.
Function throws \ref cvmexception
in case of in caso of memory allocation failure or convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    srmatrix m(3);
    m(1,1) = 0.1;  m(1,2) = 0.2;  m(1,3) = 0.1;
    m(2,1) = 0.11; m(2,2) = 2.9;  m(2,3) = -8.4;
    m(3,1) = 0.;   m(3,2) = 2.91; m(3,3) = 8.2;
    std::cout << m.eig();
}
catch(std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+9.69e-002,+0.00e+000) (+5.55e+000,+4.17e+000) (+5.55e+000,-4.17e+000)
\endcode
@see cvector::eig()
@return Result object.
*/
    [[nodiscard]] CVector eig() const {
        CVector vEig(this->msize());
        this->_eig(vEig, nullptr, true);
        return vEig;
    }

/**
@brief Cholesky factorization

Forms the Cholesky factorization of symmetric positive-definite matrix \f$A\f$ defined as
\f[
A=U^T U,
\f]
where \f$U\f$ is upper triangular matrix.
It utilizes one of \c ZPOTRF routines of the
\c LAPACK library. Function sets calling matrix to be equal to the factorization
of symmetric positive-definite matrix \c m.
Function throws \ref cvmexception in case of inappropriate sizes of the operands
or in case of convergence error.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 1., 2., 5., -1., 1., -1., 20.};
    const srsmatrix m(a, 3);
    srmatrix h(3);
    h.cholesky(m);
    std::cout << h << std::endl;
    std::cout << ~h * h - m;
}
catch(std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1 2 1
0 1 -3
0 0 3.16228

0 0 0
0 0 0
0 0 0
\endcode
@see http://www.netlib.org/lapack
@param[in] m \ref srsmatrix to factorize.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& cholesky(const basic_srsmatrix<TR>& m) {
        this->_check_cholesky();  // doesn't work for band matrices
        *this = m;
        tint nOutInfo = __cholesky<basic_srmatrix>(*this);
        _check_negative(CVM_WRONGMKLARG, nOutInfo);
        _check_positive(CVM_NOTPOSITIVEDEFINITE, nOutInfo);
        this->_clean_low_triangle();
        return *this;
    }

/**
@brief Bunch-Kaufman factorization

Forms the Bunch-Kaufman factorization of symmetric matrix (cited from the MKL library documentation):
\f[
A=PUDU^TP^T,
\f]
where \f$A\f$ is the input matrix passed in parameter \c m,
\f$P\f$ is a permutation matrix, \f$U\f$ and \f$L\f$ are upper and lower triangular
matrices with unit diagonal, and \f$D\f$ is a symmetric
block-diagonal matrix with 1-by-1 and 2-by-2
diagonal blocks. \f$U\f$ and \f$L\f$ have 2-by-2 unit diagonal
blocks corresponding to the 2-by-2 blocks of \f$D\f$.
It utilizes one of \c DSYTRF routines of the \c LAPACK library.
Function sets calling matrix to be equal to the factorization
of symmetric positive-definite matrix \c m.
Function throws \ref cvmexception in case of inappropriate sizes of the operands
or in case of convergence error.
Function is mostly designed to be used for subsequent calls
of \c DSYTRS, \c DSYCON and \c DSYTRI routines of the
\c LAPACK library.
Currently it's used internally in \ref det() flow
when argument is symmetric but not positive-definite.

@see http://www.netlib.org/lapack
@param[in] m \ref srsmatrix to factorize.
@param[out] nPivots Pivot indices array.
@return Reference to changed calling matrix.
*/
    basic_srmatrix& bunch_kaufman(const basic_srsmatrix<TR>& m,
                                  tint* nPivots) {
        this->_check_bunch_kaufman();  // doesn't work for band matrices
        *this = m;
        __bunch_kaufman<basic_srmatrix>(*this, nPivots);
        return *this;
    }

/**
@brief QR factorization

Computes QR factorization as
\f[
A=QR
\f]
where \f$A\f$ is calling square matrix, orthogonal matrix \f$Q\f$
and upper triangular matrix \f$R\f$ are \c mQ and \c mR respectively.
Function throws \ref cvmexception in case if inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
const cvm::srmatrix m(a, 3);
cvm::srmatrix q(3), r(3);
m.qr(q,r);
std::cout << (eye_real(3) - ~q * q).norm()
          << " " << (m - q * r).norm() << std::endl;
\endcode
prints
\code
+5.2889959e-16 +7.0854500e-15
\endcode
@param[out] mQ \ref srmatrix \f$Q\f$.
@param[out] mR \ref srmatrix \f$R\f$.
*/
    void qr(basic_srmatrix<TR>& mQ, basic_srmatrix<TR>& mR) const {
        this->_qr_ss(mQ, mR);
    }

/**
@brief LQ factorization

Computes LQ factorization as
\f[
A=LQ
\f]
where \f$A\f$ is calling square matrix, lower triangular matrix \f$L\f$
and orthogonal matrix \f$Q\f$ are \c mL and \c mQ respectively.
Function throws \ref cvmexception in case if inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
const cvm::srmatrix m(a, 3);
cvm::srmatrix l(3), q(3);
m.lq(l,q);
std::cout << (eye_real(3) - ~q * q).norm()
          << " " << (m - l * q).norm() << std::endl;
\endcode
prints
\code
+7.3329369e-016 +8.1523942e-015
\endcode
@param[out] mL \ref srmatrix \f$L\f$.
@param[out] mQ \ref srmatrix \f$Q\f$.
*/
    void lq(basic_srmatrix<TR>& mL, basic_srmatrix<TR>& mQ) const {
        this->_lq_ss(mL, mQ);
    }

/**
@brief QL factorization

Computes QL factorization as
\f[
A=QL
\f]
where \f$A\f$ is calling square matrix, orthogonal matrix \f$Q\f$
and lower triangular matrix \f$L\f$ are \c mQ and \c mL respectively.
Function throws \ref cvmexception in case if inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
const cvm::srmatrix m(a, 3);
cvm::srmatrix q(3), l(3);
m.ql(q,l);
std::cout << (eye_real(3) - ~q * q).norm()
          << " " << (m - q * l).norm() << std::endl;
\endcode
prints
\code
+1.6146017e-015 +4.3341378e-015
\endcode
@param[out] mQ \ref srmatrix \f$Q\f$.
@param[out] mL \ref srmatrix \f$L\f$.
*/
    void ql(basic_srmatrix<TR>& mQ, basic_srmatrix<TR>& mL) const {
        this->_ql_ss(mQ, mL);
    }

/**
@brief RQ factorization

Computes RQ factorization as
\f[
A=RQ
\f]
where \f$A\f$ is calling square matrix, upper triangular matrix \f$R\f$
and orthogonal matrix \f$Q\f$ are \c mR and \c mQ respectively.
Function throws \ref cvmexception in case if inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
const cvm::srmatrix m(a, 3);
cvm::srmatrix r(3), q(3);
m.rq(r,q);
std::cout << (eye_real(3) - ~q * q).norm()
          << " " << (m - r * q).norm() << std::endl;
\endcode
prints
\code
+3.7030557e-016 +2.2752801e-015
\endcode
@param[out] mR \ref srmatrix \f$R\f$.
@param[out] mQ \ref srmatrix \f$Q\f$.
*/
    void rq(basic_srmatrix<TR>& mR, basic_srmatrix<TR>& mQ) const {
        this->_rq_ss(mR, mQ);
    }

/**
@brief Identity matrix

Sets calling matrix to be equal to identity matrix and returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
srmatrix m(3);
m.randomize(0.,1.);
std::cout << m << std::endl;
std::cout << m.identity();
\endcode
prints
\code
9.423e-01 2.950e-01 8.429e-01
2.013e-01 3.250e-01 2.904e-01
7.920e-01 2.405e-02 7.801e-01

1.000e+00 0.000e+00 0.000e+00
0.000e+00 1.000e+00 0.000e+00
0.000e+00 0.000e+00 1.000e+00
\endcode
@return Reference to changed calling matrix.
*/
    basic_srmatrix& identity() {
        this->_vanish();
        this->_plus_plus();
        return *this;
    }

/**
@brief Set matrix to zero

Sets every element of a calling square matrix to be equal to zero
and returns a reference to the matrix changed. This function is faster
than, for example, set(TR) with zero parameter passed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
srmatrix m(3);
m.randomize(0.,1.);
std::cout << m << std::endl;
std::cout << m.vanish();
\endcode
prints
\code
1.747e-01 7.563e-01 5.163e-01
9.657e-01 6.619e-01 8.036e-01
6.392e-01 6.658e-01 6.495e-01

0.000e+00 0.000e+00 0.000e+00
0.000e+00 0.000e+00 0.000e+00
0.000e+00 0.000e+00 0.000e+00
\endcode
@return Reference to changed calling matrix.
*/
    basic_srmatrix& vanish() {
        this->_vanish();
        return *this;
    }

    basic_srmatrix& randomize(TR dFrom, TR dTo) {
        this->_randomize(dFrom, dTo);
        return *this;
    }

//! @cond INTERNAL
    virtual void _eig(CVector& vEig, basic_scmatrix<TR,TC>* mEigVect,
                      bool bRightVect) const {
        __eig<CVector, basic_srmatrix,
            basic_scmatrix<TR,TC>> (vEig, *this, mEigVect, bRightVect);
    }

    virtual void _solve(const RVector& vB, RVector& vX,
                        TR& dErr, const TR* pLU, const tint* pPivots,
                        int transp_mode) const {
        vX = vB;
        RVector vB1;
        RVector vX1;
        if (vB.incr() > 1) vB1 << vB;  // to make sure incr = 1
        if (vX.incr() > 1) vX1 << vX;
        __solve<TR,TR, basic_srmatrix>(*this, 1, vB.incr() > 1 ? vB1 : vB, vB.size(),
                                       vX.incr() > 1 ? vX1 : vX, vX.size(),
                                       dErr, pLU, pPivots, transp_mode);
        if (vX.incr() > 1) vX = vX1;
    }

    virtual void _solve(const BaseRMatrix& mB, BaseRMatrix& mX,
                        TR& dErr, const TR* pLU, const tint* pPivots,
                        int transp_mode) const {
        mX = mB;
        __solve<TR,TR, basic_srmatrix>(*this, mB.nsize(), mB, mB.ld(),
                                       mX, mX.ld(), dErr, pLU, pPivots, transp_mode);
    }

    [[nodiscard]] const TR* _pv() const override {
        return this->get();
    }

    TR* _pv() override {
        return this->get();
    }

protected:
    // protected constructors for inherited stuff
    basic_srmatrix(tint nDim, tint nLD, bool bZeroMemory)
      : BaseRMatrix(nDim, nDim, nLD, bZeroMemory)
    {}

    basic_srmatrix(tint size, tint incr, tint msize, tint nsize, tint ld)
      : BaseRMatrix(size, incr, msize, nsize, ld)
    {}

    // non-const version shares memory
    basic_srmatrix(TR* pd, tint nDim, tint nLD, tint nSize)
      : BaseRMatrix(pd, nDim, nDim, nLD, nSize)
    {}

    // const version makes a copy
    basic_srmatrix(const TR* pd, tint nDim, tint nLD, tint nSize)
      : BaseRMatrix(pd, nDim, nDim, nLD, nSize)
    {}

    [[nodiscard]] tint _size() const override {
        return this->size();
    }
    [[nodiscard]] tint _msize() const override {
        return this->msize();
    }
    [[nodiscard]] tint _nsize() const override {
        return this->nsize();
    }
    [[nodiscard]] tint _ld() const override {
        return this->ld();
    }

    // returns diagonal which IS l-value (shares memory)
    // 0 - main, negative - low, positive - up
    RVector _diag(tint nDiag) override {
        const tint nD = std::abs(nDiag);
        _check_ge(CVM_INDEX_GE, nD, this->msize());
        return RVector(this->get() + (nDiag > 0 ? nDiag * this->ld() : nD),
                       this->msize() - nD, this->ld() + 1);
    }

    // returns diagonal which is NOT l-value (creates a copy)
    // 0 - main, negative - low, positive - up
    [[nodiscard]] RVector _diag(tint nDiag) const override {
        const tint nD = std::abs(nDiag);
        _check_ge(CVM_INDEX_GE, nD, this->msize());
        return RVector(this->get() + (nDiag > 0 ? nDiag * this->ld() : nD),
                       this->msize() - nD, this->ld() + 1);
    }

    // returns main diagonal of low_up factorization
    virtual RVector _low_up_diag(basic_array<tint,tint>& naPivots) const {
        // let temp matrix be const to get a copy of its main diagonal
        const basic_srmatrix lu = this->low_up(naPivots);
        return lu.diag(0);
    }

    virtual void _transp() {
        this->_sq_transp();
    }

    virtual void _plus_plus() {
        this->_sq_plus_plus();
    }

    virtual void _minus_minus() {
        this->_sq_minus_minus();
    }

    [[nodiscard]] virtual TR _det() const {
        TR dDet(0.);
        switch (this->msize()) {
        case 0:
            break;
        case 1:
            dDet = this->_ij_val(0, 0);
            break;
        case 2:
            dDet = this->_ij_val(0, 0) * this->_ij_val(1, 1) -
               this->_ij_val(1, 0) * this->_ij_val(0, 1);
            break;
        default:
            try {
                const TR one(1.);
                basic_array<tint,tint> naPivots(this->msize());
                RVector vUpDiag = this->_low_up_diag(naPivots);

                dDet = one;
                for (tint i = 0; i <= this->msize() - 1; ++i) {
                    dDet *= vUpDiag[i];
                    if (i + 1 != naPivots[i]) {
                        dDet = -dDet;
                    }
                }
            }
            catch (const cvmexception& e) {
                if (e.cause() != CVM_SINGULARMATRIX) throw e;
            }
            break;
        }
        return dDet;
    }

    virtual void _low_up(tint* nPivots) {
        __low_up<basic_srmatrix>(*this, nPivots);
    }

    // QR - "economy" mode here
    void _qr_ss(basic_srmatrix<TR>& mQ, basic_srmatrix<TR>& mR) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mR.msize());
        __qre<basic_rmatrix<TR>, basic_srmatrix<TR>> (*this, mQ, mR);
    }

    // RQ - "economy" mode here
    void _rq_ss(basic_srmatrix<TR>& mR, basic_srmatrix<TR>& mQ) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mR.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        __rqe<basic_rmatrix<TR>, basic_srmatrix<TR>> (*this, mR, mQ);
    }

    // LQ - "economy" mode here
    void _lq_ss(basic_srmatrix<TR>& mL, basic_srmatrix<TR>& mQ) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mL.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        __lqe<basic_rmatrix<TR>, basic_srmatrix<TR>> (*this, mL, mQ);
    }

    // QL - "economy" mode here
    void _ql_ss(basic_srmatrix<TR>& mQ, basic_srmatrix<TR>& mL) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mL.msize());
        __qle<basic_rmatrix<TR>, basic_srmatrix<TR>> (*this, mQ, mL);
    }

    virtual void _check_cholesky() { }
    virtual void _check_bunch_kaufman() { }

private:
    RVector _solve_helper(const RVector& vB, TR& dErr,
                          int transp_mode) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vB.size());
        RVector vX(this->msize());
        this->_solve(vB, vX, dErr, nullptr, nullptr, transp_mode);
        return vX;
    }

    BaseRMatrix _solve_helper(const BaseRMatrix& mB, TR& dErr,
                              int transp_mode) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mB.msize());
        BaseRMatrix mX(mB.msize(), mB.nsize());
        this->_solve(mB, mX, dErr, nullptr, nullptr, transp_mode);
        return mX;
    }
//! @endcond
};


/**
@brief End-user class encapsulating matrix of complex numbers

\c TR type stands for \ref treal, \c TC type stands for \ref tcomplex. Please use predefined \ref cmatrix class in your applications.
@see Matrix
*/
template<typename TR, typename TC>
class basic_cmatrix : public Matrix<TR,TC>
{
    using RVector = basic_rvector<TR>;  //!< \ref rvector class
    using CVector = basic_cvector<TR,TC>;  //!< \ref cvector class
    using BaseArray = basic_array<TR,TC>;  //!< Base basic_array class
    using BaseMatrix = Matrix<TR,TC>;  //!< Base Matrix class

    friend class basic_cvector<TR,TC>;  // for _multiply

public:
/**
@brief Default constructor

Creates empty matrix. No memory gets allocated.
\par Example:
\code
using namespace cvm;
cmatrix m;
std::cout << m.msize() << std::endl
          << m.nsize() << std::endl;
m << eye_complex(3);
std::cout << m;
\endcode
prints
\code
0
0
(1,0) (0,0) (0,0)
(0,0) (1,0) (0,0)
(0,0) (0,0) (1,0)
\endcode
*/
    basic_cmatrix() = default;

    ~basic_cmatrix() override = default;

/**
@brief Constructor

Creates \f$m\times n\f$ \ref cmatrix object where \f$m\f$ is passed in
\c nM parameter (number of rows) and \f$n\f$ is passed in \c nN (number of columns).
Constructor sets all elements to zero.
It throws \ref cvmexception in case of non-positive sizes passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
cmatrix m(3, 4);
std::cout << m.msize() << std::endl
          << m.nsize() << std::endl
          << m.size()  << std::endl << m;
\endcode
prints
\code
3
4
12
(0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0)
\endcode
@param[in] nM Number of rows.
@param[in] nN Number of columns.
*/
    basic_cmatrix(tint nM, tint nN)
      : BaseMatrix(nM, nN, nM, true)
    {}

/**
@brief Constructor

Creates \f$m\times n\f$ \ref cmatrix object where \f$m\f$ is passed in
\c nM parameter (number of rows) and \f$n\f$ is passed in \c nN (number of columns).
It throws \ref cvmexception in case of non-positive sizes passed.
Unlike others, this constructor <b>does not allocate memory</b>.
It just shares memory with an array pointed to by \c pd (for matrices \c nIncr=1 is always satisfied).
\par Example:
\code
using namespace cvm;
double a[] = {5., 5., 5., 5., 5., 5.,
              5., 5., 5., 5., 5., 5.};
cmatrix m((std::complex<double>*) a, 2, 3);
m(1,1) = std::complex<double>(1.,2.);
std::cout << m << std::endl;
std::cout << a[0] << " " << a[1] << " "
          << a[2] << " " << a[3] << std::endl;
\endcode
prints
\code
(1,2) (5,5) (5,5)
(5,5) (5,5) (5,5)

1 2 5 5
\endcode
@see http://cvmlib.com/faq.htm
@see basic_cvector::basic_cvector(TC*,tint,tint)
@param[in] pd Pointer to an array to share memory with.
@param[in] nM Number of rows.
@param[in] nN Number of columns.
*/
    basic_cmatrix(TC* pd, tint nM, tint nN)
      : BaseMatrix(pd, nM, nN, nM, nM * nN)
    {}

/**
@brief Constructor

Creates \f$m\times n\f$ \ref cmatrix object where \f$m\f$ is passed in
\c nM parameter (number of rows) and \f$n\f$ is passed in \c nN (number of columns).
Constructor throws \ref cvmexception in case of non-positive sizes passed.
This is const version,
it allocates memory and copies every element (deep copy) from external array pointed to by \c pd parameter.
It copies \c nM*nN elements total.
\par Example:
\code
using namespace cvm;
const double a[] = {5., 5., 5., 5., 5., 5.,
                    5., 5., 5., 5., 5., 5.};
cmatrix m((const std::complex<double>*) a, 2, 3);
m(1,1) = std::complex<double>(1.,2.);
std::cout << m << std::endl;
std::cout << a[0] << " " << a[1] << " "
          << a[2] << " " << a[3] << std::endl;
\endcode
prints
\code
(1,2) (5,5) (5,5)
(5,5) (5,5) (5,5)

5 5 5 5
\endcode
@see http://cvmlib.com/faq.htm
@see basic_cvector::basic_cvector(const TC*,tint,tint)
@param[in] pd Const pointer to external array.
@param[in] nM Number of rows.
@param[in] nN Number of columns.
*/
    basic_cmatrix(const TC* pd, tint nM, tint nN)
      : BaseMatrix(pd, nM, nN, nM, nM * nN)
    {}

/**
@brief Copy constructor

Creates \ref cmatrix object as a copy of a matrix \c m.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m((std::complex<double>*) a, 2, 3);
cmatrix mc(m);
m(1,1) = std::complex<double>(7.77,7.77);
std::cout << m << std::endl << mc;
\endcode
prints
\code
(7.77,7.77) (5,6) (9,10)
(3,4) (7,8) (11,12)

(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
\endcode
@param[in] m \ref rmatrix to copy from.
*/
    basic_cmatrix(const basic_cmatrix& m)
      : BaseMatrix(m.msize(), m.nsize(), m.msize(), false) {
        this->_massign(m);
    }

/**
@brief Move constructor

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to newly created object.
It's usually executed implicitly in cases like this:
\code
rvector a(b + c);
\endcode
or this
\code
rvector a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to newly created object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_cmatrix(basic_cmatrix&& m) noexcept
       : BaseMatrix(std::move(m))
    {}

/**
@brief Constructor

Creates \ref cmatrix object containing \c v.size() rows and
1 column if \c bBeColumn is \c true or 1 row and
\c v.size() columns otherwise.
After that it copies elements of a vector \c v to the matrix created.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
cvector v(3);
v(1) = std::complex<double>(1.,2.);
v(2) = std::complex<double>(2.,3.);
v(3) = std::complex<double>(3.,4.);
cmatrix mc(v);
cmatrix mr(v, false);
std::cout << mc << std::endl << mr;
\endcode
prints
\code
(1,2)
(2,3)
(3,4)

(1,2) (2,3) (3,4)
\endcode
@param[in] v \ref cvector to copy elements from.
@param[in] bBeColumn True to create column matrix.
*/
    explicit basic_cmatrix(const CVector& v, bool bBeColumn = true)
      : BaseMatrix(v, bBeColumn)
    {}

/**
@brief Constructor

Creates \ref cmatrix object with \c m.msize() rows and \c m.nsize() columns
and copies matrix \c m to its real part if \c bRealPart is \c true or to its imaginary part otherwise.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.};
const rmatrix m(a, 2, 3);
cmatrix mr(m), mi(m, false);
std::cout << mr << std::endl << mi;
\endcode
prints
\code
(1,0) (3,0) (5,0)
(2,0) (4,0) (6,0)

(0,1) (0,3) (0,5)
(0,2) (0,4) (0,6)
\endcode
@param[in] m \ref rmatrix to copy elements from.
@param[in] bRealPart \c true to copy \c m to real part, \c false to copy to imaginary part.
*/
    explicit basic_cmatrix(const basic_rmatrix<TR>& m, bool bRealPart = true)
      : BaseMatrix(m.msize(), m.nsize(), m.msize(), true) {
        if (bRealPart) {
            __copy2<TR,TC>(this->get(), this->size(), this->incr(), m._pd(), nullptr);
        }
        else {
            __copy2<TR,TC>(this->get(), this->size(), this->incr(), nullptr, m._pd());
        }
    }

/**
@brief Constructor

Creates \c cmatrix object of size \c nM by \c nN and copies every
element of an arrays pointed to by \c pRe and \c pIm to real and imaginary part
of the matrix created respectively.
Use \c nullptr pointer to fill up appropriate part with zero values.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double re[] = {1., 2., 3., 4., 5., 6.};
double im[] = {6., 5., 4., 3., 2., 1.};
cmatrix m(re, im, 3, 2);
std::cout << m << std::endl;
re[1] = 7.77;
std::cout << m << std::endl;
const double re2[] = {1., 2., 3., 4.};
const cmatrix m2 (re2, nullptr, 2, 2);
std::cout << m2;
\endcode
prints
\code
(1,6) (4,3)
(2,5) (5,2)
(3,4) (6,1)

(1,6) (4,3)
(2,5) (5,2)
(3,4) (6,1)

(1,0) (3,0)
(2,0) (4,0)
\endcode
@param[in] pRe Const pointer to external \ref treal array to copy to real part.
@param[in] pIm Const pointer to external \ref treal array to copy to imaginary part.
@param[in] nM Number of rows.
@param[in] nN Number of columns.
*/
    basic_cmatrix(const TR* pRe, const TR* pIm, tint nM, tint nN)
      : BaseMatrix(nM, nN, nM, true) {
        __copy2<TR,TC>(this->get(), this->size(), this->incr(), pRe, pIm, 1, 1);
    }

/**
@brief Constructor

Creates \ref cmatrix object of size \c mRe.msize() by \c mRe.nsize()
(if one of these sizes differs from appropriate size of matrix
\c mIm then constructor throws \ref cvmexception)
and copies matrices \c mRe and \c mIm to real and imaginary part of the matrix created respectively.
Constructor also throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
rmatrix mr(3,3), mi(3,3);
mr(1,1) = 1.;
mr(2,2) = 2.;
mr(3,3) = 3.;
mi(1,3) = 6.;
mi(2,2) = 5.;
mi(3,1) = 4.;
const cmatrix mc(mr, mi);
std::cout << mc;
\endcode
prints
\code
(1,0) (0,0) (0,6)
(0,0) (2,5) (0,0)
(0,4) (0,0) (3,0)
\endcode
@param[in] mRe \ref rmatrix to copy to real part.
@param[in] mIm \ref rmatrix to copy to imaginary part.
*/
    basic_cmatrix(const basic_rmatrix<TR>& mRe, const basic_rmatrix<TR>& mIm)
      : BaseMatrix(mRe.msize(), mRe.nsize(), mRe.msize(), false) {
        _check_ne(CVM_SIZESMISMATCH, mRe.msize(), mIm.msize());
        _check_ne(CVM_SIZESMISMATCH, mRe.nsize(), mIm.nsize());
        _check_ne(CVM_SIZESMISMATCH, mRe.ld(), mIm.ld());
        __copy2<TR,TC>(this->get(), this->size(), this->incr(), mRe, mIm, mRe.incr(), mIm.incr());
    }

/**
@brief Submatrix constructor

Creates \ref cmatrix object as submatrix of a matrix \c m.
It means that the matrix object created shares memory with some part
of \c m. This part is defined by its upper left corner and its height and width (parameters
\c nHeight and \c nWidth).
\par Example:
\code
using namespace cvm;
cmatrix m(4,5);
cmatrix subm(m, 2, 2, 2, 2);
subm.set(std::complex<double>(1.,1.));
std::cout << m;
\endcode
prints
\code
(0,0) (0,0) (0,0) (0,0) (0,0)
(0,0) (1,1) (1,1) (0,0) (0,0)
(0,0) (1,1) (1,1) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0) (0,0)
\endcode
@param[in] m Parent \ref cmatrix to attach to.
@param[in] nRow Row to start from.
@param[in] nCol Column to start from.
@param[in] nHeight Number of submatrix's rows.
@param[in] nWidth Number of submatrix's columns.
*/
    basic_cmatrix(basic_cmatrix& m, tint nRow, tint nCol, tint nHeight, tint nWidth)
      : BaseMatrix(m._sub_pointer(nRow, nCol, nHeight, nWidth),
                   nHeight, nWidth, m.ld(), nHeight * nWidth) {
        m._check_submatrix();
    }

// TODO dox, test
#if defined(CVM_USE_INITIALIZER_LISTS)
    basic_cmatrix(tint nM, tint nN, const std::initializer_list<TR>& list)
      : BaseMatrix(nM, nN, nM, false) {
        _check_ne(CVM_SIZESMISMATCH, this->size() * tint(2), static_cast<tint>(list.size()));
        tint i = 0;
#ifdef CVM_USE_POOL_MANAGER
        TC* p = this->mpd;
#else
        TC* p = this->mp.get();
#endif
        for (auto it = list.begin(); it != list.end(); ++it, ++it) {
            p[i++] = TC(*it,*(it+1));
        }
    }
#endif



/**
@brief Reference to element (l-value)

Operator provides access to a particular element of a calling matrix by its row and column index.
It returns \e l-value in order to make possible write access to an element.
Operator throws \ref cvmexception if \c nRow or \c nCol is out of boundaries.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    const cmatrix m((std::complex<double>*) a, 2, 3);
    scmatrix ms(2);
    std::cout << m(1,1) << " "
              << m(2,3) << std::endl << std::endl;
    ms(2,2) = std::complex<double>(7.77,7.77);
    std::cout << ms;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1,2) (11,12)

(0,0) (0,0)
(0,0) (7.77,7.77)
\endcode
@see http://cvmlib.com/faq.htm
@param[in] nRow Row index.
@param[in] nCol Column index.
@return \ref type_proxy Proxy to element (l-value).
*/
    type_proxy<TC,TR> operator () (tint nRow, tint nCol) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, nRow, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, nCol, tint(), this->nsize());
        return this->_ij_proxy_val(nRow, nCol);
    }

/**
@brief Value of element (\e not l-value)

Operator returns value of a particular element of a calling matrix by its row and column index.
Operator throws \ref cvmexception if \c nRow or \c nCol is out of boundaries.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    const cmatrix m((std::complex<double>*) a, 2, 3);
    std::cout << m(1,1) << " " << m(2,3) << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1,2) (11,12)
\endcode
@see http://cvmlib.com/faq.htm
@param[in] nRow Row index.
@param[in] nCol Column index.
@return TC \ref tcomplex value.
*/
    TC operator () (tint nRow, tint nCol) const {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, nRow, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, nCol, tint(), this->nsize());
        return this->_ij_val(nRow, nCol);
    }

/**
@brief Column as l-value

Operator provides access to \c nCol-th column of a calling matrix by returning
\ref cvector <b>sharing memory</b> with it.
Operator throws \ref cvmexception if \c nCol is out of boundaries.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    const cmatrix m((std::complex<double>*) a, 2, 3);
    scmatrix ms(2);

    std::cout << m(2) << std::endl;

    ms(2) = m(3);
    std::cout << ms;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(5,6) (7,8)

(0,0) (9,10)
(0,0) (11,12)
\endcode
@param[in] nCol Index of column.
@return \ref cvector Column as l-value.
*/
    CVector operator () (tint nCol) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nCol, tint(), this->nsize());
        return this->_col(nCol);
    }

/**
@brief Row as l-value

Operator provides access to \c nRow-th row of a calling matrix by returning
\ref cvector <b>sharing memory</b> with it.
Operator throws \ref cvmexception if \c nRow is out of boundaries.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    const srmatrix m(a, 3);
    srmatrix ms(3);
    std::cout << m[2] << std::endl;
    ms[2] = m[3];
    std::cout << ms;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
2.00e+00 5.00e+00 8.00e+00

0.00e+00 0.00e+00 0.00e+00
3.00e+00 6.00e+00 9.00e+00
0.00e+00 0.00e+00 0.00e+00
\endcode
@param[in] nRow Index of row.
@return \ref cvector Row as l-value.
*/
    CVector operator [] (tint nRow) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nRow, tint(), this->msize());
        return this->_row(nRow);
    }

/**
@brief Column as \em not l-value

Operator creates \ref cvector object as a copy of \c nCol-th column of a calling matrix.
Operator throws \ref cvmexception if \c nCol is out of boundaries.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    const cmatrix m((std::complex<double>*) a, 2, 3);
    std::cout << m(2) << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(5,6) (7,8)
\endcode
@param[in] nCol Index of column.
@return \ref cvector Column value.
*/
    CVector operator () (tint nCol) const {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nCol, tint(), this->nsize());
        return this->_col(nCol);
    }

/**
@brief Row as \em not l-value

Operator creates \ref cvector object as a copy of \c nRow-th row of a calling matrix.
Operator throws \ref cvmexception if \c nRow is out of boundaries.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    const srmatrix m(a, 3);
    std::cout << m[2] << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
2.00e+00 5.00e+00 8.00e+00
\endcode
@param[in] nRow Index of row.
@return \ref cvector Row value.
*/
    CVector operator [] (tint nRow) const {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nRow, tint(), this->msize());
        return this->_row(nRow);
    }

/**
@brief Diagonal as l-value

Operator provides access
to \c nDiag-th diagonal of a calling matrix
(here \c nDiag=0 for main diagonal, \c nDiag<0 for lower diagonals
and \c nDiag>0 for upper ones) by returning \ref cvector <b>sharing memory</b>
with it.
Operator throws \ref cvmexception if \c nDiag is out of boundaries.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
                  10., 11., 12., 13., 14., 15., 16., 17., 18.};
    cmatrix m(2, 3);
    const scmatrix ms((std::complex<double>*)a, 3);
    m.diag(-1).set(std::complex<double>(1.,1.));
    m.diag(0).set(std::complex<double>(2.,2.));
    m.diag(1).set(std::complex<double>(3.,3.));
    m.diag(2).set(std::complex<double>(4.,4.));
    std::cout << m << std::endl;
    std::cout << ms << std::endl;
    std::cout << ms.diag(0) << ms.diag(1);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(2,2) (3,3) (4,4)
(1,1) (2,2) (3,3)

(1,2) (7,8) (13,14)
(3,4) (9,10) (15,16)
(5,6) (11,12) (17,18)

(1,2) (9,10) (17,18)
(7,8) (15,16)
\endcode
@param[in] nDiag Index of diagonal (0 for main diagonal, negative for lower, positive for upper one).
@return \ref cvector Diagonal as l-value.
*/
    CVector diag(tint nDiag) {
        return this->_diag(nDiag);
    }

/**
@brief Diagonal (\em not l-value)

Operator creates \ref cvector object as a copy of \c nDiag-th diagonal of a calling matrix
where \c nDiag=0 for main diagonal, \c nDiag<0 for lower diagonals
and \c nDiag>0 for upper ones.
Operator throws \ref cvmexception if \c nDiag is out of boundaries.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
                  10., 11., 12., 13., 14., 15., 16., 17., 18.};
    const scmatrix ms((std::complex<double>*)a, 3);
    std::cout << ms << std::endl;
    std::cout << ms.diag(0) << ms.diag(1);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1,2) (7,8) (13,14)
(3,4) (9,10) (15,16)
(5,6) (11,12) (17,18)

(1,2) (9,10) (17,18)
(7,8) (15,16)
\endcode
@param[in] nDiag Index of diagonal (0 for main diagonal, negative for lower, positive for upper one).
@return \ref cvector Diagonal value.
*/
    [[nodiscard]] CVector diag(tint nDiag) const {
        return this->_diag(nDiag);
    }

/**
@brief Real part (\em not l-value)

Creates an object of type \c const \ref rmatrix as real part of a calling matrix.
Please note that, unlike \ref cvector::real(), this function 
creates a new object not sharing memory with real part of a 
calling matrix, i.e. the matrix returned is not l-value. 
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m((std::complex<double>*) a, 2, 3);
std::cout << m << std::endl << m.real();
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

1 5 9
3 7 11
\endcode
@return Result object.
*/
    [[nodiscard]] basic_rmatrix<TR> real() const {
        basic_rmatrix<TR> mRet(this->msize(), this->nsize());
        __copy<TR>(this->size(), __get_real_p<TR>(this->get()),
                   this->incr() * 2, mRet, mRet.incr());
        return mRet;
    }

/**
@brief Imaginary part (\em not l-value)

Creates an object of type \c const \ref rmatrix as imaginary part of a calling matrix.
Please note that, unlike cvector::imag(), this function creates new object not sharing memory
with imaginary part of a calling matrix, i.e. the matrix returned is not l-value.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m((std::complex<double>*) a, 2, 3);
std::cout << m << std::endl << m.imag();
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

2 6 10
4 8 12
\endcode
@return Result object.
*/
    [[nodiscard]] basic_rmatrix<TR> imag() const {
        basic_rmatrix<TR> mRet(this->msize(), this->nsize());
        __copy<TR>(this->size(), __get_imag_p<TR>(this->get()),
                   this->incr() * 2, mRet, mRet.incr());
        return mRet;
    }

/**
@brief Assignment operator

Sets every element of a calling \ref cmatrix to be equal to
appropriate element of a matrix \c m and returns a reference to
the matrix changed.
Operator throws \ref cvmexception in case of different matrix dimensions.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    const cmatrix m1((std::complex<double>*) a, 2, 3);
    cmatrix m2(2, 3);
    m2 = m1;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
\endcode
@param[in] m \ref cmatrix to assign from.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& operator = (const basic_cmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.nsize());
        this->_massign(m);
        return *this;
    }

/**
@brief Move assignment operator

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to a calling object.
It's usually executed implicitly in cases like this:
\code
a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to a calling object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_cmatrix& operator = (basic_cmatrix&& m) noexcept {
        // size check is in BaseMatrix
        BaseMatrix::operator = (std::move(m));
        return *this;
    }

/**
@brief Vector (as array) assignment

Sets every element of a calling matrix to be equal to appropriate element of \ref cvector \c v as an array.
Assignment is performed according to a matrix storage (by columns). It's assumed that vector passed is long
enough to fill calling matrix. Function throws \ref cvmexception otherwise.
\par Example:
\code
using namespace cvm;
const double a[] = {1., 2., 3., 4., 5., 6.,
                    7., 8., 9., 10., 11., 12.};
const cvector v((const std::complex<double>*) a,6);
cmatrix m(2, 3);
m.assign(v);
std::cout << m;
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
\endcode
@param[in] v \ref cvector to assign.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& assign(const CVector& v) {
        _check_ne(CVM_SIZESMISMATCH, this->size(), v.size());
        this->_assign(v, v.incr());
        return *this;
    }

/**
@brief External array assignment

Sets every element of a calling matrix to be equal to
appropriate element of an array pointed to by parameter \c pd
and returns a reference to the matrix changed.
Assignment is performed according to a matrix storage (by columns).
It's assumed that array passed is long enough to fill calling matrix.
\par Example:
\code
using namespace cvm;
const double a[] = {1., 2., 3., 4., 5., 6.,
                    7., 8., 9., 10., 11., 12.};
cmatrix m(2, 3);
m.assign((const std::complex<double>*) a);
std::cout << m;
\endcode
prints
\code
1.00e+000 3.00e+000 5.00e+000
2.00e+000 4.00e+000 6.00e+000
\endcode
@param[in] pd Const pointer to external array.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& assign(const TC* pd) {
        this->_assign(pd, 1);
        return *this;
    }

/**
@brief Assignment to submatrix

Sets submatrix of a calling matrix beginning with row
\c nRow and column \c nCol to a matrix \c m and
returns a reference to the matrix changed. Function throws
\ref cvmexception if \c nRow or \c nCol are not positive or matrix \c m doesn't fit.
\par Example:
\code
using namespace cvm;
rmatrix m1(4,5);
rmatrix m2(2,2);
m1.set(1.);
m2.set(2.);
m1.assign(2,3,m2);
std::cout << m1;
\endcode
prints
\code
(1,1) (1,1) (1,1) (1,1) (1,1)
(1,1) (1,1) (2,2) (2,2) (1,1)
(1,1) (1,1) (2,2) (2,2) (1,1)
(1,1) (1,1) (1,1) (1,1) (1,1)
\endcode
@param[in] nRow Row index.
@param[in] nCol Column index.
@param[in] m Reference to a matrix to assign.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& assign(tint nRow, tint nCol, const basic_cmatrix& m) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, nRow, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, nCol, tint(), this->nsize());
        _check_gt(CVM_SIZESMISMATCH_GT, m.msize() + nRow, this->msize());
        _check_gt(CVM_SIZESMISMATCH_GT, m.nsize() + nCol, this->nsize());
        this->_assign_shifted(this->_sub_pointer_nocheck(nRow, nCol), m._pd(),
                              m.msize(), m.nsize(), m.ld());
        return *this;
    }

/**
@brief Sets all elements to one value

Sets every element of a calling matrix to be equal to
parameter \c c and returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
cmatrix m(3, 4);
m.set(std::complex<double>(3.,4.));
std::cout << m;
\endcode
prints
\code
(3,4) (3,4) (3,4) (3,4)
(3,4) (3,4) (3,4) (3,4)
(3,4) (3,4) (3,4) (3,4)
\endcode
@param[in] c Value to set to.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& set(TC c) {
        this->_set(c);
        return *this;
    }

/**
@brief Assignment to real parts

Sets real part of every element of a calling matrix to a value of
appropriate element of \ref rmatrix \c mRe and returns a reference to
the matrix changed. Function throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix m(2,3);
cmatrix mc(2,3);
m.randomize(0., 1.);
mc.assign_real(m);
std::cout << mc;
\endcode
prints
\code
(0.126835,0) (0.57271,0) (0.28312,0)
(0.784417,0) (0.541673,0) (0.663869,0)
\endcode
@param[in] mRe \ref rmatrix to assign to real part.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& assign_real(const basic_rmatrix<TR>& mRe) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mRe.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mRe.nsize());
        __copy_real<TR,TC>(this->get(), this->size(), this->incr(), mRe._pd(), mRe.incr());
        return *this;
    }

/**
@brief Assignment to imaginary parts

Sets imaginary part of every element of a calling matrix to a value of
appropriate element of \ref rmatrix \c mIm and returns a reference to
the matrix changed. Function throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
rmatrix m(2,3);
cmatrix mc(2,3);
m.randomize(0., 1.);
mc.assign_imag(m);
std::cout << mc;
\endcode
prints
\code
(0,0.13831) (0,0.267373) (0,0.482345)
(0,0.50618) (0,0.992401) (0,0.444777)
\endcode
@param[in] mIm \ref rmatrix to assign to imaginary part.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& assign_imag(const basic_rmatrix<TR>& mIm) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mIm.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mIm.nsize());
        __copy_imag<TR,TC>(this->get(), this->size(), this->incr(), mIm._pd(), mIm.incr());
        return *this;
    }

/**
@brief Sets all real parts to one value

Sets real part of every element of a calling matrix to be equal to
parameter \c d and returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
cmatrix m(2,3);
m.set_real(1.);
std::cout << m;
\endcode
prints
\code
(1,0) (1,0) (1,0)
(1,0) (1,0) (1,0)
\endcode
@param[in] d Value to set to.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& set_real(TR d) {
        this->_set_real_number(d);
        return *this;
    }

/**
@brief Sets all imaginary parts to one value

Sets imaginary part of every element of a calling matrix to be equal to
parameter \c d and returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
cmatrix m(2,3);
m.set_imag(1.);
std::cout << m;
\endcode
prints
\code
(0,1) (0,1) (0,1)
(0,1) (0,1) (0,1)
\endcode
@param[in] d Value to set to.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& set_imag(TR d) {
        this->_set_imag_number(d);
        return *this;
    }

/**
@brief Changes dimensions

Changes dimensions of a calling matrix to to \c nNewM by \c nNewN
and returns a reference to the matrix changed.
In case of increasing of its size, the matrix
is filled up with zeroes.
Function throws \ref cvmexception
in case of negative dimension passed or memory allocation failure.
 \par Example:
 \code
 using namespace cvm;
 try {
     double a[] = {1., 2., 3., 4., 5., 6.,
                   7., 8., 9., 10., 11., 12.};
     cmatrix m((std::complex<double>*) a, 2, 3);
     std::cout << m << std::endl;
     m.resize(2, 2);
     std::cout << m << std::endl;
     m.resize(3, 3);
     std::cout << m;
 }
 catch (std::exception& e) {
     std::cout << "Exception " << e.what() << std::endl;
 }
 \endcode
 prints
 \code
 (1,2) (5,6) (9,10)
 (3,4) (7,8) (11,12)

 (1,2) (5,6)
 (3,4) (7,8)

 (1,2) (5,6) (0,0)
 (3,4) (7,8) (0,0)
 (0,0) (0,0) (0,0)
 \endcode
@param[in] nNewM New number of rows.
@param[in] nNewN New number of columns.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& resize(tint nNewM, tint nNewN) {
        this->_resize2(nNewM, nNewN);
        return *this;
    }

/**
@brief Matrix comparison

Operator compares calling matrix with a matrix \c m
and returns \c true if they have same sizes
and their appropriate elements differ by not more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;
cmatrix m1(2, 3);
cmatrix m2(2, 3);
m1.set_real(1.);
m2.set_real(1.);
std::cout << (m1 == m2) << std::endl;
\endcode
prints
\code
1
\endcode
@see operator !=()
@param[in] m \ref cmatrix to compare to.
@return bool Result of comparison.
*/
    bool operator == (const basic_cmatrix& m) const {
        return this->msize() == m.msize() && this->nsize() == m.nsize() && this->_mequals(m);
    }

/**
@brief Matrix comparison

Operator compares calling matrix with a matrix \c m
and returns \c true if they have different sizes
or at least one of their appropriate elements differs by more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;
cmatrix m1(2, 3);
cmatrix m2(2, 3);
m1.set_real(1.);
m2.set_real(1.);
std::cout << (m1 != m2) << std::endl;
\endcode
prints
\code
0
\endcode
@see operator ==()
@param[in] m \ref cmatrix to compare to.
@return bool Result of comparison.
*/
    bool operator != (const basic_cmatrix& m) const {
        return !operator == (m);
    }

/**
@brief Matrix replacement

Destroys calling matrix, creates a new one as a copy of \c m
and returns a reference to the matrix changed. Operator throws \ref cvmexception
in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    cmatrix m(2,3);
    cmatrix mc(1,1);
    m(1,2) = std::complex<double>(1.,2.);
    m(2,3) = std::complex<double>(2.,4.);
    std::cout << m << mc << std::endl;
    mc << m;
    std::cout << mc;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(0,0) (1,2) (0,0)
(0,0) (0,0) (2,4)
(0,0)

(0,0) (1,2) (0,0)
(0,0) (0,0) (2,4)
\endcode
@see operator =()
@param[in] m \ref cmatrix to replace by.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& operator << (const basic_cmatrix& m) {
        this->_replace(m);
        this->_massign(m);
        return *this;
    }

/**
@brief Addition operator

Creates an object of type \ref cmatrix as a sum of
a calling matrix and a matrix \c m.
Operator throws \ref cvmexception
in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    const cmatrix ma((std::complex<double>*) a, 2, 3);
    cmatrix mb(2, 3);
    mb.set(std::complex<double>(1.,1.));
    std::cout << ma + mb << std::endl;
    std::cout << ma + ma;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(2,3) (6,7) (10,11)
(4,5) (8,9) (12,13)

(2,4) (10,12) (18,20)
(6,8) (14,16) (22,24)
\endcode
@see sum()
@param[in] m \ref cmatrix to add to a calling one.
@return Result object as a sum of matrices.
*/
    basic_cmatrix operator + (const basic_cmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.nsize());
        basic_cmatrix mSum(*this);
        mSum._mincr(m);
        return mSum;
    }

/**
@brief Subtraction operator

Creates an object of type \ref cmatrix as a difference of
a calling matrix and a matrix \c m.
It throws \ref cvmexception in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    const cmatrix ma((std::complex<double>*) a, 2, 3);
    cmatrix mb(2, 3);
    mb.set(std::complex<double>(1.,1.));
    std::cout << ma - mb << std::endl;
    std::cout << ma - ma;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(0,1) (4,5) (8,9)
(2,3) (6,7) (10,11)

(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
@see diff()
@param[in] m \ref cmatrix to subtract from calling one.
@return Result object as a difference of matrices.
*/
    basic_cmatrix operator - (const basic_cmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.nsize());
        basic_cmatrix mDiff(*this);
        mDiff._mdecr(m);
        return mDiff;
    }

/**
@brief Sum of matrices

Assigns sum of
matrices \c m1 and \c m2 to a calling matrix
and returns a reference to the matrices changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    const cmatrix ma((std::complex<double>*) a, 2, 3);
    cmatrix mb(2, 3);
    cmatrix m(2, 3);
    mb.set(std::complex<double>(1.,1.));
    std::cout << m.sum(ma, mb) << std::endl;
    std::cout << m.sum(m, mb);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(2,3) (6,7) (10,11)
(4,5) (8,9) (12,13)

(3,4) (7,8) (11,12)
(5,6) (9,10) (13,14)
\endcode
@see operator +()
@param[in] m1 First \ref cmatrix summand.
@param[in] m2 Second \ref cmatrix summand.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& sum(const basic_cmatrix& m1,
                       const basic_cmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m1.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m2.nsize());
        this->_msum(m1, m2);
        return *this;
    }

/**
@brief Difference of matrices

Assigns difference of
matrices \c m1 and \c m2 to a calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    const cmatrix ma((std::complex<double>*) a, 2, 3);
    cmatrix mb(2, 3);
    cmatrix m(2, 3);
    mb.set(std::complex<double>(1.,1.));
    std::cout << m.diff(ma, mb) << std::endl;
    std::cout << m.diff(m, mb);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(0,1) (4,5) (8,9)
(2,3) (6,7) (10,11)

(-1,0) (3,4) (7,8)
(1,2) (5,6) (9,10)
\endcode
@see operator -()
@param[in] m1 First \ref cmatrix subtrahend.
@param[in] m2 Second \ref cmatrix subtrahend.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& diff(const basic_cmatrix& m1,
                        const basic_cmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m1.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m2.nsize());
        this->_mdiff(m1, m2);
        return *this;
    }

/**
@brief Increment operator

Adds matrix \c m to a calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    cmatrix m1(2, 3);
    cmatrix m2(2, 3);
    m1.set(std::complex<double>(1.,1.));
    m2.set(std::complex<double>(2.,2.));
    m1 += m2;
    std::cout << m1 << std::endl;
    // well, you can do this too, but temporary object would be created
    m2 += m2;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(3,3) (3,3) (3,3)
(3,3) (3,3) (3,3)

(4,4) (4,4) (4,4)
(4,4) (4,4) (4,4)
\endcode
@see operator +()
@see sum()
@param[in] m \ref cmatrix to increment by.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& operator += (const basic_cmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.nsize());
        this->_mincr(m);
        return *this;
    }

/**
@brief Decrement operator

Subtracts matrix \c m from calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    cmatrix m1(2, 3);
    cmatrix m2(2, 3);
    m1.set(std::complex<double>(1.,1.));
    m2.set(std::complex<double>(2.,2.));
    m1 -= m2;
    std::cout << m1 << std::endl;
    // well, you can do this too, but temporary object would be created
    m2 -= m2;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-1,-1) (-1,-1) (-1,-1)
(-1,-1) (-1,-1) (-1,-1)

(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
@see operator -()
@see diff()
@param[in] m \ref cmatrix to decrement by.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& operator -= (const basic_cmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.nsize());
        this->_mdecr(m);
        return *this;
    }

/**
@brief Unary minus operator

Creates an object of type \ref cmatrix as
a calling matrix multiplied by \c -1.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
const cmatrix ma ((std::complex<double>*) a, 2, 3);
std::cout << - ma;
\endcode
prints
\code
(-1,-2) (-5,-6) (-9,-10)
(-3,-4) (-7,-8) (-11,-12)
\endcode
@return Result object.
*/
    basic_cmatrix operator - () const {
        const TR mone(-1.);
        basic_cmatrix mRes(*this);
        mRes._scalr(mone);
        return mRes;
    }

/**
@brief Multiply by real number operator

Creates an object of type \ref cmatrix as a product of
a calling matrix and real number \c dMult.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
const cmatrix ma ((std::complex<double>*) a, 2, 3);
std::cout << ma * 5.;
\endcode
prints
\code
(5,10) (25,30) (45,50)
(15,20) (35,40) (55,60)
\endcode
@see operator *=()
@param[in] dMult Number to multiply by.
@return Result object.
*/
    basic_cmatrix operator * (TR dMult) const {
        basic_cmatrix mRes(*this);
        mRes._scalr(dMult);
        return mRes;
    }

/**
@brief Divide by real number operator

Creates an object of type \ref cmatrix as a quotient of
a calling matrix and real number \c dDiv.
It throws \ref cvmexception if \c dDiv has absolute value equal or less
than \ref cvmMachMin() (the smallest normalized positive number).
It also throws exception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    const cmatrix ma((std::complex<double>*) a, 2, 3);
    std::cout << ma / 4.;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(0.25,0.5) (1.25,1.5) (2.25,2.5)
(0.75,1) (1.75,2) (2.75,3)
\endcode
@see operator /=()
@param[in] dDiv Number to divide by.
@return Result object.
*/
    basic_cmatrix operator / (TR dDiv) const {
        basic_cmatrix mRes(*this);
        mRes._div(dDiv);
        return mRes;
    }

/**
@brief Multiply by complex number operator

Creates an object of type \ref cmatrix as a product of
a calling matrix and complex number \c cMult.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
const cmatrix ma ((std::complex<double>*) a, 2, 3);
std::cout << ma * std::complex<double>(5.,2.);
\endcode
prints
\code
(1,12) (13,40) (25,68)
(7,26) (19,54) (31,82)
\endcode
@see operator *=()
@param[in] cMult Number to multiply by.
@return Result object.
*/
    basic_cmatrix operator * (TC cMult) const {
        basic_cmatrix mRes(*this);
        mRes._scalc(cMult);
        return mRes;
    }

/**
@brief Divide by complex number operator

Creates an object of type \ref cmatrix as a quotient of
a calling matrix and complex number \c cDiv.
It throws \ref cvmexception if \c cDiv has absolute value equal or less
than \ref cvmMachMin() (the smallest normalized positive number).
It also throws exception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    const cmatrix ma((std::complex<double>*) a, 2, 3);
    std::cout << ma / std::complex<double>(4.,2.);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(0.4,0.3) (1.6,0.7) (2.8,1.1)
(1,0.5) (2.2,0.9) (3.4,1.3)
\endcode
@see operator /=()
@param[in] cDiv Number to divide by.
@return Result object.
*/
    basic_cmatrix operator / (TC cDiv) const {
        basic_cmatrix mRes(*this);
        mRes._div(cDiv);
        return mRes;
    }

/**
@brief Multiply by real number and assign

Multiplies calling matrix by real number \c dMult and returns a reference to
the matrix changed.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix ma ((std::complex<double>*) a, 2, 3);
ma *= 2.;
std::cout << ma;
\endcode
prints
\code
(2,4) (10,12) (18,20)
(6,8) (14,16) (22,24)
\endcode
@see operator *(TR) const
@param[in] dMult Number to multiply by.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& operator *= (TR dMult) {
        this->_scalr(dMult);
        return *this;
    }

/**
@brief Divide by real number and assign

Divides calling matrix by real number \c dDiv and returns a reference to
the matrix changed. It throws \ref cvmexception if \c dDiv
has absolute value equal or less than \ref cvmMachMin() (the
smallest normalized positive number).
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    cmatrix ma((std::complex<double>*) a, 2, 3);
    ma /= 2.;
    std::cout << ma;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(0.5,1) (2.5,3) (4.5,5)
(1.5,2) (3.5,4) (5.5,6)
\endcode
@see operator /(TR) const
@param[in] dDiv Number to divide by.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& operator /= (TR dDiv) {
        this->_div(dDiv);
        return *this;
    }

/**
@brief Multiply by complex number and assign

Multiplies calling matrix by complex number \c cMult and returns a reference to
the matrix changed.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix ma ((std::complex<double>*) a, 2, 3);
ma *= std::complex<double>(2.,1.);
std::cout << ma;
\endcode
prints
\code
(0,5) (4,17) (8,29)
(2,11) (6,23) (10,35)
\endcode
@see operator *(TR) const
@param[in] cMult Number to multiply by.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& operator *= (TC cMult) {
        this->_scalc(cMult);
        return *this;
    }

/**
@brief Divide by complex number and assign

Divides calling matrix by complex number \c cDiv and returns a reference to
the matrix changed. It throws \ref cvmexception if \c cDiv
has absolute value equal or less than \ref cvmMachMin() (the
smallest normalized positive number).
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.,
                  7., 8., 9., 10., 11., 12.};
    cmatrix ma((std::complex<double>*) a, 2, 3);
    ma /= std::complex<double>(2.,1.);
    std::cout << ma;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(0.8,0.6) (3.2,1.4) (5.6,2.2)
(2,1) (4.4,1.8) (6.8,2.6)
\endcode
@see operator /(TR) const
@param[in] cDiv Number to divide by.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& operator /= (TC cDiv) {
        this->_div(cDiv);
        return *this;
    }

/**
@brief Matrix normalizer

Normalizes calling matrix so its Euclidean \ref norm()
becomes equal to 1 if it was greater than \ref cvmMachMin() (the
smallest normalized positive number) before the call.
Does nothing otherwise.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix ma ((std::complex<double>*) a, 2, 3);
ma.normalize();
std::cout << ma << ma.norm() << std::endl;
\endcode
prints
\code
(0.0392232,0.0784465) (0.196116,0.235339) (0.353009,0.392232)
(0.11767,0.156893) (0.274563,0.313786) (0.431455,0.470679)
1
\endcode
@return Reference to changed calling matrix.
*/
    basic_cmatrix& normalize() {
        this->_normalize();
        return *this;
    }

/**
@brief Matrix transposition

Creates an object of type \c cmatrix as transposed calling matrix.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m((std::complex<double>*) a, 2, 3);
cmatrix mc(3,2);
std::cout << m << std::endl << !m << std::endl ;
mc.transpose(m);
std::cout << mc << std::endl;
mc.transpose();
std::cout << mc;
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

(1,2) (3,4)
(5,6) (7,8)
(9,10) (11,12)

(1,2) (3,4)
(5,6) (7,8)
(9,10) (11,12)

(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
\endcode
@return Result object.
*/
    basic_cmatrix operator ! () const {
        basic_cmatrix mRes(this->nsize(), this->msize());
        mRes._transp_m(*this);
        return mRes;
    }

/**
@brief Matrix conjugation

Creates an object of type \c cmatrix as Hermitian conjugated calling matrix.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m((std::complex<double>*) a, 2, 3);
cmatrix mc(3,2);
std::cout << m << std::endl << ~m << std::endl ;
mc.conj(m);
std::cout << mc << std::endl;
mc.conj();
std::cout << mc;
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

(1,-2) (3,-4)
(5,-6) (7,-8)
(9,-10) (11,-12)

(1,-2) (3,-4)
(5,-6) (7,-8)
(9,-10) (11,-12)

(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
\endcode
@return Result object.
*/
    basic_cmatrix operator ~ () const {
        basic_cmatrix mRes(this->nsize(), this->msize());
        mRes._transp_m(*this);
        __conj<TC>(mRes.get(), mRes.size(), mRes.incr());
        return mRes;
    }

/**
@brief Matrix transposition

Sets calling matrix to be equal to a matrix \c m transposed.
Function throws \ref cvmexception in case of not appropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m((std::complex<double>*) a, 2, 3);
cmatrix mc(3,2);
std::cout << m << std::endl << !m << std::endl ;
mc.transpose(m);
std::cout << mc << std::endl;
mc.transpose();
std::cout << mc;
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

(1,2) (3,4)
(5,6) (7,8)
(9,10) (11,12)

(1,2) (3,4)
(5,6) (7,8)
(9,10) (11,12)

(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
\endcode
@param[in] m \ref cmatrix to transpose.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& transpose(const basic_cmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.msize());
        if (this->get() == m.get()) {
            basic_cmatrix mTmp(m);
            this->_transp_m(mTmp);
        } else {
            this->_transp_m(m);
        }
        return *this;
    }

/**
@brief Matrix conjugation

Sets calling matrix to be equal to a matrix \c m conjugated.
Function throws \ref cvmexception in case of not appropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m((std::complex<double>*) a, 2, 3);
cmatrix mc(3,2);
std::cout << m << std::endl << ~m << std::endl ;
mc.conj(m);
std::cout << mc << std::endl;
mc.conj();
std::cout << mc;
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

(1,-2) (3,-4)
(5,-6) (7,-8)
(9,-10) (11,-12)

(1,-2) (3,-4)
(5,-6) (7,-8)
(9,-10) (11,-12)

(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
\endcode
@param[in] m \ref cmatrix to conjugate.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& conj(const basic_cmatrix& m) {
        this->transpose(m);
        __conj<TC>(this->get(), this->size(), this->incr());
        return *this;
    }

/**
@brief Matrix transposition (in-place)

Makes calling matrix to be equal to transposed itself.
Function throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m((std::complex<double>*) a, 2, 3);
cmatrix mc(3,2);
std::cout << m << std::endl << !m << std::endl ;
mc.transpose(m);
std::cout << mc << std::endl;
mc.transpose();
std::cout << mc;
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

(1,2) (3,4)
(5,6) (7,8)
(9,10) (11,12)

(1,2) (3,4)
(5,6) (7,8)
(9,10) (11,12)

(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
\endcode
@return Reference to changed calling matrix.
*/
    basic_cmatrix& transpose() {
        basic_cmatrix mTmp(*this);
        this->_resize2(this->nsize(), this->msize());
        this->_transp_m(mTmp);
        return *this;
    }

/**
@brief Matrix conjugation (in-place)

Makes calling matrix to be equal to conjugated itself.
Function throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m((std::complex<double>*) a, 2, 3);
cmatrix mc(3,2);
std::cout << m << std::endl << ~m << std::endl ;
mc.conj(m);
std::cout << mc << std::endl;
mc.conj();
std::cout << mc;
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

(1,-2) (3,-4)
(5,-6) (7,-8)
(9,-10) (11,-12)

(1,-2) (3,-4)
(5,-6) (7,-8)
(9,-10) (11,-12)

(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
\endcode
@return Reference to changed calling matrix.
*/
    basic_cmatrix& conj() {
        this->transpose();
        __conj<TC>(this->get(), this->size(), this->incr());
        return *this;
    }

/**
@brief Matrix-vector product

Creates an object of type \ref cvector as a product of a calling matrix and a vector \c v.
Function throws \ref cvmexception if the number of columns of the calling matrix
differs from size of the vector \c v.
Use \ref basic_cvector::mult(const basic_cmatrix<TR,TC>&,const basic_cvector<TR,TC>&)
to avoid new object creation.
\par Example:
\code
using namespace cvm;
cmatrix m(2, 3);
cvector v(3);
m.set(std::complex<double>(1.,1.));
v.set(std::complex<double>(1.,1.));
std::cout << m * v;
\endcode
prints
\code
(0,6) (0,6)
\endcode
@see basic_cvector::mult(const basic_cmatrix<TR,TC>&,const basic_cvector<TR,TC>&)
@param[in] v \ref cvector to compute product with.
@return Result object.
*/
    CVector operator * (const CVector& v) const {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), v.size());
        CVector vRes(this->msize());
        this->_multiply(vRes, v, false);
        return vRes;
    }

/**
@brief Matrix-matrix product

Creates an object of type \ref cmatrix as a product of a calling matrix and a matrix \c m.
Operator throws \ref cvmexception if number of columns of a calling matrix
differs from number of rows of the matrix \c m.
Use \ref mult() to avoid new object creation.
\par Example:
\code
using namespace cvm;
cmatrix m1(2, 3);
cmatrix m2(3, 2);
m1.set(std::complex<double>(1.,1.));
m2.set(std::complex<double>(1.,1.));
std::cout << m1 * m2;
\endcode
prints
\code
(0,6) (0,6)
(0,6) (0,6)
\endcode
@param[in] m \ref cmatrix to compute product with.
@return Result object.
*/
    basic_cmatrix operator * (const basic_cmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.msize());
        basic_cmatrix mRes(this->msize(), m.nsize());
        mRes.mult(*this, m);
        return mRes;
    }

/**
@brief Matrix-matrix product

Sets calling matrix to be equal to product of a matrix \c m1 by matrix \c m2
and returns a reference to the matrix changed.
Function throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix m1(2, 3);
cmatrix m2(3, 2);
scmatrix m(2);
m1.set(std::complex<double>(1.,1.));
m2.set(std::complex<double>(1.,1.));
m.mult(m1, m2);
std::cout << m;
\endcode
prints
\code
(0,6) (0,6)
(0,6) (0,6)
\endcode
@param[in] m1 \ref cmatrix multiplicand.
@param[in] m2 \ref cmatrix multiplier.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& mult(const basic_cmatrix& m1, const basic_cmatrix& m2) {
        this->_mult(m1, m2);
        return *this;
    }

/**
@brief Rank-1 update (unconjugated)

Sets calling matrix to rank-1 update (unconjugated) of a vector \c vCol and a vector \c vRow.
The rank-1 update of vector-column \f$x\f$ of size \f$m\f$ and
vector-row \f$y\f$ of size \f$n\f$ is defined as \f$m\times n\f$ matrix
\f[\begin{pmatrix}
x_1 y_1 & x_1 y_2 & \cdots & x_1 y_n \\
x_2 y_1 & x_2 y_2 & \cdots & x_2 y_n \\
\hdotsfor{4} \\
x_m y_1 & x_m y_2 & \cdots & x_m y_n
\end{pmatrix} =
\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_m
\end{pmatrix}
\begin{pmatrix}
y_1 & y_2 & \cdots & y_n
\end{pmatrix}.\f]
Function throws \ref cvmexception if number of rows of a calling matrix
is not equal to \c vCol.size() or number of columns is not equal to \c vRow.size().
\par Example:
\code
using namespace cvm;
cvector vc(3), vr(2);
cmatrix m(3, 2);
vc.set(std::complex<double>(1.,1.));
vr.set(std::complex<double>(1.,1.));
std::cout << m.rank1update_u(vc, vr);
\endcode
prints
\code
(0,2) (0,2)
(0,2) (0,2)
(0,2) (0,2)
\endcode
@see rank1update_c()
@param[in] vCol \ref cvector column.
@param[in] vRow \ref cvector row.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& rank1update_u(const CVector& vCol, const CVector& vRow) {
        const TC one(1., 0.);
        this->_check_rank1update_u();
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vCol.size());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), vRow.size());
        this->_vanish();
        __geru<TC, basic_cmatrix, CVector>(*this, vCol, vRow, one);
        return *this;
    }

/**
@brief Rank-1 update (conjugated)

Sets calling matrix to rank-1 update (conjugated) of a vector \c vCol and a vector \c vRow.
The rank-1 update of vector-column \f$x\f$ of size \f$m\f$ and
vector-row \f$y\f$ of size \f$n\f$ is defined as \f$m\times n\f$ matrix
\f[\begin{pmatrix}
x_1 y_1^* & x_1 y_2^* & \cdots & x_1 y_n^* \\
x_2 y_1^* & x_2 y_2^* & \cdots & x_2 y_n^* \\
\hdotsfor{4} \\
x_m y_1^* & x_m y_2^* & \cdots & x_m y_n^*
\end{pmatrix} =
\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_m
\end{pmatrix}
\begin{pmatrix}
y_1^* & y_2^* & \hdots & y_n^*
\end{pmatrix},\f]
where \f$y_i^*\f$ is \f$i\f$-th complex conjugated element of \f$y\f$.
Function throws \ref cvmexception if number of rows of a calling matrix
is not equal to \c vCol.size() or number of columns is not equal to \c vRow.size().
\par Example:
\code
using namespace cvm;
cvector vc(3), vr(2);
cmatrix m(3, 2);
vc.set(std::complex<double>(1.,1.));
vr.set(std::complex<double>(1.,1.));
std::cout << m.rank1update_c(vc, vr);
\endcode
prints
\code
(2,0) (2,0)
(2,0) (2,0)
(2,0) (2,0)
\endcode
@see rank1update_u()
@param[in] vCol \ref cvector column.
@param[in] vRow \ref cvector row.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& rank1update_c(const CVector& vCol, const CVector& vRow) {
        const TC one(1., 0.);
        this->_check_rank1update_c();
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vCol.size());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), vRow.size());
        this->_vanish();
        __gerc<TC, basic_cmatrix, CVector>(*this, vCol, vRow, one);
        return *this;
    }

/**
@brief Rows swap

Swaps two rows of a calling matrix and returns a reference to
the matrix changed. \c n1 and \c n2 are indexes of rows to be swapped.
Function throws \ref cvmexception if one of the parameters is out of boundaries.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m ((std::complex<double>*)a, 3, 2);
std::cout << m << std::endl;
std::cout << m.swap_rows(2,3);
\endcode
prints
\code
(1,2) (7,8)
(3,4) (9,10)
(5,6) (11,12)

(1,2) (7,8)
(5,6) (11,12)
(3,4) (9,10)
\endcode
@param[in] n1 Row index to swap.
@param[in] n2 Row index to swap.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& swap_rows(tint n1, tint n2) {
        this->_swap_rows(n1, n2);
        return *this;
    }

/**
@brief Columns swap

Swaps two columnss of a calling matrix and returns a reference to
the matrix changed. \c n1 and \c n2 are indexes of columns to be swapped.
Function throws \ref cvmexception if one of the parameters is out of boundaries.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m ((std::complex<double>*)a, 2, 3);
std::cout << m << std::endl;
std::cout << m.swap_cols(2,3);
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

(1,2) (9,10) (5,6)
(3,4) (11,12) (7,8)
\endcode
@param[in] n1 Column index to swap.
@param[in] n2 Column index to swap.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& swap_cols(tint n1, tint n2) {
        this->_swap_cols(n1, n2);
        return *this;
    }

/**
@brief Linear solver

Sets calling matrix to be equal to solution \f$X\f$ of
matrix linear equation \f$A*X=B\f$ where parameter \c mA is square complex matrix \f$A\f$
and parameter \c mB is complex matrix \f$B\f$. Function returns a reference to the matrix changed.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(4);

scmatrix ma(3);
cmatrix  mb(3,2);
cmatrix  mx(3,2);
double dErr;
ma.randomize_real(0.,10.); ma.randomize_imag(0.,10.);
mb.randomize_real(0.,10.); mb.randomize_imag(0.,10.);

mx.solve(ma, mb, dErr);
std::cout << mx << std::endl << ma * mx - mb
          << dErr << std::endl;
\endcode
prints
\code
(+3.2103e-001,+2.8598e-002) (+1.1907e+000,-1.1101e+000)
(+3.7451e-001,+4.2471e-001) (-2.3858e-001,+3.3028e-001)
(+3.0085e-001,-3.0427e-001) (-7.6874e-001,+4.1100e-001)

(+4.4409e-016,+0.0000e+000) (-8.8818e-016,+1.3323e-015)
(+7.7716e-016,-8.8818e-016) (+0.0000e+000,+1.7764e-015)
(+0.0000e+000,-8.8818e-016) (-1.7764e-015,+8.8818e-016)
+5.4774e-015
\endcode
@see solve(const basic_scmatrix<TR,TC>&,const basic_cmatrix<TR,TC>&)
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& solve(const basic_scmatrix<TR,TC>& mA, const basic_cmatrix& mB, TR& dErr) {
        return _solve_helper(mA, mB, dErr, 0);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Sets calling matrix to be equal to solution \f$X\f$ of
matrix linear equation \f$A^T*X=B\f$  (which is equivalent to \f$X^T*A=B^T\f$)
where parameter \c mA is square complex matrix \f$A\f$
and parameter \c mB is complex matrix \f$B\f$. Function returns a reference to the matrix changed.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);

scmatrix ma(3);
cmatrix  mb(3,2);
cmatrix  mx(3,2);
double dErr;
ma.randomize_real(0.,10.); ma.randomize_imag(0.,10.);
mb.randomize_real(0.,10.); mb.randomize_imag(0.,10.);

mx.solve_tran(ma, mb, dErr);

std::cout << !ma * mx - mb << dErr << std::endl;
std::cout << !mx * ma - !mb << std::endl;
\endcode
prints
\code
(+6.661e-016,+1.776e-015) (+0.000e+000,+5.690e-016)
(-1.776e-015,-1.776e-015) (-8.882e-016,-8.882e-016)
(-2.665e-015,+1.776e-015) (+0.000e+000,-1.110e-015)
+7.079e-015
(+6.661e-016,+1.776e-015) (-1.776e-015,-1.776e-015) (-1.776e-015,+1.776e-015)
(+0.000e+000,+5.690e-016) (-8.882e-016,-8.882e-016) (+0.000e+000,-1.554e-015)
\endcode
@see solve_tran(const basic_scmatrix<TR,TC>&,const basic_cmatrix<TR,TC>&)
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& solve_tran(const basic_scmatrix<TR,TC>& mA, const basic_cmatrix& mB, TR& dErr) {
        return _solve_helper(mA, mB, dErr, 1);
    }

// 6.1: conjugate added
/**
@brief Linear solver (conjugated)

Sets calling matrix to be equal to solution \f$X\f$ of
matrix linear equation \f$A^H*X=B\f$  (which is equivalent to \f$X^H*A=B^H\f$)
where parameter \c mA is square complex matrix \f$A\f$
and parameter \c mB is complex matrix \f$B\f$. Function returns a reference to the matrix changed.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);

scmatrix ma(3);
cmatrix  mb(3,2);
cmatrix  mx(3,2);
double dErr;
ma.randomize_real(0.,10.); ma.randomize_imag(0.,10.);
mb.randomize_real(0.,10.); mb.randomize_imag(0.,10.);

mx.solve_conj(ma, mb, dErr);

std::cout << ~ma * mx - mb << dErr << std::endl;
std::cout << ~mx * ma - ~mb << std::endl;
\endcode
prints
\code
(+7.105e-015,-1.776e-015) (+1.332e-015,+8.882e-016)
(+1.776e-015,-8.882e-016) (+8.882e-016,-8.882e-016)
(+0.000e+000,-6.661e-016) (-1.776e-015,-2.665e-015)
+1.169e-014
(+7.105e-015,+1.776e-015) (+1.776e-015,+8.882e-016) (-2.665e-015,+6.661e-016)
(+1.332e-015,-8.882e-016) (+8.882e-016,+8.882e-016) (-1.776e-015,+2.665e-015)
\endcode
@see solve_conj(const basic_scmatrix<TR,TC>&,const basic_cmatrix<TR,TC>&)
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& solve_conj(const basic_scmatrix<TR,TC>& mA, const basic_cmatrix& mB, TR& dErr) {
        return _solve_helper(mA, mB, dErr, 2);
    }

/**
@brief Linear solver

Sets calling matrix to be equal to solution \f$X\f$ of
matrix linear equation \f$A*X=B\f$ where parameter \c mA is square complex matrix \f$A\f$
and parameter \c mB is complex matrix \f$B\f$. Function returns a reference to the matrix changed.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(4);

scmatrix ma(3);
cmatrix  mb(3,2);
cmatrix  mx(3,2);
ma.randomize_real(0.,10.); ma.randomize_imag(0.,10.);
mb.randomize_real(0.,10.); mb.randomize_imag(0.,10.);

mx.solve(ma, mb);
std::cout << mx << std::endl << ma * mx - mb;
\endcode
prints
\code
(+3.2103e-001,+2.8598e-002) (+1.1907e+000,-1.1101e+000)
(+3.7451e-001,+4.2471e-001) (-2.3858e-001,+3.3028e-001)
(+3.0085e-001,-3.0427e-001) (-7.6874e-001,+4.1100e-001)

(+4.4409e-016,+0.0000e+000) (-8.8818e-016,+1.3323e-015)
(+7.7716e-016,-8.8818e-016) (+0.0000e+000,+1.7764e-015)
(+0.0000e+000,-8.8818e-016) (-1.7764e-015,+8.8818e-016)
\endcode
@see solve(const basic_scmatrix<TR,TC>&,const basic_cmatrix<TR,TC>&,TR&)
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mB \ref cmatrix \f$B\f$.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& solve(const basic_scmatrix<TR,TC>& mA,
                         const basic_cmatrix& mB) {
        TR dErr(0.);
        return this->solve(mA, mB, dErr);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Sets calling matrix to be equal to solution \f$X\f$ of
matrix linear equation \f$A^T*X=B\f$  (which is equivalent to \f$X^T*A=B^T\f$)
where parameter \c mA is square complex matrix \f$A\f$
and parameter \c mB is complex matrix \f$B\f$. Function returns a reference to the matrix changed.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);

scmatrix ma(3);
cmatrix  mb(3,2);
cmatrix  mx(3,2);
ma.randomize_real(0.,10.); ma.randomize_imag(0.,10.);
mb.randomize_real(0.,10.); mb.randomize_imag(0.,10.);

mx.solve_tran(ma, mb);

std::cout << !ma * mx - mb << std::endl;
std::cout << !mx * ma - !mb << std::endl;
\endcode
prints
\code
(+6.661e-016,+1.776e-015) (+0.000e+000,+5.690e-016)
(-1.776e-015,-1.776e-015) (-8.882e-016,-8.882e-016)
(-2.665e-015,+1.776e-015) (+0.000e+000,-1.110e-015)

(+6.661e-016,+1.776e-015) (-1.776e-015,-1.776e-015) (-1.776e-015,+1.776e-015)
(+0.000e+000,+5.690e-016) (-8.882e-016,-8.882e-016) (+0.000e+000,-1.554e-015)
\endcode
@see solve_tran(const basic_scmatrix<TR,TC>&,const basic_cmatrix<TR,TC>&,TR&)
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mB \ref cmatrix \f$B\f$.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& solve_tran(const basic_scmatrix<TR,TC>& mA,
                              const basic_cmatrix& mB) {
        TR dErr(0.);
        return this->solve_tran(mA, mB, dErr);
    }

// 6.1: conjugate added
/**
@brief Linear solver (conjugated)

Sets calling matrix to be equal to solution \f$X\f$ of
matrix linear equation \f$A^H*X=B\f$  (which is equivalent to \f$X^H*A=B^H\f$)
where parameter \c mA is square complex matrix \f$A\f$
and parameter \c mB is complex matrix \f$B\f$. Function returns a reference to the matrix changed.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);

scmatrix ma(3);
cmatrix  mb(3,2);
cmatrix  mx(3,2);
ma.randomize_real(0.,10.); ma.randomize_imag(0.,10.);
mb.randomize_real(0.,10.); mb.randomize_imag(0.,10.);

mx.solve_conj(ma, mb);

std::cout << ~ma * mx - mb << std::endl;
std::cout << ~mx * ma - ~mb << std::endl;
\endcode
prints
\code
(+7.105e-015,-1.776e-015) (+1.332e-015,+8.882e-016)
(+1.776e-015,-8.882e-016) (+8.882e-016,-8.882e-016)
(+0.000e+000,-6.661e-016) (-1.776e-015,-2.665e-015)

(+7.105e-015,+1.776e-015) (+1.776e-015,+8.882e-016) (-2.665e-015,+6.661e-016)
(+1.332e-015,-8.882e-016) (+8.882e-016,+8.882e-016) (-1.776e-015,+2.665e-015)
\endcode
@see solve_conj(const basic_scmatrix<TR,TC>&,const basic_cmatrix<TR,TC>&,TR&)
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mB \ref cmatrix \f$B\f$.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& solve_conj(const basic_scmatrix<TR,TC>& mA,
                              const basic_cmatrix& mB) {
        TR dErr(0.);
        return this->solve_conj(mA, mB, dErr);
    }

/**
@brief LU factorization based linear solver

Sets calling matrix to be equal to solution \f$X\f$ of a matrix linear equation
\f$A*X=B\f$ where parameter \c mA is square complex matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref srmatrix::low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c mB is complex matrix \f$B\f$.
Function returns a reference to the matrix changed.
It also sets output parameter \c dErr to be equal to the norm of computation error.
This function is useful when you need to solve few linear equations
of kind \f$A*X=B\f$ with the same matrix \f$A\f$ and different matrices \f$B\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time. Throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(4);
try {
    scmatrix ma(3);
    scmatrix mLU(3);
    cmatrix  mb1(3,2);
    cmatrix  mb2(3,2);
    cmatrix  mx1(3,2);
    cmatrix  mx2(3,2);
    iarray   nPivots(3);
    double   dErr = 0.;
    ma.randomize_real(0.,10.); ma.randomize_imag(0.,10.);
    mb1.randomize_real(0.,10.); mb1.randomize_imag(0.,10.);
    mb2.randomize_real(0.,10.); mb2.randomize_imag(0.,10.);

    mLU.low_up(ma, nPivots);
    std::cout << mx1.solve_lu(ma, mLU, nPivots, mb1, dErr);
    std::cout << dErr << std::endl;
    std::cout << mx2.solve_lu(ma, mLU, nPivots, mb2) << std::endl;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(4.2888e-01,8.2409e-02) (-1.1261e-01,-5.7778e-01)
(5.8052e-01,3.2179e-01) (2.5811e-01,-3.8609e-02)
(-3.1499e-02,-7.0014e-01) (1.2652e+00,4.5309e-01)
5.2931e-15
(3.0153e-01,-5.6606e-01) (-1.6308e-01,1.8217e-01)
(7.4971e-01,-1.1305e-01) (5.2187e-01,2.3441e-01)
(-1.9916e-01,1.4493e+00) (9.1046e-02,3.5242e-01)

(0.0000e+00,-8.8818e-16) (0.0000e+00,-8.8818e-16)
(-4.4409e-16,0.0000e+00) (0.0000e+00,-8.8818e-16)
(0.0000e+00,0.0000e+00) (0.0000e+00,0.0000e+00)

(-8.8818e-16,8.8818e-16) (-8.8818e-16,-1.7764e-15)
(0.0000e+00,0.0000e+00) (2.2204e-16,-8.8818e-16)
(4.4409e-16,-8.8818e-16) (1.3878e-17,-4.4409e-16)
\endcode
@see srmatrix::low_up()
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& solve_lu(const basic_scmatrix<TR,TC>& mA,
                            const basic_scmatrix<TR,TC>& mLU, const tint* pPivots,
                            const basic_cmatrix& mB, TR& dErr) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mA.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mB.nsize());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), mB.msize());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), mLU.msize());
        mA._solve(mB, *this, dErr, mLU, pPivots, 0);
        return *this;
    }

/**
@brief LU factorization based linear solver

Sets calling matrix to be equal to solution \f$X\f$ of a matrix linear equation
\f$A*X=B\f$ where parameter \c mA is square complex matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref srmatrix::low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c mB is complex matrix \f$B\f$.
Function returns a reference to the matrix changed.
This function is useful when you need to solve few linear equations
of kind \f$A*X=B\f$ with the same matrix \f$A\f$ and different matrices \f$B\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time. Throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(4);
try {
    scmatrix ma(3);
    scmatrix mLU(3);
    cmatrix  mb1(3,2);
    cmatrix  mb2(3,2);
    cmatrix  mx1(3,2);
    cmatrix  mx2(3,2);
    iarray   nPivots(3);
    ma.randomize_real(0.,10.); ma.randomize_imag(0.,10.);
    mb1.randomize_real(0.,10.); mb1.randomize_imag(0.,10.);
    mb2.randomize_real(0.,10.); mb2.randomize_imag(0.,10.);

    mLU.low_up(ma, nPivots);
    std::cout << mx1.solve_lu(ma, mLU, nPivots, mb1);
    std::cout << std::endl;
    std::cout << mx2.solve_lu(ma, mLU, nPivots, mb2) << std::endl;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(4.2888e-01,8.2409e-02) (-1.1261e-01,-5.7778e-01)
(5.8052e-01,3.2179e-01) (2.5811e-01,-3.8609e-02)
(-3.1499e-02,-7.0014e-01) (1.2652e+00,4.5309e-01)

(3.0153e-01,-5.6606e-01) (-1.6308e-01,1.8217e-01)
(7.4971e-01,-1.1305e-01) (5.2187e-01,2.3441e-01)
(-1.9916e-01,1.4493e+00) (9.1046e-02,3.5242e-01)

(0.0000e+00,-8.8818e-16) (0.0000e+00,-8.8818e-16)
(-4.4409e-16,0.0000e+00) (0.0000e+00,-8.8818e-16)
(0.0000e+00,0.0000e+00) (0.0000e+00,0.0000e+00)

(-8.8818e-16,8.8818e-16) (-8.8818e-16,-1.7764e-15)
(0.0000e+00,0.0000e+00) (2.2204e-16,-8.8818e-16)
(4.4409e-16,-8.8818e-16) (1.3878e-17,-4.4409e-16)
\endcode
@see srmatrix::low_up()
@param[in] mA \ref scmatrix \f$A\f$.
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] mB \ref cmatrix \f$B\f$.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& solve_lu(const basic_scmatrix<TR,TC>& mA,
                            const basic_scmatrix<TR,TC>& mLU, const tint* pPivots,
                            const basic_cmatrix& mB) {
        TR dErr(0.);
        return this->solve_lu(mA, mLU, pPivots, mB, dErr);
    }

/**
@brief Singular value decomposition

Creates \ref rvector of singular values
\f[
\sigma_1\ge\sigma_2\ge\dots\ge\sigma_{\min(m,n)}\ge 0
\f]
of \f$m\times n\f$ complex matrix \f$A\f$ (calling matrix).
These values are the main diagonal of a matrix \f$\Sigma\f$ of the singular value decomposition
\f[
A=U\Sigma V^H
\f]
where \f$U\f$ and \f$V\f$ are orthogonal for real \f$A\f$ and unitary for complex \f$A\f$.
\f$V^H\f$ is transposed \f$V\f$ for real one and Hermitian conjugated \f$V\f$ for complex one.
First \f$\min(m, n)\f$ columns of matrices \f$U\f$ and \f$V\f$ are left and right singular
vectors of \f$A\f$ respectively. Singular values and singular vectors satisfy
\f[
Av_i=\sigma_i u_i\ \ \text{ and }\ \ A^Hu_i=\sigma_i v_i
\f]
where \f$u_i\f$ and \f$v_i\f$ are \f$i\f$-th columns of \f$U\f$ and \f$V\f$ respectively.
Function throws \ref cvmexception in case of convergence error.
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double m[] = {1., -1., 1., 2., -2., 1.,
                  3., -2., 1., 0., -2., 1.};
    cmatrix mA((std::complex<double>*) m, 2, 3);
    cmatrix mSigma(2,3);
    rvector v(2);
    scmatrix mU(2), mVH(3);

    v = mA.svd(mU, mVH);
    mSigma.diag(0) = cvector(v);

    std::cout << mU << std::endl;
    std::cout << mVH << std::endl;
    std::cout << mSigma << std::endl;

    std::cout << (mA * ~mVH - mU * mSigma).norm() << std::endl;
    std::cout << (~mA * mU - ~(mSigma * mVH)).norm() << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-4.861e-01,0.000e+00) (8.739e-01,0.000e+00)
(7.956e-01,-3.616e-01) (4.425e-01,-2.012e-01)

(-7.590e-02,4.474e-01) (7.488e-01,-1.820e-01) (-4.474e-01,1.327e-02)
(8.084e-01,1.878e-01) (-1.576e-02,5.238e-01) (-1.878e-01,3.558e-02)
(1.065e-01,3.065e-01) (3.597e-01,4.669e-02) (8.727e-01,4.012e-02)

(5.452e+00,0.000e+00) (0.000e+00,0.000e+00) (0.000e+00,0.000e+00)
(0.000e+00,0.000e+00) (1.131e+00,0.000e+00) (0.000e+00,0.000e+00)

1.357e-15
1.267e-15
\endcode
@return Result object (singular values in decreasing order).
*/
    [[nodiscard]] RVector svd() const {
        RVector vRes(_cvm_min<tint>(this->msize(), this->nsize()));
        this->_svd(vRes, nullptr, nullptr);
        return vRes;
    }

/**
@brief Singular value decomposition

Creates \ref rvector of singular values
\f[
\sigma_1\ge\sigma_2\ge\dots\ge\sigma_{\min(m,n)}\ge 0
\f]
of \f$m\times n\f$ complex matrix \f$A\f$ (calling matrix).
These values are the main diagonal of a matrix \f$\Sigma\f$ of the singular value decomposition
\f[
A=U\Sigma V^H
\f]
where \f$U\f$ and \f$V\f$ are orthogonal for real \f$A\f$ and unitary for complex \f$A\f$.
\f$V^H\f$ is transposed \f$V\f$ for real one and Hermitian conjugated \f$V\f$ for complex one.
First \f$\min(m, n)\f$ columns of matrices \f$U\f$ and \f$V\f$ are left and right singular
vectors of \f$A\f$ respectively. Singular values and singular vectors satisfy
\f[
Av_i=\sigma_i u_i\ \ \text{ and }\ \ A^Hu_i=\sigma_i v_i
\f]
where \f$u_i\f$ and \f$v_i\f$ are \f$i\f$-th columns of \f$U\f$ and \f$V\f$ respectively.
Function sets output parameter \c mU to be equal to square matrix \f$U\f$ of size \f$m\times m\f$ and
\c mVH to be equal to square matrix \f$V^H\f$ of size \f$n\times n\f$.
Function throws \ref cvmexception
in case of inappropriate calling object size (it must be equal to \f$\min(m,n)\f$), matrix \c mU size
(must be \f$m\times m\f$), matrix \c mVH size (must be \f$n\times n\f$) or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    double m[] = {1., -1., 1., 2., -2., 1.,
                  3., -2., 1., 0., -2., 1.};
    cmatrix mA((std::complex<double>*) m, 2, 3);
    cmatrix mSigma(2,3);
    rvector v(2);
    scmatrix mU(2), mVH(3);

    v = mA.svd(mU, mVH);
    mSigma.diag(0) = cvector(v);

    std::cout << mU << std::endl;
    std::cout << mVH << std::endl;
    std::cout << mSigma << std::endl;

    std::cout << (mA * ~mVH - mU * mSigma).norm() << std::endl;
    std::cout << (~mA * mU - ~(mSigma * mVH)).norm() << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-4.861e-01,0.000e+00) (8.739e-01,0.000e+00)
(7.956e-01,-3.616e-01) (4.425e-01,-2.012e-01)

(-7.590e-02,4.474e-01) (7.488e-01,-1.820e-01) (-4.474e-01,1.327e-02)
(8.084e-01,1.878e-01) (-1.576e-02,5.238e-01) (-1.878e-01,3.558e-02)
(1.065e-01,3.065e-01) (3.597e-01,4.669e-02) (8.727e-01,4.012e-02)

(5.452e+00,0.000e+00) (0.000e+00,0.000e+00) (0.000e+00,0.000e+00)
(0.000e+00,0.000e+00) (1.131e+00,0.000e+00) (0.000e+00,0.000e+00)

1.357e-15
1.267e-15
\endcode
@param[out] mU \ref scmatrix \f$U\f$.
@param[out] mVH \ref scmatrix \f$V^H\f$.
@return Result object (singular values in decreasing order).
*/
    RVector svd(basic_scmatrix<TR,TC>& mU,
                basic_scmatrix<TR,TC>& mVH) const {
        RVector vRes(_cvm_min<tint>(this->msize(), this->nsize()));
        this->_svd(vRes, &mU, &mVH);
        return vRes;
    }

/**
@brief Pseudo (generalized) inversion

Creates an object of type \ref cmatrix as pseudo inverted calling matrix.
Matrix pseudo inversion (aka Moore-Penrose generalized inversion) definition:
\f$n\times m\f$ matrix \f$A^{+}\f$ is
<em>pseudo inversion</em> of \f$m\times n\f$ matrix \f$A\f$ if the following two equations
are satisfied:
\f[
AA^{+}A=A,\\
A^{+}=QA^H=A^HP
\f]
where \f$Q\f$ and \f$P\f$ are some matrices. To compute the pseudo inversion, we use
singular value decomposition
\f[
A = U\Sigma V^H
\f]
of a matrix \f$A\f$, thus
\f[
A^{+} = V\Sigma^{-1}U^{H},
\f]
where \f$\Sigma^{-1}\f$ is diagonal \f$n\times m\f$ matrix having inverted
diagonal values of a matrix \f$\Sigma\f$ if they are greater than some threshold,
and zeros otherwise. The \c threshold parameter sets  the minimum distinguishable
from zero singular value to be used to compute the pseudo inversion.
All values equal or less than the threshold are treated as zeros.
Function throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);
try {
    cmatrix mA(2,3);
    mA(1,1) = tcomplex(1.,2.);  mA(1,2) = tcomplex(-1.,3.);
    mA(1,3) = tcomplex(0.,-1.);
    mA(2,1) = tcomplex(1.,-2.); mA(2,2) = tcomplex(1.,-4.);
    mA(2,3) = tcomplex(1.,0.);
    cmatrix mX = mA.pinv();
    std::cout << mX << (mA * mX * mA - mA).norm2() << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+3.2407407e-01,-1.1111111e-01) (+2.5925926e-01,-1.8518519e-02)
(-1.3888889e-01,-2.7777778e-02) (-5.5555556e-02,+1.6666667e-01)
(+1.4814815e-01,+2.3148148e-01) (+1.6666667e-01,+1.4814815e-01)
+3.3217718e-15
\endcode
@see svd()
@param[in] threshold Algorithm threshold.
@return Result object.
*/
    [[nodiscard]] basic_cmatrix pinv(TR threshold = basic_cvmMachSp<TR>()) const {
        basic_cmatrix mAx(this->nsize(), this->msize());
        this->_pinv(mAx, threshold);
        return mAx;
    }

/**
@brief Pseudo (generalized) inversion

Sets calling matrix to be equal to complex matrix \c mA pseudo inverted.
Matrix pseudo inversion (aka Moore-Penrose generalized inversion) definition:
\f$n\times m\f$ matrix \f$A^{+}\f$ is
<em>pseudo inversion</em> of \f$m\times n\f$ matrix \f$A\f$ if the following two equations
are satisfied:
\f[
AA^{+}A=A,\\
A^{+}=QA^H=A^HP
\f]
where \f$Q\f$ and \f$P\f$ are some matrices. To compute the pseudo inversion, we use
singular value decomposition
\f[
A = U\Sigma V^H
\f]
of a matrix \f$A\f$, thus
\f[
A^{+} = V\Sigma^{-1}U^{H},
\f]
where \f$\Sigma^{-1}\f$ is diagonal \f$n\times m\f$ matrix having inverted
diagonal values of a matrix \f$\Sigma\f$ if they are greater than some threshold,
and zeros otherwise. The \c threshold parameter sets  the minimum distinguishable
from zero singular value to be used to compute the pseudo inversion.
All values equal or less than the threshold are treated as zeros.
Function throws \ref cvmexception in case of not appropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(3);
try {
    cmatrix mA(2,3), mX(3,2);
    mA(1,1) = tcomplex(1.,2.);  mA(1,2) = tcomplex(-1.,3.);
    mA(1,3) = tcomplex(0.,-1.);
    mA(2,1) = tcomplex(1.,-2.); mA(2,2) = tcomplex(1.,-4.);
    mA(2,3) = tcomplex(1.,0.);
    mX.pinv(mA);
    std::cout << mX << (mA * mX * mA - mA).norm2() << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+3.241e-001,-1.111e-001) (+2.593e-001,-1.852e-002)
(-1.389e-001,-2.778e-002) (-5.556e-002,+1.667e-001)
(+1.481e-001,+2.315e-001) (+1.667e-001,+1.481e-001)
+3.322e-015
\endcode
@see svd()
@param[in] mA Matrix to pseudo invert.
@param[in] threshold Algorithm threshold.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& pinv(const basic_cmatrix& mA,
                        TR threshold = basic_cvmMachSp<TR>()) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mA.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mA.msize());
        mA._pinv(*this, threshold);
        return *this;
    }

/**
@brief Overdetermined or underdetermined linear solver

Creates an object of type \ref cmatrix as a
solution of overdetermined or underdetermined linear systems
\f[
A*x=b
\f]
for \f$m\times n\f$ complex matrix \f$A\f$ (or its conjugated one) where
\f$b\f$ is a vector of length \f$k\f$ combined to
\f[
A*X=B
\f]
for multiple vectors \f$b\f$ stored as columns of \f$k\times l\f$ matrix \f$B\f$ where
\f$k=m\f$ in non-conjugated case and \f$k=n\f$ otherwise.
The algorithm uses QR or LQ factorization of \f$A\f$.
It is assumed that \f$A\f$ has full rank, infinity returned otherwise.
Internally function uses \c ZGELS LAPACK routines.
If \f$m>n\f$ and \c conjugate=false or \f$m<n\f$ and \c conjugate=true, then
the system is overdetermined, thus the algorithm tries to find the least squares solution \f$x\f$
of the problem
\f[
\|A*x-b\|_2\to\min\quad\text{or}\quad\|A^H*x-b\|_2\to\min\
\f]
respectively. Real number \c dErr (or vector \c vErr for multiple vector \f$b\f$ case) returns residual sum of squares.
The system is underdetermined otherwise, and the algorithm finds its minimum norm solution.
In this case \c bErr is set to zero. In both cases the solution computed
satisfies \f$\newcommand{\pinv}{\operatorname{pinv}} x=\pinv(A)*b\f$, but this algorithm is faster than pseudo inversion.
Function throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix a(7, 5);
cmatrix b(7, 2);
cmatrix bt(5, 2);
cvector bv(5);
cvector vErr(2);
tcomplex dErr;
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bt.randomize_real(-10., 10.);
bt.randomize_imag(-10., 10.);
bv.randomize_real(-10., 10.);
bv.randomize_imag(-10., 10.);

cmatrix x = a.gels(false, b, vErr);
cvector vt = a.gels(true, bv, dErr);
cmatrix xt(7,2);
xt.gels(true, a, bt, vErr);

std::cout << (a.pinv()*b - x).norm() << std::endl;
std::cout << (~a.pinv()*bv - vt).norm() << std::endl;
std::cout << (~a.pinv()*bt - xt).norm() << std::endl;
\endcode
prints
\code
+1.3258216e-015
+1.0696705e-015
+1.1685394e-015
\endcode
@see pinv()
@param[in] conjugate True to compute for transposed matrix \f$A\f$ (calling matrix).
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] vErr Norms of computation errors.
@return Result object.
*/
    basic_cmatrix gels(bool conjugate, const basic_cmatrix& mB,
                       basic_cvector<TR,TC>& vErr) const {
        _check_ne(CVM_SIZESMISMATCH, vErr.size(), mB.nsize());
        _check_ne(CVM_SIZESMISMATCH, conjugate ? this->nsize() : this->msize(), mB.msize());
        basic_cmatrix mA(*this);  // this algorithm overrides A
        basic_cmatrix mX;
        __gels(conjugate, mA, mB, mX, vErr);
        return mX;
    }

/**
@brief Overdetermined or underdetermined linear solver

Sets calling matrix to a
solution of overdetermined or underdetermined linear systems
\f[
A*x=b
\f]
for \f$m\times n\f$ complex matrix \f$A\f$ (or conjuated one, parameter \c mA) where
\f$b\f$ is a vector of length \f$k\f$ combined to
\f[
A*X=B
\f]
for multiple vectors \f$b\f$ stored as columns of \f$k\times l\f$ matrix \f$B\f$ where
\f$k=m\f$ in non-conjugated case and \f$k=n\f$ otherwise.
The algorithm uses QR or LQ factorization of \f$A\f$.
It is assumed that \f$A\f$ has full rank, infinity returned otherwise.
Internally function uses \c ZGELS LAPACK routines.
If \f$m>n\f$ and \c transpose=false or \f$m<n\f$ and \c transpose=true, then
the system is overdetermined, thus the algorithm tries to find the least squares solution \f$x\f$
of the problem
\f[
\|A*x-b\|_2\to\min\quad\text{or}\quad\|A^H*x-b\|_2\to\min\
\f]
respectively. Real number \c dErr (or vector \c vErr for multiple vector \f$b\f$ case) returns residual sum of squares.
The system is underdetermined otherwise, and the algorithm finds its minimum norm solution.
In this case \c bErr is set to zero. In both cases the solution computed
satisfies \f$\newcommand{\pinv}{\operatorname{pinv}} x=\pinv(A)*b\f$, but this algorithm is faster than pseudo inversion.
Function throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix a(7, 5);
cmatrix b(7, 2);
cmatrix bt(5, 2);
cvector bv(5);
cvector vErr(2);
tcomplex dErr;
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bt.randomize_real(-10., 10.);
bt.randomize_imag(-10., 10.);
bv.randomize_real(-10., 10.);
bv.randomize_imag(-10., 10.);

cmatrix x = a.gels(false, b, vErr);
cvector vt = a.gels(true, bv, dErr);
cmatrix xt(7,2);
xt.gels(true, a, bt, vErr);

std::cout << (a.pinv()*b - x).norm() << std::endl;
std::cout << (~a.pinv()*bv - vt).norm() << std::endl;
std::cout << (~a.pinv()*bt - xt).norm() << std::endl;
\endcode
prints
\code
+1.3258216e-015
+1.0696705e-015
+1.1685394e-015
\endcode
@see pinv()
@param[in] conjugate True to compute for conjugated matrix \f$A\f$ (calling matrix).
@param[in] mA \ref cmatrix \f$A\f$.
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] vErr Norms of computation errors.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& gels(bool conjugate, const basic_cmatrix& mA, const basic_cmatrix& mB,
                        basic_cvector<TR,TC>& vErr) {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mB.nsize());
        _check_ne(CVM_SIZESMISMATCH, mB.nsize(), vErr.size());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), conjugate ? mA.msize() : mA.nsize());
        _check_ne(CVM_SIZESMISMATCH, mB.msize(), conjugate ? mA.nsize() : mA.msize());
        basic_cmatrix mA2(mA);  // this algorithm overrides A
        __gels(conjugate, mA2, mB, *this, vErr);
        return *this;
    }

/**
@brief Overdetermined or underdetermined linear solver

Creates an object of type \ref cvector as a
solution of overdetermined or underdetermined linear system
\f[
A*x=b
\f]
for \f$m\times n\f$ complex matrix \f$A\f$ (or conjugated one) where
\f$b\f$ is a vector of length \f$k\f$
where
\f$k=m\f$ in non-transposed case and \f$k=n\f$ otherwise.
The algorithm uses QR or LQ factorization of \f$A\f$.
It is assumed that \f$A\f$ has full rank, infinity returned otherwise.
Internally function uses \c ZGELS LAPACK routines.
If \f$m>n\f$ and \c transpose=false or \f$m<n\f$ and \c transpose=true, then
the system is overdetermined, thus the algorithm tries to find the least squares solution \f$x\f$
of the problem
\f[
\|A*x-b\|_2\to\min\quad\text{or}\quad\|A^H*x-b\|_2\to\min\
\f]
respectively. Real number \c dErr returns residual sum of squares.
The system is underdetermined otherwise, and the algorithm finds its minimum norm solution.
In this case \c bErr is set to zero. In both cases the solution computed
satisfies \f$\newcommand{\pinv}{\operatorname{pinv}} x=\pinv(A)*b\f$, but this algorithm is faster than pseudo inversion.
Function throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix a(7, 5);
cmatrix b(7, 2);
cmatrix bt(5, 2);
cvector bv(5);
cvector vErr(2);
tcomplex dErr;
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bt.randomize_real(-10., 10.);
bt.randomize_imag(-10., 10.);
bv.randomize_real(-10., 10.);
bv.randomize_imag(-10., 10.);

cmatrix x = a.gels(false, b, vErr);
cvector vt = a.gels(true, bv, dErr);
cmatrix xt(7,2);
xt.gels(true, a, bt, vErr);

std::cout << (a.pinv()*b - x).norm() << std::endl;
std::cout << (~a.pinv()*bv - vt).norm() << std::endl;
std::cout << (~a.pinv()*bt - xt).norm() << std::endl;
\endcode
prints
\code
+1.3258216e-015
+1.0696705e-015
+1.1685394e-015
\endcode
@see pinv()
@param[in] conjugate True to compute for conjugated matrix \f$A\f$ (calling matrix).
@param[in] vB \ref cvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    basic_cvector<TR,TC> gels(bool conjugate,
                              const basic_cvector<TR,TC>& vB,
                              TC& dErr) const {
        _check_ne(CVM_SIZESMISMATCH, conjugate ? this->nsize() : this->msize(), vB.size());
        basic_cmatrix mA(*this);  // this algorithm overrides A
        basic_cmatrix mB(vB, vB.size(), 1);
        basic_cmatrix mX;
        basic_cvector<TR,TC> vErr(1);
        __gels(conjugate, mA, mB, mX, vErr);
        dErr = vErr(0);
        const TC* pResult = mX;
        return basic_cvector<TR,TC>(pResult, mX.msize());
    }

/**
@brief Linear least squares problem

Function creates \ref cmatrix object with the minimum-norm solutions to linear least squares problems
\f[
\|A*x-b\|_2\to\min
\f]
using complete orthogonal factorization of \f$m\times n\f$ calling complex matrix \f$A\f$.
Here \f$b\f$ is a vector of length \f$m\f$.
Multiple vectors \f$b\f$ are stored as columns of \f$m\times l\f$ matrix \f$B\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c ZGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix a(4, 5);
cmatrix b(4, 2);
cvector bv(4);
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bv.randomize_real(-10., 10.);
bv.randomize_imag(-10., 10.);
tint rank;

cmatrix x = a.gelsy(b, rank);
cvector xv = a.gelsy(bv, rank);
cmatrix x2(5,2);
x2.gelsy(a, b, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*x2 - b).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+8.9701623e-015
+6.9342294e-015
+8.9701623e-015
+4 +4
\endcode
@see gelss()
@see gelsd()
@see cvector::gelsy()
@see rank()
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Result object.
*/
    basic_cmatrix gelsy(const basic_cmatrix& mB, tint& rank,
                        TR tol = basic_cvmMachSp<TR>()) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mB.msize());
        basic_cmatrix mA(*this);  // this algorithm overrides A
        basic_cmatrix mX;
        __gelsy(mA, mB, mX, tol, rank);
        return mX;
    }

/**
@brief Linear least squares problem

Function sets calling matrix to the minimum-norm solutions to linear least squares problems
\f[
\|A*x-b\|_2\to\min
\f]
using complete orthogonal factorization of \f$m\times n\f$ complex matrix \f$A\f$ (parameter \c mA).
Here \f$b\f$ is a vector of length \f$m\f$.
Multiple vectors \f$b\f$ are stored as columns of \f$m\times l\f$ matrix \f$B\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c ZGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix a(4, 5);
cmatrix b(4, 2);
cvector bv(4);
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bv.randomize_real(-10., 10.);
bv.randomize_imag(-10., 10.);
tint rank;

cmatrix x = a.gelsy(b, rank);
cvector xv = a.gelsy(bv, rank);
cmatrix x2(5,2);
x2.gelsy(a, b, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*x2 - b).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+8.9701623e-015
+6.9342294e-015
+8.9701623e-015
+4 +4
\endcode
@see gelss()
@see gelsd()
@see cvector::gelsy()
@see rank()
@param[in] mA \ref cmatrix \f$A\f$.
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& gelsy(const basic_cmatrix& mA, const basic_cmatrix& mB,
                         tint& rank, TR tol = basic_cvmMachSp<TR>()) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mA.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mB.nsize());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), mB.msize());
        basic_cmatrix mA2(mA);  // this algorithm overrides A
        __gelsy(mA2, mB, *this, tol, rank);
        return *this;
    }

/**
@brief Linear least squares problem

Function creates \ref cvector object with the minimum-norm solution to linear least squares problem
\f[
\|A*x-b\|_2\to\min
\f]
using complete orthogonal factorization of \f$m\times n\f$ calling complex matrix \f$A\f$.
Here \f$b\f$ is a vector of length \f$m\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c ZGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix a(4, 5);
cmatrix b(4, 2);
cvector bv(4);
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bv.randomize_real(-10., 10.);
bv.randomize_imag(-10., 10.);
tint rank;

cmatrix x = a.gelsy(b, rank);
cvector xv = a.gelsy(bv, rank);
cmatrix x2(5,2);
x2.gelsy(a, b, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*x2 - b).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+8.9701623e-015
+6.9342294e-015
+8.9701623e-015
+4 +4
\endcode
@see gelss()
@see gelsd()
@see cvector::gelsy()
@see rank()
@param[in] vB \ref cvector \f$b\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Result object.
*/
    basic_cvector<TR,TC> gelsy(const basic_cvector<TR,TC>& vB, tint& rank,
                               TR tol = basic_cvmMachSp<TR>()) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vB.size());
        basic_cmatrix mA(*this);  // this algorithm overrides A
        basic_cmatrix mB(vB, vB.size(), 1);
        basic_cmatrix mX;
        __gelsy(mA, mB, mX, tol, rank);
        const TC* pResult = mX;
        return basic_cvector<TR,TC>(pResult, mX.msize());
    }

/**
@brief Linear least squares problem

Function creates \ref cmatrix object with the minimum-norm solutions to linear least squares problems
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ calling complex matrix \f$A\f$.
Here \f$b\f$ is a vector of length \f$m\f$.
Multiple vectors \f$b\f$ are stored as columns of \f$m\times l\f$ matrix \f$B\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c ZGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix a(4, 5);
cmatrix b(4, 2);
cvector bv(4);
rvector sv(4);
tint rank;
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bv.randomize_real(-10., 10.);
bv.randomize_imag(-10., 10.);

cmatrix x = a.gelss(b, sv, rank);
cvector xv = a.gelss(bv, sv, rank);
cmatrix xt(5,2);
xt.gelss(a, b, sv, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*xt - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+2.3444861e-013
+4.6335022e-014
+2.3444861e-013
+1.1234667e-014
+4 +4
\endcode
@see gelsy()
@see gelsd()
@see cvector::gelss()
@see rank()
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] sv Singular values of \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Result object.
*/
    basic_cmatrix gelss(const basic_cmatrix& mB, basic_rvector<TR>& sv, tint& rank,
                        TR tol = basic_cvmMachSp<TR>()) const {
        return _gels_sd(true, mB, sv, rank, tol);
    }

/**
@brief Linear least squares problem

Function sets calling matrix to the minimum-norm solutions to linear least squares problems
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ complex matrix \f$A\f$ (parameter \c mA).
Here \f$b\f$ is a vector of length \f$m\f$.
Multiple vectors \f$b\f$ are stored as columns of \f$m\times l\f$ matrix \f$B\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c ZGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix a(4, 5);
cmatrix b(4, 2);
cvector bv(4);
rvector sv(4);
tint rank;
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bv.randomize_real(-10., 10.);
bv.randomize_imag(-10., 10.);

cmatrix x = a.gelss(b, sv, rank);
cvector xv = a.gelss(bv, sv, rank);
cmatrix xt(5,2);
xt.gelss(a, b, sv, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*xt - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+2.3444861e-013
+4.6335022e-014
+2.3444861e-013
+1.1234667e-014
+4 +4
\endcode
@see gelsy()
@see gelsd()
@see cvector::gelss()
@see rank()
@param[in] mA \ref cmatrix \f$A\f$.
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] sv Singular values of \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& gelss(const basic_cmatrix& mA,
                         const basic_cmatrix& mB, basic_rvector<TR>& sv,
                         tint& rank, TR tol = basic_cvmMachSp<TR>()) {
        _gels_sd(true, mA, mB, sv, rank, tol);
        return *this;
    }

/**
@brief Linear least squares problem

Function creates \ref cvector object with the minimum-norm solution to linear least squares problem
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ calling complex matrix \f$A\f$.
Here \f$b\f$ is a vector of length \f$m\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c ZGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix a(4, 5);
cmatrix b(4, 2);
cvector bv(4);
rvector sv(4);
tint rank;
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bv.randomize_real(-10., 10.);
bv.randomize_imag(-10., 10.);

cmatrix x = a.gelss(b, sv, rank);
cvector xv = a.gelss(bv, sv, rank);
cmatrix xt(5,2);
xt.gelss(a, b, sv, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*xt - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+2.3444861e-013
+4.6335022e-014
+2.3444861e-013
+1.1234667e-014
+4 +4
\endcode
@see gelsy()
@see gelsd()
@see cvector::gelss()
@see rank()
@param[in] vB \ref cvector \f$b\f$.
@param[out] sv Singular values of \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Result object.
*/
    basic_cvector<TR,TC> gelss(const basic_cvector<TR,TC>& vB, basic_rvector<TR>& sv,
                               tint& rank,
                               TR tol = basic_cvmMachSp<TR>()) const {
        return _gels_sd(true, vB, sv, rank, tol);
    }

/**
@brief Linear least squares problem

Function creates \ref cmatrix object with the minimum-norm solutions to linear least squares problems
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ calling complex matrix \f$A\f$ and divide and conquer method.
Here \f$b\f$ is a vector of length \f$m\f$.
Multiple vectors \f$b\f$ are stored as columns of \f$m\times l\f$ matrix \f$B\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c ZGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix a(4, 5);
cmatrix b(4, 2);
cvector bv(4);
rvector sv(4);
tint rank;
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bv.randomize_real(-10., 10.);
bv.randomize_imag(-10., 10.);

cmatrix x = a.gelsd(b, sv, rank);
cvector xv = a.gelsd(bv, sv, rank);
cmatrix xt(5,2);
xt.gelsd(a, b, sv, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*xt - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+1.2865301e-014
+1.2824878e-014
+1.2865301e-014
+1.2809491e-014
+4 +4
\endcode
@see gelsy()
@see gelss()
@see cvector::gelss()
@see rank()
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] sv Singular values of \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Result object.
*/
    basic_cmatrix gelsd(const basic_cmatrix& mB, basic_rvector<TR>& sv,
                        tint& rank, TR tol = basic_cvmMachSp<TR>()) const {
        return _gels_sd(false, mB, sv, rank, tol);
    }

/**
@brief Linear least squares problem

Function sets calling complex matrix to the minimum-norm solutions to linear least squares problems
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ complex matrix \f$A\f$ (parameter \c mA) and divide and conquer method.
Here \f$b\f$ is a vector of length \f$m\f$.
Multiple vectors \f$b\f$ are stored as columns of \f$m\times l\f$ matrix \f$B\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c ZGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix a(4, 5);
cmatrix b(4, 2);
cvector bv(4);
rvector sv(4);
tint rank;
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bv.randomize_real(-10., 10.);
bv.randomize_imag(-10., 10.);

cmatrix x = a.gelsd(b, sv, rank);
cvector xv = a.gelsd(bv, sv, rank);
cmatrix xt(5,2);
xt.gelsd(a, b, sv, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*xt - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+1.2865301e-014
+1.2824878e-014
+1.2865301e-014
+1.2809491e-014
+4 +4
\endcode
@see gelsy()
@see gelss()
@see cvector::gelss()
@see rank()
@param[in] mA \ref cmatrix \f$A\f$.
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] sv Singular values of \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& gelsd(const basic_cmatrix& mA,
                         const basic_cmatrix& mB, basic_rvector<TR>& sv,
                         tint& rank, TR tol = basic_cvmMachSp<TR>()) {
        _gels_sd(false, mA, mB, sv, rank, tol);
        return *this;
    }

/**
@brief Linear least squares problem

Function creates \ref cvector object with the minimum-norm solution to linear least squares problem
\f[
\|A*x-b\|_2\to\min
\f]
using singular value decomposition of \f$m\times n\f$ calling complex matrix \f$A\f$ and divide and conquer method.
Here \f$b\f$ is a vector of length \f$m\f$.
Matrix \f$A\f$ may be rank-deficient, function returns its effective rank in \c rank
output parameter using \c tol tolerance.
Internally function uses \c ZGELSY  LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix \f$A\f$ is passed as argument \c mA.
Function also computes singular values of \f$A\f$ in decreasing order and returns them in \c sv output parameter
having \f$\min(m,n)\f$ size.
It throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
cmatrix a(4, 5);
cmatrix b(4, 2);
cvector bv(4);
rvector sv(4);
tint rank;
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bv.randomize_real(-10., 10.);
bv.randomize_imag(-10., 10.);

cmatrix x = a.gelsd(b, sv, rank);
cvector xv = a.gelsd(bv, sv, rank);
cmatrix xt(5,2);
xt.gelsd(a, b, sv, rank);

std::cout << (a*x - b).norm() << std::endl;
std::cout << (a*xv - bv).norm() << std::endl;
std::cout << (a*xt - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\endcode
prints
\code
+1.2865301e-014
+1.2824878e-014
+1.2865301e-014
+1.2809491e-014
+4 +4
\endcode
@see gelsy()
@see gelss()
@see cvector::gelss()
@see rank()
@param[in] vB \ref cvector \f$b\f$.
@param[out] sv Singular values of \f$A\f$.
@param[out] rank Rank of a matrix \f$A\f$.
@param[in] tol Rank computation tolerance.
@return Result object.
*/
    basic_cvector<TR,TC> gelsd(const basic_cvector<TR,TC>& vB, basic_rvector<TR>& sv,
                               tint& rank, TR tol = basic_cvmMachSp<TR>()) const {
        return _gels_sd(false, vB, sv, rank, tol);
    }

/**
@brief Matrix rank

Returns rank of a calling complex matrix as number of
singular values with normalized absolute value greater than or
equal to parameter \c tol (this is the <em>largest relative spacing</em> by default).
Function throws \ref cvmexception in case of convergence error.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m(a, nullptr, 3, 4);
std::cout << m << m.rank() << std::endl;
m(3,4) = std::complex<double>(0.,1.);
std::cout << m.rank() << std::endl;
\endcode
prints
\code
(1,0) (4,0) (7,0) (10,0)
(2,0) (5,0) (8,0) (11,0)
(3,0) (6,0) (9,0) (12,0)
2
3
\endcode
@see rvector::svd()
@see cvector::normalize()
@see cvmMachSp()
@param[in] tol Rank computation tolerance.
@return tint Rank as integer.
*/
    [[nodiscard]] tint rank(TR tol = basic_cvmMachSp<TR>()) const {
        tint nRank = 0;
        RVector vS(_cvm_min<tint>(this->msize(), this->nsize()));
        this->_svd(vS, nullptr, nullptr);
        vS.normalize();
        for (; nRank < vS.size(); ++nRank) {
            if (vS[nRank * this->incr()] < tol) break;
        }
        return nRank;
    }

// QR factorization
// Case 1: "economy" mode, A is (m x n) and Q is (m x n) and R is (n x n)
/**
@brief QR factorization ("economy" mode)

Computes QR factorization as
\f[
M=QR
\f]
where
\f$M\f$ is calling matrix, orthogonal matrix \f$Q\f$
and upper triangular (trapezoidal) matrix \f$R\f$ are \c mQ and \c mR output parameters
respectively. This version implements so-called "economy" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times n\f$ matrix \f$Q\f$
and \f$n\times n\f$ matrix \f$R\f$. See also \ref qr(basic_scmatrix<TR,TC>&,basic_cmatrix<TR,TC>&)const  "full" version.
Function throws \ref cvmexception in case if inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal ar[] = {1., 2., 3., 4., 5., 6.};
treal ai[] = {1., -1., 2., -2., 3., -3.};
const cvm::cmatrix mh(ar, ai, 2, 3);
const cvm::cmatrix mv(ar, ai, 3, 2);
cvm::scmatrix s2(2), s3(3);
cvm::cmatrix  h(2,3), v(3,2);

mh.qr(h,s3);
std::cout << (eye_complex(2)-~cmatrix(h,1,1,2,2)*cmatrix(h,1,1,2,2)).norm()
          << " " << (mh - h * s3).norm() << std::endl;
mh.qr(s2,h);
std::cout << (eye_complex(2) - ~s2 * s2).norm()
          << " " << (mh - s2 * h).norm() << std::endl;
mv.qr(v,s2);
std::cout << (eye_complex(2) - ~v * v).norm()
          << " " << (mv - v * s2).norm() << std::endl;
mv.qr(s3,v);
std::cout << (eye_complex(3) - ~s3 * s3).norm()
          << " " << (mv - s3 * v).norm() << std::endl;
\endcode
prints
\code
+2.5145832e-16 +1.3506446e-15
+2.5145832e-16 +1.3506446e-15
+2.5367068e-16 +1.4432899e-15
+3.8435519e-16 +1.4432899e-15
\endcode
@param[out] mQ \ref cmatrix \f$Q\f$.
@param[out] mR \ref scmatrix \f$R\f$.
*/
    void qr(basic_cmatrix<TR,TC>& mQ, basic_scmatrix<TR,TC>& mR) const {
        this->_qr_rs(mQ, mR);
    }

// Case 2: full mode, A is (m x n) and Q is (m x m) and R is (m x n)
/**
@brief QR factorization ("full" mode)

Computes QR factorization as
\f[
M=QR
\f]
where
\f$M\f$ is calling matrix, orthogonal matrix \f$Q\f$
and upper triangular (trapezoidal) matrix \f$R\f$ are \c mQ and \c mR output parameters
respectively. This version implements so-called "full" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times m\f$ matrix \f$Q\f$ and \f$m\times n\f$ matrix \f$R\f$.
See also \ref qr(basic_cmatrix<TR,TC>&,basic_scmatrix<TR,TC>&)const  "economy" version.
Function throws \ref cvmexception in case if inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal ar[] = {1., 2., 3., 4., 5., 6.};
treal ai[] = {1., -1., 2., -2., 3., -3.};
const cvm::cmatrix mh(ar, ai, 2, 3);
const cvm::cmatrix mv(ar, ai, 3, 2);
cvm::scmatrix s2(2), s3(3);
cvm::cmatrix  h(2,3), v(3,2);

mh.qr(h,s3);
std::cout << (eye_complex(2)-~cmatrix(h,1,1,2,2)*cmatrix(h,1,1,2,2)).norm()
          << " " << (mh - h * s3).norm() << std::endl;
mh.qr(s2,h);
std::cout << (eye_complex(2) - ~s2 * s2).norm()
          << " " << (mh - s2 * h).norm() << std::endl;
mv.qr(v,s2);
std::cout << (eye_complex(2) - ~v * v).norm()
          << " " << (mv - v * s2).norm() << std::endl;
mv.qr(s3,v);
std::cout << (eye_complex(3) - ~s3 * s3).norm()
          << " " << (mv - s3 * v).norm() << std::endl;
\endcode
prints
\code
+2.5145832e-16 +1.3506446e-15
+2.5145832e-16 +1.3506446e-15
+2.5367068e-16 +1.4432899e-15
+3.8435519e-16 +1.4432899e-15
\endcode
@param[out] mQ \ref scmatrix \f$Q\f$.
@param[out] mR \ref cmatrix \f$R\f$.
*/
    void qr(basic_scmatrix<TR,TC>& mQ, basic_cmatrix<TR,TC>& mR) const {
        this->_qr_sr(mQ, mR);
    }

// LQ factorization
// Case 1: "economy" mode, A is (m x n) and L is (m x m) and Q is (m x n)
/**
@brief LQ factorization ("economy" mode)

Computes LQ factorization as
\f[
M=LQ
\f]
where \f$M\f$ is calling matrix, lower triangular (trapezoidal) matrix \f$L\f$
and orthogonal matrix \f$Q\f$ are \c mL and \c mQ output parameters respectively.
This version implements so-called "economy" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times m\f$ matrix \f$L\f$
and \f$m\times n\f$ matrix \f$Q\f$. See also \ref lq(basic_cmatrix<TR,TC>&,basic_scmatrix<TR,TC>&)const  "full" version.
Function throws \ref cvmexception in case of inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal ar[] = {1., 2., 3., 4., 5., 6.};
treal ai[] = {1., -1., 2., -2., 3., -3.};
const cvm::cmatrix mh(ar, ai, 2, 3);
const cvm::cmatrix mv(ar, ai, 3, 2);
cvm::scmatrix s2(2), s3(3);
cvm::cmatrix  h(2,3), v(3,2);

mh.lq(s2,h);
std::cout << (eye_complex(2) - h * ~h).norm() << " " << (mh - s2 * h)
             .norm() << std::endl;
mv.lq(s3,v);
std::cout << (eye_complex(2) - ~cmatrix(v,1,1,2,2) * cmatrix(v,1,1,2,2))
             .norm() << " " << (mv - s3 * v).norm() << std::endl;
mh.lq(h,s3);
std::cout << (eye_complex(3) - s3 * ~s3).norm() << " " << (mh - h * s3)
             .norm() << std::endl;
mv.lq(v,s2);
std::cout << (eye_complex(2) - s2 * ~s2).norm() << " " << (mv - v * s2)
             .norm() << std::endl;
\endcode
prints
\code
+1.3374617e-015 +7.4806297e-015
+6.6728929e-016 +2.9205408e-015
+1.4349634e-015 +7.4806297e-015
+6.7217793e-016 +2.9205408e-015
\endcode
@param[out] mL \ref scmatrix \f$L\f$.
@param[out] mQ \ref cmatrix \f$Q\f$.
*/
    void lq(basic_scmatrix<TR,TC>& mL, basic_cmatrix<TR,TC>& mQ) const {
        this->_lq_sr(mL, mQ);
    }

// Case 2: full mode, A is (m x n) and L is (m x n) and Q is (n x n)
/**
@brief LQ factorization ("full" mode)

Computes LQ factorization as
\f[
M=LQ
\f]
where \f$M\f$ is calling matrix, lower triangular (trapezoidal) matrix \f$L\f$
and orthogonal matrix \f$Q\f$ are \c mL and \c mQ output parameters respectively.
This version implements so-called "full" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times n\f$ matrix \f$L\f$ and \f$n\times n\f$ matrix \f$Q\f$.
See also \ref lq(basic_scmatrix<TR,TC>&,basic_cmatrix<TR,TC>&)const  "economy" version.
Function throws \ref cvmexception in case of inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal ar[] = {1., 2., 3., 4., 5., 6.};
treal ai[] = {1., -1., 2., -2., 3., -3.};
const cvm::cmatrix mh(ar, ai, 2, 3);
const cvm::cmatrix mv(ar, ai, 3, 2);
cvm::scmatrix s2(2), s3(3);
cvm::cmatrix  h(2,3), v(3,2);

mh.lq(s2,h);
std::cout << (eye_complex(2) - h * ~h).norm() << " " << (mh - s2 * h)
             .norm() << std::endl;
mv.lq(s3,v);
std::cout << (eye_complex(2) - ~cmatrix(v,1,1,2,2) * cmatrix(v,1,1,2,2))
             .norm() << " " << (mv - s3 * v).norm() << std::endl;
mh.lq(h,s3);
std::cout << (eye_complex(3) - s3 * ~s3).norm() << " " << (mh - h * s3)
             .norm() << std::endl;
mv.lq(v,s2);
std::cout << (eye_complex(2) - s2 * ~s2).norm() << " " << (mv - v * s2)
             .norm() << std::endl;
\endcode
prints
\code
+1.3374617e-015 +7.4806297e-015
+6.6728929e-016 +2.9205408e-015
+1.4349634e-015 +7.4806297e-015
+6.7217793e-016 +2.9205408e-015
\endcode
@param[out] mL \ref cmatrix \f$L\f$.
@param[out] mQ \ref scmatrix \f$Q\f$.
*/
    void lq(basic_cmatrix<TR,TC>& mL, basic_scmatrix<TR,TC>& mQ) const {
        this->_lq_rs(mL, mQ);
    }

// RQ factorization
// Case 1: "ecomomy" mode, A is (m x n) and R is (m x m) and Q is (m x n)
/**
@brief RQ factorization ("economy" mode)

Computes RQ factorization as
\f[
M=RQ
\f]
where \f$M\f$ is calling matrix, upper triangular matrix \f$R\f$
and orthogonal matrix \f$Q\f$ are \c mR and \c mQ output parameters respectively.
This version implements so-called "economy" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times m\f$ matrix \f$R\f$
and \f$m\times n\f$ matrix \f$Q\f$. See also \ref rq(basic_cmatrix<TR,TC>&,basic_scmatrix<TR,TC>&)const  "full" version.
Following <a href="http://www.netlib.org/scalapack/slug/node57.html" target="_blank">this definition</a>
the implementation assumes that \f$m\le n\f$ is satisfied and throws \ref cvmexception otherwise.
Function also throws \ref cvmexception in case of inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal ar[] = {1., 2., 3., 4., 5., 6.};
treal ai[] = {1., -1., 2., -2., 3., -3.};
const cvm::cmatrix mh(ar, ai, 2, 3);
const cvm::cmatrix mv(ar, ai, 3, 2);
cvm::scmatrix s2(2), s3(3);
cvm::cmatrix  h(2,3), v(3,2);

mh.rq(h,s3);
std::cout << (eye_complex(2) - cmatrix(s3,2,1,2,3) * ~cmatrix(s3,2,1,2,3))
             .norm() << " " << (mh - h * s3).norm() << std::endl;
mh.rq(s2,h);
std::cout << (eye_complex(2) - h * ~h).norm()
          << " " << (mh - s2 * h).norm() << std::endl;
\endcode
prints
\code
+3.1898416e-016 +2.2342807e-015
+3.1898416e-016 +2.2342807e-015
\endcode
@param[out] mR \ref scmatrix \f$R\f$.
@param[out] mQ \ref cmatrix \f$Q\f$.
*/
    void rq(basic_scmatrix<TR,TC>& mR, basic_cmatrix<TR,TC>& mQ) const {
        this->_rq_sr(mR, mQ);
    }

// Case 2: full mode, A is (m x n) and R is (m x n) and Q is (n x n)
/**
@brief RQ factorization ("full" mode)

Computes RQ factorization as
\f[
M=RQ
\f]
where \f$M\f$ is calling matrix, upper triangular matrix \f$R\f$
and orthogonal matrix \f$Q\f$ are \c mR and \c mQ output parameters respectively.
This version implements so-called "full" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times n\f$ matrix \f$R\f$ and \f$n\times n\f$ matrix \f$Q\f$.
See also \ref rq(basic_scmatrix<TR,TC>&,basic_cmatrix<TR,TC>&)const  "economy" version.
Following <a href="http://www.netlib.org/scalapack/slug/node57.html" target="_blank">this definition</a>
the implementation assumes that \f$m\le n\f$ is satisfied and throws \ref cvmexception otherwise.
Function also throws \ref cvmexception in case of inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal ar[] = {1., 2., 3., 4., 5., 6.};
treal ai[] = {1., -1., 2., -2., 3., -3.};
const cvm::cmatrix mh(ar, ai, 2, 3);
const cvm::cmatrix mv(ar, ai, 3, 2);
cvm::scmatrix s2(2), s3(3);
cvm::cmatrix  h(2,3), v(3,2);

mh.rq(h,s3);
std::cout << (eye_complex(2) - cmatrix(s3,2,1,2,3) * ~cmatrix(s3,2,1,2,3))
             .norm() << " " << (mh - h * s3).norm() << std::endl;
mh.rq(s2,h);
std::cout << (eye_complex(2) - h * ~h).norm()
          << " " << (mh - s2 * h).norm() << std::endl;
\endcode
prints
\code
+3.1898416e-016 +2.2342807e-015
+3.1898416e-016 +2.2342807e-015
\endcode
@param[out] mR \ref cmatrix \f$R\f$.
@param[out] mQ \ref scmatrix \f$Q\f$.
*/
    void rq(basic_cmatrix<TR,TC>& mR, basic_scmatrix<TR,TC>& mQ) const {
        this->_rq_rs(mR, mQ);
    }

// QL factorization
// Case 1: "ecomomy" mode, A is (m x n) and Q is (m x n) and L is (n x n)
/**
@brief QL factorization ("economy" mode)

Computes QL factorization as
\f[
M=QL
\f]
where \f$M\f$ is calling matrix, orthogonal matrix \f$Q\f$
and lower triangular matrix \f$L\f$ are \c mQ and \c mL output parameters respectively.
This version implements so-called "economy" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times n\f$ matrix \f$Q\f$
and \f$n\times n\f$ matrix \f$L\f$. See also \ref ql(basic_scmatrix<TR,TC>&,basic_cmatrix<TR,TC>&)const  "full" version.
Following <a href="http://www.netlib.org/scalapack/slug/node57.html" target="_blank">this definition</a>
the implementation assumes that \f$m\ge n\f$ is satisfied and throws \ref cvmexception otherwise.
Function also throws \ref cvmexception in case of inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal ar[] = {1., 2., 3., 4., 5., 6.};
treal ai[] = {1., -1., 2., -2., 3., -3.};
const cvm::cmatrix mv(ar, ai, 3, 2);
cvm::scmatrix s2(2), s3(3);
cvm::cmatrix v(3,2);

mv.ql(v,s2);
std::cout << (eye_complex(2) - ~v * v).norm()
          << " " << (mv - v * s2).norm() << std::endl;
mv.ql(s3,v);
std::cout << (eye_complex(2) - ~cmatrix(s3,1,2,3,2) * cmatrix(s3,1,2,3,2))
             .norm() << " " << (mv - s3 * v).norm() << std::endl;
\endcode
prints
\code
+1.1857187e-016 +9.4857497e-016
+1.1857187e-016 +9.4857497e-016
\endcode
@param[out] mQ \ref cmatrix \f$Q\f$.
@param[out] mL \ref scmatrix \f$L\f$.
*/
    void ql(basic_cmatrix<TR,TC>& mQ, basic_scmatrix<TR,TC>& mL) const {
        this->_ql_rs(mQ, mL);
    }

// Case 2: full mode, A is (m x n) and Q is (m x m) and L is (m x n)
/**
@brief QL factorization ("full" mode)

Computes QL factorization as
\f[
M=QL
\f]
where \f$M\f$ is calling matrix, orthogonal matrix \f$Q\f$
and lower triangular matrix \f$L\f$ are \c mQ and \c mL output parameters respectively.
This version implements so-called "full" algorithm
which for given \f$m\times n\f$ matrix \f$M\f$ computes \f$m\times m\f$ matrix \f$Q\f$ and \f$m\times n\f$ matrix \f$L\f$.
See also \ref ql(basic_cmatrix<TR,TC>&,basic_scmatrix<TR,TC>&)const  "economy" version.
Following <a href="http://www.netlib.org/scalapack/slug/node57.html" target="_blank">this definition</a>
the implementation assumes that \f$m\ge n\f$ is satisfied and throws \ref cvmexception otherwise.
Function also throws \ref cvmexception in case of inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal ar[] = {1., 2., 3., 4., 5., 6.};
treal ai[] = {1., -1., 2., -2., 3., -3.};
const cvm::cmatrix mv(ar, ai, 3, 2);
cvm::scmatrix s2(2), s3(3);
cvm::cmatrix v(3,2);

mv.ql(v,s2);
std::cout << (eye_complex(2) - ~v * v).norm()
          << " " << (mv - v * s2).norm() << std::endl;
mv.ql(s3,v);
std::cout << (eye_complex(2) - ~cmatrix(s3,1,2,3,2) * cmatrix(s3,1,2,3,2))
             .norm() << " " << (mv - s3 * v).norm() << std::endl;
\endcode
prints
\code
+1.1857187e-016 +9.4857497e-016
+1.1857187e-016 +9.4857497e-016
\endcode
@param[out] mQ \ref scmatrix \f$Q\f$.
@param[out] mL \ref cmatrix \f$L\f$.
*/
    void ql(basic_scmatrix<TR,TC>& mQ, basic_cmatrix<TR,TC>& mL) const {
        this->_ql_sr(mQ, mL);
    }

// this += alpha * v_col * v_row (unconjugated)
/**
@brief Rank-1 update matrix-vector operation (unconjugated)

Calls one of \c ZGER routines of the \c BLAS library
performing rank-1 update matrix-vector operation defined as
\f[
M=\alpha\,\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_m
\end{pmatrix}
\begin{pmatrix}
y_1 & y_2 & \cdots & y_n
\end{pmatrix} + M,
\f]
where \f$\alpha\f$ is complex number (parameter \c dAlpha),
\f$M\f$ is calling matrix and \f$x\f$ and \f$y\f$ are complex vectors (parameters \c vCol and \c vRow respectively).
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
Function is <b>not applicable</b> to objects of the classes \ref scbmatrix and \ref schmatrix
(i.e. \ref cvmexception would be thrown).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(5);
std::complex<double> alpha = std::complex<double>(1.2,4.11);
cmatrix m(3,2);
cvector vc(3);
cvector vr(2);
m.randomize_real(-1., 2.); m.randomize_imag(-3., 2.);
vc.randomize_real(-1., 3.); vc.randomize_imag(1., 3.);
vr.randomize_real(0., 2.); vr.randomize_imag(-1., 2.);

std::cout << m + vc.rank1update_u(vr) * alpha << std::endl;
std::cout << m.geru(alpha, vc, vr);
\endcode
prints
\code
(2.88144e+00,3.54299e+00) (-8.14760e+00,-1.03789e+00)
(6.33361e-01,3.35209e+00) (-4.81787e+00,-8.53964e+00)
(5.44811e-01,1.37156e+00) (-5.97006e+00,-5.00794e+00)

(2.88144e+00,3.54299e+00) (-8.14760e+00,-1.03789e+00)
(6.33361e-01,3.35209e+00) (-4.81787e+00,-8.53964e+00)
(5.44811e-01,1.37156e+00) (-5.97006e+00,-5.00794e+00)
\endcode
@see http://www.netlib.org/blas
@see rank1update_u()
@see basic_cvector<TR,TC>::rank1update_u()
@param[in] alpha Multiplier \f$\alpha\f$.
@param[in] vCol \ref cvector \f$x\f$.
@param[in] vRow \ref cvector \f$y\f$.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& geru(TC alpha, const CVector& vCol,
                        const CVector& vRow) {
        this->_check_geru();
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vCol.size());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), vRow.size());
        __geru<TC, basic_cmatrix, CVector>(*this, vCol, vRow, alpha);
        return *this;
    }

// this += alpha * v_col * v_row (conjugated)
/**
@brief Rank-1 update matrix-vector operation (conjugated)

Calls one of \c ZGER routines of the \c BLAS library
performing rank-1 update matrix-vector operation defined as
\f[
M=\alpha\,\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_m
\end{pmatrix}
\begin{pmatrix}
y_1^* & y_2^* & \cdots & y_n^*
\end{pmatrix} + M,
\f]
where \f$\alpha\f$ is complex number (parameter \c dAlpha),
\f$M\f$ is calling matrix and \f$x\f$ and \f$y\f$ are complex vectors (parameters \c vCol and \c vRow respectively).
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
Function is <b>not applicable</b> to objects of the classes \ref scbmatrix and \ref schmatrix
(i.e. \ref cvmexception would be thrown).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(5);
std::complex<double> alpha = std::complex<double>(1.2,4.11);
cmatrix m(3,2);
cvector vc(3);
cvector vr(2);
m.randomize_real(-1., 2.); m.randomize_imag(-3., 2.);
vc.randomize_real(-1., 3.); vc.randomize_imag(1., 3.);
vr.randomize_real(0., 2.); vr.randomize_imag(-1., 2.);

std::cout << m + vc.rank1update_c(vr) * alpha << std::endl;
std::cout << m.gerc(alpha, vc, vr);
\endcode
prints
\code
(1.27138e+01,1.58049e+01) (1.00616e+01,2.21197e+01)
(1.93326e+01,1.41763e+01) (1.74769e+01,2.49013e+01)
(8.09961e+00,1.36259e+01) (5.86738e+00,1.97800e+01)

(1.27138e+01,1.58049e+01) (1.00616e+01,2.21197e+01)
(1.93326e+01,1.41763e+01) (1.74769e+01,2.49013e+01)
(8.09961e+00,1.36259e+01) (5.86738e+00,1.97800e+01)
\endcode
@see http://www.netlib.org/blas
@see rank1update_c()
@see basic_cvector<TR,TC>::rank1update_c()
@param[in] alpha Multiplier \f$\alpha\f$.
@param[in] vCol \ref cvector \f$x\f$.
@param[in] vRow \ref cvector \f$y\f$.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& gerc(TC alpha, const CVector& vCol,
                        const CVector& vRow) {
        this->_check_gerc();
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vCol.size());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), vRow.size());
        __gerc<TC, basic_cmatrix, CVector>(*this, vCol, vRow, alpha);
        return *this;
    }

// this = alpha * m1 * m2 + beta * this
/**
@brief Generic matrix-matrix operation

Calls one of \c ZGEMM routines of the BLAS library
performing matrix-matrix operation defined as
\f[
M=\alpha\,\mathcal{T}(M_1)\cdot\mathcal{T}(M_2) + \beta M,
\f]
where \f$\alpha\f$ and \f$\beta\f$ are complex numbers
(parameters \c dAlpha and \c dBeta), \f$M\f$ is calling matrix
and \f$M_1\f$ and \f$M_2\f$ are matrices (parameters \c m1
and \c m2 respectively). Function \f$\mathcal{T}(M_i)\f$
conjugatess matrix \f$M_i\f$ if appropriate boolean
parameter \c bConj* is equal to \c true and does nothing otherwise.
Function returns a reference to the matrix changed and throws
\ref cvmexception in case of inappropriate sizes of the operands.
Function is <b>not applicable</b> to objects of the classes
\ref srbmatrix and \ref srsmatrix (i.e. exception of
type \ref cvmexception would be thrown).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    std::complex<double> alpha = std::complex<double>(1.1,2.1);
    std::complex<double> beta = std::complex<double>(0.71,0.12);
    cmatrix m1(4,3); cmatrix m2(4,3);
    cmatrix m(3,3);
    m.randomize_real(-1., 2.); m.randomize_imag(1., 3.);
    m1.randomize_real(-1., 3.); m1.randomize_imag(-2., 4.);
    m2.randomize_real(0., 2.); m2.randomize_imag(-3., 2.);

    std::cout << ~m1 * m2 * alpha + m * beta << std::endl;
    std::cout << m.gemm(m1, true, m2, false, alpha, beta);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(3.225e+01,3.611e+01) (2.042e+01,1.206e+01) (5.065e+01,-2.261e+01)
(3.009e+01,3.665e+00) (2.167e+01,-3.327e+00) (4.305e+01,-1.960e+01)
(1.156e+01,-4.966e+00) (4.067e+00,-1.181e+01) (1.121e+01,-2.684e+01)

(3.225e+01,3.611e+01) (2.042e+01,1.206e+01) (5.065e+01,-2.261e+01)
(3.009e+01,3.665e+00) (2.167e+01,-3.327e+00) (4.305e+01,-1.960e+01)
(1.156e+01,-4.966e+00) (4.067e+00,-1.181e+01) (1.121e+01,-2.684e+01)
\endcode
@see http://www.netlib.org/blas
@param[in] m1 \ref cmatrix \f$M_1\f$.
@param[in] bConj1 Conjugate \ref cmatrix \f$M_1\f$.
@param[in] m2 \ref cmatrix \f$M_2\f$.
@param[in] bConj2 Conjugate \ref cmatrix \f$M_2\f$.
@param[in] cAlpha Multiplier \f$\alpha\f$.
@param[in] cBeta Multiplier \f$\beta\f$.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& gemm(const basic_cmatrix& m1, bool bConj1, const basic_cmatrix& m2,
                        bool bConj2, TC cAlpha, TC cBeta) {
        this->_check_gemm();
        _check_ne(CVM_SIZESMISMATCH, this->msize(), bConj1 ? m1.nsize() : m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), bConj2 ? m2.msize() : m2.nsize());
        _check_ne(CVM_SIZESMISMATCH,
                  bConj1 ? m1.msize() : m1.nsize(),
                  bConj2 ? m2.nsize() : m2.msize());
        this->_gemm(bConj1, m1, bConj2, m2, cAlpha, cBeta);
        return *this;
    }

// this = alpha*a*b + beta*this of this = alpha*b*a + beta*this  where a is Hermitian
/**
@brief Generic Hermitian matrix-matrix operation

Calls one of \c ZHEMM routines of the BLAS library performing one of
matrix-matrix operations defined as
\f[
M=\alpha\,M_s\cdot M_1 + \beta M\quad\text{or}\quad M=\alpha\,M_1\cdot M_s + \beta M,
\f]
where \f$\alpha\f$ and \f$\beta\f$ are complex numbers
(parameters \c cAlpha and \c cBeta), \f$M\f$ is calling matrix,
\f$M_s\f$ is Hermitian matrix and \f$M_1\f$ is complex matrix (parameters \c ms
and \c m respectively).
First operation is performed if \c bLeft passed is \c true and second one otherwise.
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
Function is <b>not applicable</b> to objects of the class \ref scbmatrix
(i.e. \ref cvmexception would be thrown).
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
try {
    std::complex<double> alpha = std::complex<double>(1.3,0.21);
    std::complex<double> beta = std::complex<double>(0.5,-0.1);
    cmatrix m1(2,3);
    cmatrix m2(3,2);
    schmatrix ms(2);
    cmatrix m(2,3);
    m.randomize_real(-1., 2.); m.randomize_imag(1., 3.);
    m1.randomize_real(-1., 3.); m1.randomize_imag(1., 2.);
    m2.randomize_real(0., 2.); m2.randomize_imag(-3., -1.);
    ms.randomize_real(-3., 1.); ms.randomize_imag(-1.3, 4.);

    std::cout << ms * m1 * alpha + m * beta << std::endl;
    std::cout << m.hemm(true, ms, m1, alpha, beta) << std::endl;

    m.resize(3,2);
    m.randomize_real(-1.4, 1.3); m.randomize_imag(1.1, 3.);
    std::cout << m2 * ms * alpha + m * beta << std::endl;
    std::cout << m.hemm(false, ms, m2, alpha, beta);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1.096e+00,-7.692e+00) (-7.923e+00,-3.909e+00) (-1.324e+01,-5.264e+00)
(2.415e+00,1.240e+00) (4.384e-01,-1.771e+00) (7.495e-01,-2.740e+00)

(1.096e+00,-7.692e+00) (-7.923e+00,-3.909e+00) (-1.324e+01,-5.264e+00)
(2.415e+00,1.240e+00) (4.384e-01,-1.771e+00) (7.495e-01,-2.740e+00)

(-5.007e+00,1.010e+01) (2.341e+00,3.248e+00)
(-8.753e+00,7.854e+00) (3.152e+00,4.491e+00)
(-9.162e+00,6.401e+00) (-1.168e+00,3.973e+00)

(-5.007e+00,1.010e+01) (2.341e+00,3.248e+00)
(-8.753e+00,7.854e+00) (3.152e+00,4.491e+00)
(-9.162e+00,6.401e+00) (-1.168e+00,3.973e+00)
\endcode
@see http://www.netlib.org/blas
@param[in] bLeft Perfoem left-side operation.
@param[in] ms \ref schmatrix \f$M_s\f$.
@param[in] m \ref cmatrix \f$M_1\f$.
@param[in] cAlpha Multiplier \f$\alpha\f$.
@param[in] cBeta Multiplier \f$\beta\f$.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& hemm(bool bLeft, const basic_schmatrix<TR,TC>& ms,
                        const basic_cmatrix& m,
                        TC cAlpha, TC cBeta) {
        this->_check_hemm();
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.nsize());
        _check_ne(CVM_SIZESMISMATCH,
                  bLeft ? this->msize() : this->nsize(), ms.msize());
        this->_hemm(bLeft, ms, m, cAlpha, cBeta);
        return *this;
    }

/**
@brief Set matrix to zero

Sets every element of a calling matrix to be equal to zero
and returns a reference to the matrix changed. This function is faster
than, for example, set(TC) with zero parameter passed.
\par Example:
\code
using namespace cvm;
cmatrix m(4, 3);
m.randomize_real(0.,1.);
m.randomize_imag(1.,2.);
std::cout << m << std::endl;
std::cout << m.vanish();
\endcode
prints
\code
(0.851527,1.16376) (0.557512,1.90188) (0.0343638,1.52068)
(0.478042,1.29106) (0.561724,1.19764) (0.320994,1.35804)
(0.264534,1.40986) (0.113468,1.75137) (0.37727,1.54994)
(0.521409,1.83035) (0.559465,1.35072) (0.809198,1.12537)

(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
@return Reference to changed calling matrix.
*/
    basic_cmatrix& vanish() {
        this->_vanish();
        return *this;
    }

/**
@brief Randomizer (real part)

Fills real part of a calling complex matrix with pseudo-random numbers distributed between \c dFrom and \c dTo.
It returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
cmatrix m(2,3);
m.randomize_real(-1., 2.);
std::cout << m;
\endcode
prints
\code
(1.090e+00,0.000e+00) (-6.375e-01,0.000e+00) (1.248e+00,0.000e+00)
(-1.272e-01,0.000e+00) (-8.557e-01,0.000e+00) (4.848e-01,0.000e+00)
\endcode
@param[in] dFrom First limit.
@param[in] dTo Second limit.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& randomize_real(TR dFrom, TR dTo) {
        this->_randomize_real(dFrom, dTo);
        return *this;
    }

/**
@brief Randomizer (imaginary part)

Fills imaginary part of a calling complex matrix with pseudo-random numbers distributed between \c dFrom and \c dTo.
It returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);
cmatrix m(2,3);
m.randomize_imag(-1., 2.);
std::cout << m;
\endcode
prints
\code
(0.000e+00,1.113e+00) (0.000e+00,6.615e-01) (0.000e+00,1.017e+00)
(0.000e+00,-3.397e-01) (0.000e+00,1.577e+00) (0.000e+00,8.071e-01)
\endcode
@param[in] dFrom First limit.
@param[in] dTo Second limit.
@return Reference to changed calling matrix.
*/
    basic_cmatrix& randomize_imag(TR dFrom, TR dTo) {
        this->_randomize_imag(dFrom, dTo);
        return *this;
    }

    // 2-norm (maximum singular value)
    [[nodiscard]] TR norm2() const override {
        RVector vS(_cvm_min<tint>(this->msize(), this->nsize()));
        this->_svd(vS, nullptr, nullptr);
        return vS[0];
    }

//! @cond INTERNAL
    void _div(TC d) {
        if (std::abs(d) <= basic_cvmMachMin<TR>()) {
            throw cvmexception(CVM_DIVISIONBYZERO);
        }
        const TC one(1., 0.);
        this->_scalc(one / d);
    }

    // ?gemm routines perform a matrix-matrix operation with general matrices. The operation is defined as
    // c := alpha*op(a)*op(b) + beta*c,
    // where: op(x) is one of op(x) = x or op(x) = x' or op(x) = conjg(x'),
    void _gemm(bool bTrans1, const basic_cmatrix& m1, bool bTrans2,
               const basic_cmatrix& m2, TC dAlpha, TC dBeta) {
        basic_cmatrix mTmp1, mTmp2;
        const TC* pD1 = m1.get();
        const TC* pD2 = m2.get();
        if (this->get() == pD1) mTmp1 << m1;
        if (this->get() == pD2) mTmp2 << m2;
        __gemm<TC, basic_cmatrix>(this->get() == pD1 ? mTmp1 : m1, bTrans1,
                                  this->get() == pD2 ? mTmp2 : m2, bTrans2,
                                  dAlpha, *this, dBeta);
    }

    // this = alpha*a*b + beta*this or this = alpha*b*a + beta*this  where a is Hermitian
    void _hemm(bool bLeft, const basic_schmatrix<TR,TC>& ms,
               const basic_cmatrix& m, TC dAlpha, TC dBeta) {
        basic_cmatrix mTmp;
        basic_schmatrix<TR,TC> msTmp;
        const TC* pD1 = ms.get();
        const TC* pD2 = m._pd();
        if (this->get() == pD1) msTmp << ms;
        if (this->get() == pD2) mTmp << m;
        __hemm<TC, basic_schmatrix<TR,TC>,
            basic_cmatrix>(bLeft, this->get() == pD1 ? msTmp : ms,
                                  this->get() == pD2 ? mTmp : m,
                           dAlpha, *this, dBeta);
    }

    // singular values in decreasing order
    virtual void _svd(RVector& vRes,
                      basic_scmatrix<TR,TC>* pmU,
                      basic_scmatrix<TR,TC>* pmVH) const {
        if (pmU != nullptr && pmVH != nullptr) {
            _check_ne(CVM_SIZESMISMATCH, this->msize(), pmU->msize());
            _check_ne(CVM_SIZESMISMATCH, this->nsize(), pmVH->msize());
        }
        __svd<TR,basic_cmatrix,
            basic_scmatrix<TR,TC>> (vRes, vRes.size(), vRes.incr(), *this, pmU, pmVH);
    }

    virtual void _pinv(basic_cmatrix& mX, TR threshold) const {
        __pinv<TR,basic_cmatrix, basic_cmatrix>(mX, *this, threshold);
    }

    virtual void _check_submatrix() const {
    }

    virtual void _scalc(TC d) {
        if (this->_continuous()) {
            __scal<TC,TC>(this->get(), this->size(), this->incr(), d);
        } else for (tint i = 0; i < this->nsize(); ++i) {
            __scal<TC,TC>(this->get() + this->ld() * i, this->msize(), this->incr(), d);
        }
    }

protected:
    // protected constructors for inherited stuff
    basic_cmatrix(tint nM, tint nN, tint nLD, bool bZeroMemory)
      : BaseMatrix(nM, nN, nLD, bZeroMemory)
    {}

    basic_cmatrix(tint size, tint incr, tint msize, tint nsize, tint ld)
      : BaseMatrix(size, incr, msize, nsize, ld)
    {}

    // non-const version shares memory
    basic_cmatrix(TC* pd, tint nM, tint nN, tint nLD, tint nSize)
      : BaseMatrix(pd, nM, nN, nLD, nSize)
    {}

    // const version makes a copy
    basic_cmatrix(const TC* pd, tint nM, tint nN, tint nLD, tint nSize)
      : BaseMatrix(pd, nM, nN, nLD, nSize)
    {}

    virtual CVector _diag(tint nDiag) {
        tint nShift = 0;
        tint nSize = 0;
        this->_diag_helper(nDiag, nShift, nSize);
        return CVector(this->get() + nShift, nSize, this->ld() + 1);
    }

    [[nodiscard]] virtual CVector _diag(tint nDiag) const {
        tint nShift = 0;
        tint nSize = 0;
        this->_diag_helper(nDiag, nShift, nSize);
        return CVector(this->get() + nShift, nSize, this->ld() + 1);
    }

    // compares matrix elements (equal sizes assumed)
    [[nodiscard]] bool _mequals(const basic_cmatrix& m) const {
        return ((*this) - m).norminf() <= basic_cvmMachMin<TR>();
    }

    // ?gemv routines perform a matrix-vector operation defined as
    // vRes = alpha*m*v + beta * vRes or vRes = alpha*v'*m + beta * vRes
    // not virtual since __gemv calls all virtual methods inside
    void _gemv(bool bLeft, TC dAlpha, const CVector& v, TC dBeta, CVector& vRes) const {
        CVector vTmp;
        basic_cmatrix mTmp;
        const TC* pDv = v;
        if (vRes.get() == pDv) vTmp << v;
        if (vRes.get() == this->get()) mTmp << *this;
        __gemv<TC, basic_cmatrix,
            CVector>(bLeft,
                     vRes.get() == this->get() ? mTmp : *this, dAlpha,
                     vRes.get() == pDv ? vTmp : v, dBeta, vRes);
    }

    // 0-based, returns an l-value sharing memory
    virtual CVector _row(tint m) {
        return CVector(this->get() + m, this->nsize(), this->ld());
    }

    // 0-based, returns not an l-value (copy)
    [[nodiscard]] virtual CVector _row(tint m) const {
        return CVector(this->get() + m, this->nsize(), this->ld());
    }

    // 0-based, returns an l-value sharing memory
    virtual CVector _col(tint n) {
        return CVector(this->get() + this->ld() * n, this->msize());
    }

    // 0-based, returns not an l-value (copy)
    [[nodiscard]] virtual CVector _col(tint n) const {
        return CVector(this->get() + this->ld() * n, this->msize());
    }

    virtual void _mult(const basic_cmatrix& m1,
                       const basic_cmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m2.nsize());
        _check_ne(CVM_SIZESMISMATCH, m1.nsize(), m2.msize());
        const TR zero = TR(0.);
        const TR one = TR(1.);
        this->_gemm(false, m1, false, m2, one, zero);
    }

    virtual void _multiply(CVector& vRes,
                           const CVector& v, bool bLeft) const {
        const TR zero = TR(0.);
        const TR one = TR(1.);
        this->_gemv(bLeft, one, v, zero, vRes);
    }

    void _set_real_number(TR d) {
        if (this->_continuous()) {
            _set_real<TR,TC>(this->get(), this->size(), this->incr(), d);
        } else for (tint i = 0; i < this->nsize(); ++i) {
            _set_real<TR,TC>(this->get() + this->ld() * i, this->msize(), this->incr(), d);
        }
    }

    virtual void _set_imag_number(TR d) {
        if (this->_continuous()) {
            _set_imag<TR,TC>(this->get(), this->size(), this->incr(), d);
        } else for (tint i = 0; i < this->nsize(); ++i) {
            _set_imag<TR,TC>(this->get() + this->ld() * i, this->msize(), this->incr(), d);
        }
    }

    virtual void _randomize_real(TR dFrom, TR dTo) {
        if (this->_continuous()) {
            __randomize_real<TC,TR>(this->get(), this->size(), this->incr(), dFrom, dTo);
        } else for (tint i = 0; i < this->nsize(); ++i) {
            __randomize_real<TC,TR>(this->get() + this->ld() * i, this->msize(), this->incr(), dFrom, dTo);
        }
    }

    virtual void _randomize_imag(TR dFrom, TR dTo) {
        if (this->_continuous()) {
            __randomize_imag<TC,TR>(this->get(), this->size(), this->incr(), dFrom, dTo);
        } else for (tint i = 0; i < this->nsize(); ++i) {
            __randomize_imag<TC,TR>(this->get() + this->ld() * i, this->msize(), this->incr(), dFrom, dTo);
        }
    }

    // QR factorization
    // Case 1: "economy" mode, A is (m x n) and Q is (m x n) and R is (n x n)
    void _qr_rs(basic_cmatrix<TR,TC>& mQ, basic_scmatrix<TR,TC>& mR) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mQ.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mR.msize());
        __qre<basic_cmatrix, basic_scmatrix<TR,TC>> (*this, mQ, mR);
    }

    // Case 2: full mode, A is (m x n) and Q is (m x m) and R is (m x n)
    void _qr_sr(basic_scmatrix<TR,TC>& mQ, basic_cmatrix<TR,TC>& mR) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mR.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mR.nsize());
        __qrf<basic_cmatrix, basic_scmatrix<TR,TC>> (*this, mQ, mR);
    }

    // RQ factorization
    // Case 1: "economy" mode, A is (m x n) and R is (m x m) and Q is (m x n)
    void _rq_sr(basic_scmatrix<TR,TC>& mR, basic_cmatrix<TR,TC>& mQ) const {
        _check_gt(CVM_SIZESMISMATCH_GT, this->msize(), this->nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mQ.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mR.msize());
        __rqe<basic_cmatrix, basic_scmatrix<TR,TC>> (*this, mR, mQ);
    }

    // Case 2: full mode, A is (m x n) and R is (m x n) and Q is (n x n)
    void _rq_rs(basic_cmatrix<TR,TC>& mR, basic_scmatrix<TR,TC>& mQ) const {
        _check_gt(CVM_SIZESMISMATCH_GT, this->msize(), this->nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mR.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mR.nsize());
        __rqf<basic_cmatrix, basic_scmatrix<TR,TC>> (*this, mR, mQ);
    }

    // LQ factorization
    // Case 1: "economy" mode, A is (m x n) and L is (m x m) and Q is (m x n)
    void _lq_sr(basic_scmatrix<TR,TC>& mL, basic_cmatrix<TR,TC>& mQ) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mL.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mQ.nsize());
        __lqe<basic_cmatrix, basic_scmatrix<TR,TC>> (*this, mL, mQ);
    }

    // Case 2: full mode, A is (m x n) and L is (m x n) and Q is (n x n)
    void _lq_rs(basic_cmatrix<TR,TC>& mL, basic_scmatrix<TR,TC>& mQ) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mL.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mL.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mQ.nsize());
        __lqf<basic_cmatrix, basic_scmatrix<TR,TC>> (*this, mL, mQ);
    }

    // QL factorization
    // Case 1: "economy" mode, A is (m x n) and Q is (m x n) and L is (n x n)
    void _ql_rs(basic_cmatrix<TR,TC>& mQ, basic_scmatrix<TR,TC>& mL) const {
        _check_lt(CVM_SIZESMISMATCH_LT, this->msize(), this->nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mQ.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mL.msize());
        __qle<basic_cmatrix, basic_scmatrix<TR,TC>> (*this, mQ, mL);
    }

    // Case 2: full mode, A is (m x n) and Q is (m x m) and L is (m x n)
    void _ql_sr(basic_scmatrix<TR,TC>& mQ, basic_cmatrix<TR,TC>& mL) const {
        _check_lt(CVM_SIZESMISMATCH_LT, this->msize(), this->nsize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mL.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mL.nsize());
        __qlf<basic_cmatrix, basic_scmatrix<TR,TC>> (*this, mQ, mL);
    }

    virtual void _check_geru() { }
    virtual void _check_gerc() { }
    virtual void _check_rank1update_u() { }
    virtual void _check_rank1update_c() { }
    virtual void _check_gemm() { }
    virtual void _check_hemm() { }

private:
    basic_cmatrix& _solve_helper(const basic_scmatrix<TR,TC>& mA,
                                 const basic_cmatrix& mB,
                                 TR& dErr, int transp_mode) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mA.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mB.nsize());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), mB.msize());
        mA._solve(mB, *this, dErr, nullptr, nullptr, transp_mode);
        return *this;
    }

    // helper for svd and divide&conquer methods
    basic_cmatrix _gels_sd(bool svd, const basic_cmatrix& mB, basic_rvector<TR>& sv,
                           tint& rank, TR tol) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mB.msize());
        _check_ne(CVM_SIZESMISMATCH, _cvm_min<tint>(this->msize(), this->nsize()), sv.size());
        basic_cmatrix mA(*this);  // this algorithm overrides A
        basic_cmatrix mX;
        basic_rvector<TR> sv1(sv.size());  // to ensure that incr=1
        if (svd) {
            __gelss(mA, mB, mX, tol, sv1, rank);
        } else {
            __gelsd(mA, mB, mX, tol, sv1, rank);
        }
        sv = sv1;
        return mX;
    }

    void _gels_sd(bool svd, const basic_cmatrix& mA, const basic_cmatrix& mB,
                  basic_rvector<TR>& sv,
                  tint& rank, TR tol) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mA.nsize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mB.nsize());
        _check_ne(CVM_SIZESMISMATCH, mA.msize(), mB.msize());
        _check_ne(CVM_SIZESMISMATCH, _cvm_min<tint>(mA.msize(), mA.nsize()), sv.size());
        basic_cmatrix mA2(mA);  // this algorithm overrides A
        basic_rvector<TR> sv1(sv.size());  // to ensure that incr=1
        if (svd) {
            __gelss(mA2, mB, *this, tol, sv1, rank);
        } else {
            __gelsd(mA2, mB, *this, tol, sv1, rank);
        }
        sv = sv1;
    }

    basic_cvector<TR,TC> _gels_sd(bool svd,
                                  const basic_cvector<TR,TC>& vB, basic_rvector<TR>& sv,
                                  tint& rank, TR tol) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vB.size());
        _check_ne(CVM_SIZESMISMATCH, _cvm_min<tint>(this->msize(), this->nsize()), sv.size());
        basic_cmatrix mA(*this);  // this algorithm overrides A
        basic_cmatrix mB(vB, vB.size(), 1);
        basic_cmatrix mX;
        basic_rvector<TR> sv1(sv.size());  // to ensure that incr=1
        if (svd) {
            __gelss(mA, mB, mX, tol, sv1, rank);
        } else {
            __gelsd(mA, mB, mX, tol, sv1, rank);
        }
        sv = sv1;
        const TC* pResult = mX;
        return basic_cvector<TR,TC>(pResult, mX.msize());
    }
//! @endcond
};


/**
@brief End-user class encapsulating square matrix of complex numbers

\c TR type stands for \ref treal, \c TC type stands for \ref tcomplex. Please use predefined \ref scmatrix class in your applications.
@see Matrix
*/
template<typename TR, typename TC>
class basic_scmatrix : public basic_cmatrix<TR,TC>, public SqMatrix<TR,TC>
{
    using CVector = basic_cvector<TR,TC>;  //!< \ref cvector
    using BaseArray = basic_array<TR,TC>;  //!< Base basic_array class
    using BaseMatrix = Matrix<TR,TC>;  //!< Base Matrix class
    using BaseSqMatrix = SqMatrix<TR,TC>;  //!< Base SqMatrix class
    using BaseCMatrix = basic_cmatrix<TR,TC>;  //!< \ref cmatrix

public:
/**
@brief Default constructor

Creates empty square complex matrix. No memory gets allocated.
\par Example:
\code
using namespace cvm;
scmatrix m;
std::cout << m.msize() << std::endl
          << m.nsize() << std::endl
          << m.size() << std::endl;
m.resize(3);
std::cout << m;
\endcode
prints
\code
0
0
0
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
*/
    basic_scmatrix() = default;

    ~basic_scmatrix() override = default;

/**
@brief Constructor

Creates \f$n\times n\f$ \ref scmatrix object where \f$n\f$ is passed in
\c nDim parameter. Constructor sets all elements to zero.
It throws \ref cvmexception in case of non-positive size passed or memory allocation failure.
Example:
\code
using namespace cvm;
scmatrix m(4);
std::cout << m.msize() << std::endl
          << m.nsize() << std::endl
          << m.size() << std::endl << m;
\endcode
prints
\code
4
4
16
(0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0)
\endcode
@param[in] nDim Number of rows and columns.
*/
    explicit basic_scmatrix(tint nDim)
      : BaseCMatrix(nDim, nDim)
    {}



// TODO dox, test
#if defined(CVM_USE_INITIALIZER_LISTS)
    basic_scmatrix(tint nDim, const std::initializer_list<TR>& list)
      : BaseCMatrix(nDim, nDim, list)
    {}
#endif



/**
@brief Constructor

Creates \f$n\times n\f$ \ref scmatrix object where \f$n\f$ is passed in \c nDim parameter.
It throws \ref cvmexception in case of non-positive size passed.
Unlike others, this constructor <b>does not allocate memory</b>.
It just shares memory with an array pointed to by \c pd (for matrices \c nIncr=1 is always satisfied).
\par Example:
\code
using namespace cvm;
double a[] = {1., 1., 1., 1., 1., 1., 1., 1., 1.,
              1., 1., 1., 1., 1., 1., 1., 1., 1.};
scmatrix m((std::complex<double>*) a, 3);
m(1,1) = std::complex<double>(2.,3.);
std::cout << m << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << " "
          << a[3] << " " << a[4] << " " << a[5] << " " << std::endl;
\endcode
prints
\code
(2,3) (1,1) (1,1)
(1,1) (1,1) (1,1)
(1,1) (1,1) (1,1)

2 3 1 1 1 1
\endcode
@see http://cvmlib.com/faq.htm
@see basic_cmatrix::basic_cmatrix(TC*,tint,tint)
@param[in] pd Pointer to an array to share memory with.
@param[in] nDim Number of rows and columns.
*/
    basic_scmatrix(TC* pd, tint nDim)
      : BaseCMatrix(pd, nDim, nDim)
    {}

/**
@brief Constructor

Creates \f$n\times n\f$ \ref scmatrix object where \f$n\f$ is passed in \c nDim parameter.
Constructor throws \ref cvmexception in case of non-positive sizes passed.
This is const version,
it allocates memory and copies every element (deep copy) from external array pointed to by \c pd parameter.
It copies \c nDim*nDim elements total.
\par Example:
\code
using namespace cvm;
const double a[] = {1., 1., 1., 1., 1., 1., 1., 1., 1.,
                    1., 1., 1., 1., 1., 1., 1., 1., 1.};
scmatrix m((const std::complex<double>*) a, 3);
m(1,1) = std::complex<double>(2.,3.);
std::cout << m << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << " "
          << a[3] << " " << a[4] << " " << a[5] << " " << std::endl;
\endcode
prints
\code
(2,3) (1,1) (1,1)
(1,1) (1,1) (1,1)
(1,1) (1,1) (1,1)

1 1 1 1 1 1
\endcode
@see http://cvmlib.com/faq.htm
@see basic_cmatrix::basic_cmatrix(const TC*,tint,tint)
@param[in] pd Const pointer to external array.
@param[in] nDim Number of rows and columns.
*/
    basic_scmatrix(const TC* pd, tint nDim)
      : BaseCMatrix(pd, nDim, nDim)
    {}

/**
@brief Copy constructor

Creates \ref scmatrix object as a copy of smatrix \c m.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
scmatrix m((std::complex<double>*) a, 2);
scmatrix mc(m);
m(1,1) = std::complex<double>(7.77,7.77);
std::cout << m << std::endl << mc;
\endcode
prints
\code
(7.77,7.77) (5,6)
(3,4) (7,8)

(1,2) (5,6)
(3,4) (7,8)
\endcode
@param[in] m \ref scmatrix to copy from.
*/
    basic_scmatrix(const basic_scmatrix& m)
      : BaseCMatrix(m.msize(), m.nsize(), m.msize(), false), BaseSqMatrix() {
        this->_massign(m);
    }

/**
@brief Move constructor

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to newly created object.
It's usually executed implicitly in cases like this:
\code
rvector a(b + c);
\endcode
or this
\code
rvector a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to newly created object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_scmatrix(basic_scmatrix&& m) noexcept
       : BaseCMatrix(std::move(m))
    {}

/**
@brief Constructor

Creates \ref scmatrix object as a copy of a matrix \c m.
It's assumed that \f$m\times n\f$ matrix \c m must have equal
sizes, i.e. \f$m = n\f$ is satisfied.
Constructor throws \ref cvmexception if this is not true or in case of memory allocation failure.
Please note that this constructor is <em>not explicit</em>.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.,
              7., 8., 9., 10., 11., 12.};
cmatrix m((std::complex<double>*) a, 2, 3);
std::cout << m << std::endl;
m.resize(3, 3);
scmatrix ms(m);
std::cout << ms;
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
(0,0) (0,0) (0,0)
\endcode
@param[in] m \ref cmatrix to copy from.
*/
    basic_scmatrix(const BaseCMatrix& m)
      : BaseCMatrix(m.msize(), m.nsize(), m.msize(), false) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), this->nsize());
        this->_massign(m);
    }

/**
@brief Constructor

Creates \ref scmatrix object of size \c v.size() by \c v.size()
and assigns vector \c v to its main diagonal.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
cvector v((std::complex<double>*) a, 4);
scmatrix m(v);
std::cout << m;
\endcode
prints
\code
(1,2) (0,0) (0,0) (0,0)
(0,0) (3,4) (0,0) (0,0)
(0,0) (0,0) (5,6) (0,0)
(0,0) (0,0) (0,0) (7,8)
\endcode
@param[in] v \ref cvector to copy main diagonal from.
*/
    explicit basic_scmatrix(const CVector& v)
      : BaseCMatrix(v.size(), v.size(), v.size(), true) {
        __copy<TC>(this->msize(), v, v.incr(), this->get(), this->msize() + 1);
    }

/**
@brief Constructor

Creates \ref cmatrix with the same dimensions as passed \ref srmatrix \c m
and copies matrix \c m to its real part if \c bRealPart is \c true or to its imaginary part otherwise.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
const srmatrix m(a, 3);
scmatrix mr(m), mi(m, false);
std::cout << mr << std::endl << mi;
\endcode
prints
\code
(1,0) (4,0) (7,0)
(2,0) (5,0) (8,0)
(3,0) (6,0) (9,0)

(0,1) (0,4) (0,7)
(0,2) (0,5) (0,8)
(0,3) (0,6) (0,9)
\endcode
@param[in] m \ref srmatrix to copy elements from.
@param[in] bRealPart \c true to copy \c m to real part, \c false to copy to imaginary part.
*/
    explicit basic_scmatrix(const basic_srmatrix<TR>& m, bool bRealPart = true)
      : BaseCMatrix(m.msize(), m.msize(), m.msize(), true) {
        if (bRealPart) {
            __copy2<TR,TC>(this->get(), this->size(), this->incr(), m._pd(), nullptr);
        }
        else {
            __copy2<TR,TC>(this->get(), this->size(), this->incr(), nullptr, m._pd());
        }
    }

/**
@brief Constructor

Creates \c scmatrix object of dimension \c nDim and copies every
element of an arrays pointed to by \c pRe and \c pIm to real and imaginary part
of the matrix created respectively.
Use \c nullptr pointer to fill up appropriate part with zero values.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double re[] = {1., 2., 3., 4.};
double im[] = {4., 3., 2., 1.};
scmatrix m(re, im, 2);
std::cout << m << std::endl;
re[0] = 7.777;
std::cout << m << std::endl;
const double rec[] = {1., 2., 3., 4.};
const scmatrix mc (rec, nullptr, 2);
std::cout << mc;
\endcode
prints
\code
(1,4) (3,2)
(2,3) (4,1)

(1,4) (3,2)
(2,3) (4,1)

(1,0) (3,0)
(2,0) (4,0)
\endcode
@param[in] pRe Const pointer to external \ref treal array to copy to real part.
@param[in] pIm Const pointer to external \ref treal array to copy to imaginary part.
@param[in] nDim Matrix dimension.
*/
    basic_scmatrix(const TR* pRe, const TR* pIm, tint nDim)
      : BaseCMatrix(pRe, pIm, nDim, nDim)
    {}

/**
@brief Constructor

Creates \ref scmatrix object of dimension \c mRe.msize()
(if it differs from \c mIm.msize() then constructor throws \ref cvmexception)
and copies matrices \c mRe and \c mIm to real and imaginary part of the matrix created respectively.
Constructor also throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
srmatrix mr(3), mi(3);
mr.set(1.);
mi.set(2.);
const scmatrix mc(mr, mi);
std::cout << mc;
\endcode
prints
\code
(1,2) (1,2) (1,2)
(1,2) (1,2) (1,2)
(1,2) (1,2) (1,2)
\endcode
@param[in] mRe \ref srmatrix to copy to real part.
@param[in] mIm \ref srmatrix to copy to imaginary part.
*/
    basic_scmatrix(const basic_srmatrix<TR>& mRe, const basic_srmatrix<TR>& mIm)
      : BaseCMatrix(mRe.msize(), mRe.nsize(), mRe.msize(), false) {
        _check_ne(CVM_SIZESMISMATCH, mRe.msize(), mIm.msize());
        _check_ne(CVM_SIZESMISMATCH, mRe.nsize(), mIm.nsize());
        __copy2<TR,TC>(this->get(), this->size(), this->incr(), mRe, mIm, mRe.incr(), mIm.incr());
    }

/**
@brief Submatrix constructor

Creates \ref scmatrix object as submatrix of a matrix \c m.
It means that the object created shares memory with some part
of \c m. This part is defined by its upper left corner and its dimension (parameter
\c nDim).
\par Example:
\code
using namespace cvm;
cmatrix m(4,5);
scmatrix subm(m,2,2,2);
subm.set(std::complex<double>(1.,2.));
std::cout << m;
\endcode
prints
\code
(0,0) (0,0) (0,0) (0,0) (0,0)
(0,0) (1,2) (1,2) (0,0) (0,0)
(0,0) (1,2) (1,2) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0) (0,0)
\endcode
@param[in] m Parent \ref cmatrix to attach to.
@param[in] nRow Row to start from.
@param[in] nCol Column to start from.
@param[in] nDim Dimension of square submatrix.
*/
    basic_scmatrix(BaseCMatrix& m, tint nRow, tint nCol, tint nDim)
      : BaseCMatrix(m, nRow, nCol, nDim, nDim) {
        m._check_submatrix();
    }

    // TODO dox
    // real part
    [[nodiscard]] basic_srmatrix<TR> real() const {
        basic_srmatrix<TR> mRet(this->msize());
        __copy<TR>(this->size(), __get_real_p<TR>(this->get()), this->incr() * 2, mRet, mRet.incr());
        return mRet;
    }

    // imaginary part
    [[nodiscard]] basic_srmatrix<TR> imag() const {
        basic_srmatrix<TR> mRet(this->msize());
        __copy<TR>(this->size(), __get_imag_p<TR>(this->get()), this->incr() * 2, mRet, mRet.incr());
        return mRet;
    }

/**
@brief Assignment operator

Sets every element of a calling \ref scmatrix to be equal to
appropriate element of smatrix \c m and returns a reference to
the matrix changed.
Operator throws \ref cvmexception in case of different matrix dimensions.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
    const scmatrix m1((std::complex<double>*) a, 2);
    scmatrix m2(2);
    m2 = m1;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1,2) (5,6)
(3,4) (7,8)
\endcode
@param[in] m \ref scmatrix to assign from.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& operator = (const basic_scmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        this->_massign(m);
        return *this;
    }

/**
@brief Move assignment operator

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to a calling object.
It's usually executed implicitly in cases like this:
\code
a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to a calling object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_scmatrix& operator = (basic_scmatrix&& m) noexcept {
        // size check is in BaseCMatrix
        BaseCMatrix::operator = (std::move(m));
        return *this;
    }

    // assigns vector
    basic_scmatrix& assign(const CVector& v) {
        _check_gt(CVM_SIZESMISMATCH_GT, this->size(), v.size());
        this->_assign(v, v.incr());
        return *this;
    }

    // assigns external array (nIncr = 1)
    basic_scmatrix& assign(const TC* pd) {
        this->_assign(pd, 1);
        return *this;
    }

/**
@brief Assignment to submatrix

Sets submatrix of a calling matrix beginning with row
\c nRow and column \c nCol to a matrix \c m and
returns a reference to the matrix changed. Function throws
\ref cvmexception if \c nRow or \c nCol are not positive or matrix \c m doesn't fit.
\par Example:
\code
using namespace cvm;
scmatrix m1(5);
cmatrix m2(2,3);
m1.set(std::complex<double>(1.,1.));
m2.set(std::complex<double>(2.,2.));
m1.assign(2,3,m2);
std::cout << m1;
\endcode
prints
\code
(1,1) (1,1) (1,1) (1,1) (1,1)
(1,1) (1,1) (2,2) (2,2) (2,2)
(1,1) (1,1) (2,2) (2,2) (2,2)
(1,1) (1,1) (1,1) (1,1) (1,1)
(1,1) (1,1) (1,1) (1,1) (1,1)
\endcode
@param[in] nRow Row index.
@param[in] nCol Column index.
@param[in] m Reference to \ref cmatrix to assign.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& assign(tint nRow, tint nCol, const BaseCMatrix& m) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, nRow, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, nCol, tint(), this->nsize());
        _check_gt(CVM_SIZESMISMATCH_GT, m.msize() + nRow, this->msize());
        _check_gt(CVM_SIZESMISMATCH_GT, m.nsize() + nCol, this->nsize());
        this->_assign_shifted(this->_sub_pointer_nocheck(nRow, nCol), m._pd(),
                              m.msize(), m.nsize(), m.ld());
        return *this;
    }

    // fills the content
    basic_scmatrix& set(TC c) {
        this->_set(c);
        return *this;
    }

/**
@brief Assignment to real parts

Sets real part of every element of a calling matrix to a value of
appropriate element of \ref srmatrix \c mRe and returns a reference to
the matrix changed. Function throws \ref cvmexception in case of different dimensions of the operands.
\par Example:
\code
using namespace cvm;
scmatrix mc(3);
srmatrix m(3);
m.set(1.);
mc.assign_real(m);
std::cout << mc;
\endcode
prints
\code
(1,0) (1,0) (1,0)
(1,0) (1,0) (1,0)
(1,0) (1,0) (1,0)
\endcode
@param[in] mRe \ref srmatrix to assign to real part.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& assign_real(const basic_srmatrix<TR>& mRe) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mRe.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mRe.nsize());
        __copy_real<TR,TC>(this->get(), this->size(), this->incr(), mRe._pd(), mRe.incr());
        return *this;
    }

/**
@brief Assignment to imaginary parts

Sets imaginary part of every element of a calling matrix to a value of
appropriate element of \ref srmatrix \c mRe and returns a reference to
the matrix changed. Function throws \ref cvmexception in case of different dimensions of the operands.
\par Example:
\code
using namespace cvm;
scmatrix mc(3);
srmatrix m(3);
m.set(1.);
mc.assign_imag(m);
std::cout << mc;
\endcode
prints
\code
(0,1) (0,1) (0,1)
(0,1) (0,1) (0,1)
(0,1) (0,1) (0,1)
\endcode
@param[in] mIm \ref srmatrix to assign to imaginary part.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& assign_imag(const basic_srmatrix<TR>& mIm) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mIm.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mIm.nsize());
        __copy_imag<TR,TC>(this->get(), this->size(), this->incr(), mIm._pd(), mIm.incr());
        return *this;
    }

    // fills real part
    basic_scmatrix& set_real(TR d) {
        this->_set_real_number(d);
        return *this;
    }

    // fills imaginary part
    basic_scmatrix& set_imag(TR d) {
        this->_set_imag_number(d);
        return *this;
    }

/**
@brief Changes dimension

Changes dimension of a calling square matrix to \c nNewDim
and returns a reference to the matrix changed.
In case of increasing of its size, the matrix
is filled up with zeroes.
Function throws \ref cvmexception
in case of negative dimension passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
    scmatrix m((std::complex<double>*) a, 2);
    std::cout << m << std::endl;
    m.resize(3);
    std::cout << m;
}
catch (std::exception& e) {
std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1,2) (5,6)
(3,4) (7,8)

(1,2) (5,6) (0,0)
(3,4) (7,8) (0,0)
(0,0) (0,0) (0,0)
\endcode
@param[in] nNewDim New dimension.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& resize(tint nNewDim) {
        this->_resize2(nNewDim, nNewDim);
        return *this;
    }

/**
@brief Matrix replacement

Destroys calling matrix, creates a new one as a copy of \c m
and returns a reference to the matrix changed. Operator throws \ref cvmexception
in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    scmatrix m(3);
    scmatrix mc(1);
    m(1,2) = 1.;
    m(2,3) = 2.;
    std::cout << m << std::endl << mc << std::endl;
    mc << m;
    std::cout << mc;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(0,0) (1,0) (0,0)
(0,0) (0,0) (2,0)
(0,0) (0,0) (0,0)

(0,0)

(0,0) (1,0) (0,0)
(0,0) (0,0) (2,0)
(0,0) (0,0) (0,0)
\endcode
@see operator =()
@param[in] m \ref scmatrix to replace by.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& operator << (const basic_scmatrix& m) {
        this->_replace(m);
        this->_massign(m);
        return *this;
    }

/**
@brief Addition operator

Creates an object of type \ref scmatrix as a sum of
a calling matrix and a matrix \c m.
Operator throws \ref cvmexception
in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
    double b[] = {10., 20., 30., 40., 50., 60., 70., 80.};
    scmatrix m1((std::complex<double>*) a, 2);
    scmatrix m2((std::complex<double>*) b, 2);
    std::cout << m1 + m2 << std::endl << m1 + m1;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(11,22) (55,66)
(33,44) (77,88)

(2,4) (10,12)
(6,8) (14,16)
\endcode
@see sum()
@param[in] m \ref scmatrix to add to a calling one.
@return Sum of matrices.
*/
    basic_scmatrix operator + (const basic_scmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        basic_scmatrix mSum(*this);
        mSum._mincr(m);
        return mSum;
    }

/**
@brief Subtraction operator

Creates an object of type \ref scmatrix as a difference of
a calling matrix and a matrix \c m.
It throws \ref cvmexception in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
    double b[] = {10., 20., 30., 40., 50., 60., 70., 80.};
    scmatrix m1((std::complex<double>*) a, 2);
    scmatrix m2((std::complex<double>*) b, 2);
    std::cout << m2 - m1 << std::endl << m1 - m1;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(9,18) (45,54)
(27,36) (63,72)

(0,0) (0,0)
(0,0) (0,0)
\endcode
@see diff()
@param[in] m \ref scmatrix to subtract from calling one.
@return Difference of matrices.
*/
    basic_scmatrix operator - (const basic_scmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        basic_scmatrix mDiff(*this);
        mDiff._mdecr(m);
        return mDiff;
    }

/**
@brief Sum of matrices

Assigns sum of square complex matrices \c m1 and \c m2 to a calling matrix
and returns a reference to the matrices changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
                  10., 11., 12., 13., 14., 15., 16., 17., 18.};
    const scmatrix m1((std::complex<double>*)a, 3);
    scmatrix m2(3);
    scmatrix m(3);
    m2.set(std::complex<double>(1.,1.));
    std::cout << m.sum(m1, m2) << std::endl;
    std::cout << m.sum(m, m2);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(2,3) (8,9) (14,15)
(4,5) (10,11) (16,17)
(6,7) (12,13) (18,19)

(3,4) (9,10) (15,16)
(5,6) (11,12) (17,18)
(7,8) (13,14) (19,20)
\endcode
@see operator +()
@param[in] m1 First \ref scmatrix summand.
@param[in] m2 Second \ref scmatrix summand.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& sum(const basic_scmatrix& m1, const basic_scmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
        this->_msum(m1, m2);
        return *this;
    }

/**
@brief Difference of matrices

Assigns difference of square complex matrices \c m1 and \c m2 to a calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
                  10., 11., 12., 13., 14., 15., 16., 17., 18.};
    const scmatrix m1((std::complex<double>*)a, 3);
    scmatrix m2(3);
    scmatrix m(3);
    m2.set(std::complex<double>(1.,1.));
    std::cout << m.diff(m1, m2) << std::endl;
    std::cout << m.diff(m, m2);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(0,1) (6,7) (12,13)
(2,3) (8,9) (14,15)
(4,5) (10,11) (16,17)

(-1,0) (5,6) (11,12)
(1,2) (7,8) (13,14)
(3,4) (9,10) (15,16)
\endcode
@see operator -()
@param[in] m1 First \ref scmatrix subtrahend.
@param[in] m2 Second \ref scmatrix subtrahend.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& diff(const basic_scmatrix& m1, const basic_scmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
        this->_mdiff(m1, m2);
        return *this;
    }

/**
@brief Increment operator

Adds \ref scmatrix \c m to a calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    scmatrix m1(3);
    scmatrix m2(3);
    m1.set(std::complex<double>(1.,2.));
    m2.set(std::complex<double>(3.,4.));

    m1 += m2;
    std::cout << m1 << std::endl;

    // well, you can do this too, but temporary object would be created
    m2 += m2;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(4,6) (4,6) (4,6)
(4,6) (4,6) (4,6)
(4,6) (4,6) (4,6)

(6,8) (6,8) (6,8)
(6,8) (6,8) (6,8)
(6,8) (6,8) (6,8)
\endcode
@see operator +()
@see sum()
@param[in] m \ref scmatrix to increment by.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& operator += (const basic_scmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        this->_mincr(m);
        return *this;
    }

/**
@brief Decrement operator

Subtracts \ref scmatrix \c m from calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    scmatrix m1(3);
    scmatrix m2(3);
    m1.set(std::complex<double>(1.,2.));
    m2.set(std::complex<double>(3.,4.));

    m1 -= m2;
    std::cout << m1 << std::endl;

    // well, you can do this too, but temporary object would be created
    m2 -= m2;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-2,-2) (-2,-2) (-2,-2)
(-2,-2) (-2,-2) (-2,-2)
(-2,-2) (-2,-2) (-2,-2)

(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
@see operator -()
@see diff()
@param[in] m \ref scmatrix to decrement by.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& operator -= (const basic_scmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        this->_mdecr(m);
        return *this;
    }

/**
@brief Unary minus operator

Creates an object of type \ref scmatrix as
a calling matrix multiplied by \c -1.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
scmatrix m((std::complex<double>*) a, 2);
std::cout << -m;
\endcode
prints
\code
(-1,-2) (-5,-6)
(-3,-4) (-7,-8)
\endcode
@return Result object.
*/
    basic_scmatrix operator - () const {
        const TR mone(-1.);
        basic_scmatrix mRes(*this);
        mRes._scalr(mone);
        return mRes;
    }

/**
@brief Plus identity, prefix

Adds identity matrix to a calling square complex matrix and returns 
a reference to the matrix changed.
\par Example:
\code
using namespace cvm; 
scmatrix m(2, {1., 2., 3., 4., 5., 6., 7., 8.});
std::cout << m << std::endl; 
std::cout << ++m << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
(1,2) (5,6) 
(3,4) (7,8) 

(2,2) (5,6) 
(3,4) (8,8) 

(2,2) (5,6) 
(3,4) (8,8) 
\endcode
@return Reference to changed calling matrix.
*/
    basic_scmatrix& operator ++ () {
        this->_plus_plus();
        return *this;
    }

/**
@brief Plus identity, postfix

Adds identity matrix to a calling square complex matrix and
returns a copy of the original calling matrix.
\par Example:
\code
using namespace cvm; 
scmatrix m(2, {1., 2., 3., 4., 5., 6., 7., 8.});
std::cout << m << std::endl; 
std::cout << m++ << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
(1,2) (5,6) 
(3,4) (7,8) 

(1,2) (5,6) 
(3,4) (7,8) 

(2,2) (5,6) 
(3,4) (8,8) 
\endcode
@return Copy of the original calling matrix.
*/
    basic_scmatrix operator ++ (int) {
        basic_scmatrix mRes(*this);
        this->_plus_plus();
        return mRes;
    }

/**
@brief Minus identity, prefix

Subtracts identity matrix from calling square complex matrix and 
returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm; 
scmatrix m(2, {1., 2., 3., 4., 5., 6., 7., 8.});
std::cout << m << std::endl; 
std::cout << --m << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
(1,2) (5,6) 
(3,4) (7,8) 

(0,2) (5,6) 
(3,4) (6,8) 

(0,2) (5,6) 
(3,4) (6,8) 
\endcode
@return Reference to changed calling matrix.
*/
    basic_scmatrix& operator -- () {
        this->_minus_minus();
        return *this;
    }

/**
@brief Minus identity, postfix

Subtracts identity matrix from calling square complex matrix and 
returns a copy of the original calling matrix.
\par Example:
\code
using namespace cvm; 
scmatrix m(2, {1., 2., 3., 4., 5., 6., 7., 8.});
std::cout << m << std::endl; 
std::cout << m-- << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
(1,2) (5,6) 
(3,4) (7,8) 

(1,2) (5,6) 
(3,4) (7,8) 

(0,2) (5,6) 
(3,4) (6,8) 
\endcode
@return Copy of the original calling matrix.
*/
    basic_scmatrix operator -- (int) {
        basic_scmatrix mRes(*this);
        this->_minus_minus();
        return mRes;
    }

/**
@brief Multiply by real number operator

Creates an object of type \ref scmatrix as a product of
a calling matrix and real number \c dMult.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
std::cout << m * 5.;
\endcode
prints
\code
(5,10) (35,40) (65,70)
(15,20) (45,50) (75,80)
(25,30) (55,60) (85,90)
\endcode
@see operator *=()
@param[in] dMult Number to multiply by.
@return Result object.
*/
    basic_scmatrix operator * (TR dMult) const {
        basic_scmatrix mRes(*this);
        mRes._scalr(dMult);
        return mRes;
    }

/**
@brief Divide by real number operator

Creates an object of type \ref scmatrix as a quotient of
a calling matrix and real number \c dDiv.
It throws \ref cvmexception if \c dDiv has absolute value equal or less
than \ref cvmMachMin() (the smallest normalized positive number).
It also throws exception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
std::cout << m / 2.;
\endcode
prints
\code
(0.5,1) (3.5,4) (6.5,7)
(1.5,2) (4.5,5) (7.5,8)
(2.5,3) (5.5,6) (8.5,9)
\endcode
@see operator /=()
@param[in] dDiv Number to divide by.
@return Result object.
*/
    basic_scmatrix operator / (TR dDiv) const {
        basic_scmatrix mRes(*this);
        mRes._div(dDiv);
        return mRes;
    }

/**
@brief Multiply by complex number operator

Creates an object of type \ref scmatrix as a product of
a calling matrix and complex number \c cMult.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
std::cout << m * std::complex<double>(1.,1.);
\endcode
prints
\code
(-1,3) (-1,15) (-1,27)
(-1,7) (-1,19) (-1,31)
(-1,11) (-1,23) (-1,35)
\endcode
@see operator *=()
@param[in] cMult Number to multiply by.
@return Result object.
*/
    basic_scmatrix operator * (TC cMult) const {
        basic_scmatrix mRes(*this);
        mRes._scalc(cMult);
        return mRes;
    }

/**
@brief Divide by complex number operator

Creates an object of type \ref scmatrix as a quotient of
a calling matrix and complex number \c cDiv.
It throws \ref cvmexception if \c cDiv has absolute value equal or less
than \ref cvmMachMin() (the smallest normalized positive number).
It also throws exception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
std::cout << m / std::complex<double>(1.,1.);
\endcode
prints
\code
(1.5,0.5) (7.5,0.5) (13.5,0.5)
(3.5,0.5) (9.5,0.5) (15.5,0.5)
(5.5,0.5) (11.5,0.5) (17.5,0.5)
\endcode
@see operator /=()
@param[in] cDiv Number to divide by.
@return Result object.
*/
    basic_scmatrix operator / (TC cDiv) const {
        basic_scmatrix mRes(*this);
        mRes._div(cDiv);
        return mRes;
    }

/**
@brief Multiply by real number and assign

Multiplies calling square complex matrix by real number \c dMult and returns a reference to
the matrix changed.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
m *= 5.;
std::cout << m;
\endcode
prints
\code
(5,10) (35,40) (65,70)
(15,20) (45,50) (75,80)
(25,30) (55,60) (85,90)
\endcode
@see operator *(TR) const
@param[in] dMult Number to multiply by.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& operator *= (TR dMult) {
        this->_scalr(dMult);
        return *this;
    }

/**
@brief Divide by real number and assign

Divides calling square complex matrix by real number \c dDiv and returns a reference to
the matrix changed. It throws \ref cvmexception if \c dDiv
has absolute value equal or less than \ref cvmMachMin() (the
smallest normalized positive number).
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
m /= 2.;
std::cout << m;
\endcode
prints
\code
(0.5,1) (3.5,4) (6.5,7)
(1.5,2) (4.5,5) (7.5,8)
(2.5,3) (5.5,6) (8.5,9)
\endcode
@see operator /(TR) const
@param[in] dDiv Number to divide by.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& operator /= (TR dDiv) {
        this->_div(dDiv);
        return *this;
    }

/**
@brief Multiply by complex number and assign

Multiplies calling square complex matrix by complex number \c cMult and returns a reference to
the matrix changed.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
m *= std::complex<double>(2.,1.);
std::cout << m;
\endcode
prints
\code
(0,5) (6,23) (12,41)
(2,11) (8,29) (14,47)
(4,17) (10,35) (16,53)
\endcode
@see operator *(TR) const
@param[in] cMult Number to multiply by.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& operator *= (TC cMult) {
        this->_scalc(cMult);
        return *this;
    }

/**
@brief Divide by complex number and assign

Divides calling square complex matrix by complex number \c cDiv and returns a reference to
the matrix changed. It throws \ref cvmexception if \c cDiv
has absolute value equal or less than \ref cvmMachMin() (the
smallest normalized positive number).
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
m /= std::complex<double>(2.,1.);
std::cout << m;
\endcode
prints
\code
(0.8,0.6) (4.4,1.8) (8,3)
(2,1) (5.6,2.2) (9.2,3.4)
(3.2,1.4) (6.8,2.6) (10.4,3.8)
\endcode
@see operator /(TR) const
@param[in] cDiv Number to divide by.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& operator /= (TC cDiv) {
        this->_div(cDiv);
        return *this;
    }

    // TODO dox
    basic_scmatrix& normalize() {
        this->_normalize();
        return *this;
    }

// 6.1: transposed (not conjugated) matrix
/**
@brief Matrix transposition

Creates an object of type \c scmatrix as transposed calling matrix.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
scmatrix mc(3);
std::cout << m << std::endl << !m << std::endl ;
mc.transpose(m);
std::cout << mc << std::endl;
mc.transpose();
std::cout << mc;
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

(1,2) (3,4)
(5,6) (7,8)
(9,10) (11,12)

(1,2) (3,4)
(5,6) (7,8)
(9,10) (11,12)

(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
\endcode
@return Result object.
*/
    basic_scmatrix operator ! () const {
        basic_scmatrix mRes(*this);
        return mRes.transpose();
    }

/**
@brief Matrix conjugation

Creates an object of type \c scmatrix as Hermitian conjugated calling matrix.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
scmatrix mc(3);
std::cout << m << std::endl << ~m << std::endl ;
mc.conj(m);
std::cout << mc << std::endl;
mc.conj();
std::cout << mc;
\endcode
prints
\code
(1,2) (7,8) (13,14)
(3,4) (9,10) (15,16)
(5,6) (11,12) (17,18)

(1,-2) (3,-4) (5,-6)
(7,-8) (9,-10) (11,-12)
(13,-14) (15,-16) (17,-18)

(1,-2) (3,-4) (5,-6)
(7,-8) (9,-10) (11,-12)
(13,-14) (15,-16) (17,-18)

(1,2) (7,8) (13,14)
(3,4) (9,10) (15,16)
(5,6) (11,12) (17,18)
\endcode
@return Result object.
*/
    basic_scmatrix operator ~ () const {
        basic_scmatrix mRes(*this);
        return mRes.conj();
    }

// 6.1: this = transposed (not conjugated) (m)
/**
@brief Matrix transposition

Sets calling matrix to be equal to square complex matrix \c m transposed.
Function throws \ref cvmexception in case of not appropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
scmatrix mc(3);
std::cout << m << std::endl << !m << std::endl ;
mc.transpose(m);
std::cout << mc << std::endl;
mc.transpose();
std::cout << mc;
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

(1,2) (3,4)
(5,6) (7,8)
(9,10) (11,12)

(1,2) (3,4)
(5,6) (7,8)
(9,10) (11,12)

(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
\endcode
@param[in] m \ref scmatrix to transpose.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& transpose(const basic_scmatrix& m) {
        (*this) = m;
        return this->transpose();
    }

/**
@brief Matrix conjugation

Sets calling matrix to be equal to square complex matrix \c m Hermitian conjugated.
Function throws \ref cvmexception in case of not appropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
scmatrix mc(3);
std::cout << m << std::endl << ~m << std::endl ;
mc.conj(m);
std::cout << mc << std::endl;
mc.conj();
std::cout << mc;
\endcode
prints
\code
(1,2) (7,8) (13,14)
(3,4) (9,10) (15,16)
(5,6) (11,12) (17,18)

(1,-2) (3,-4) (5,-6)
(7,-8) (9,-10) (11,-12)
(13,-14) (15,-16) (17,-18)

(1,-2) (3,-4) (5,-6)
(7,-8) (9,-10) (11,-12)
(13,-14) (15,-16) (17,-18)

(1,2) (7,8) (13,14)
(3,4) (9,10) (15,16)
(5,6) (11,12) (17,18)
\endcode
@param[in] m \ref scmatrix to conjugate.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& conj(const basic_scmatrix& m) {
        (*this) = m;
        return this->conj();
    }

// 6.1: this = transposed (not conjugate) (this)
/**
@brief Matrix transposition (in-place)

Makes calling square complex matrix to be equal to transposed itself.
Function throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
scmatrix mc(3);
std::cout << m << std::endl << !m << std::endl ;
mc.transpose(m);
std::cout << mc << std::endl;
mc.transpose();
std::cout << mc;
\endcode
prints
\code
(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)

(1,2) (3,4)
(5,6) (7,8)
(9,10) (11,12)

(1,2) (3,4)
(5,6) (7,8)
(9,10) (11,12)

(1,2) (5,6) (9,10)
(3,4) (7,8) (11,12)
\endcode
@return Reference to changed calling matrix.
*/
    basic_scmatrix& transpose() {
        this->_transp();
        return *this;
    }

/**
@brief Matrix conjugation (in-place)

Makes calling square complex matrix to be equal to Hermitian conjugated itself.
Function throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*) a, 3);
scmatrix mc(3);
std::cout << m << std::endl << ~m << std::endl ;
mc.conj(m);
std::cout << mc << std::endl;
mc.conj();
std::cout << mc;
\endcode
prints
\code
(1,2) (7,8) (13,14)
(3,4) (9,10) (15,16)
(5,6) (11,12) (17,18)

(1,-2) (3,-4) (5,-6)
(7,-8) (9,-10) (11,-12)
(13,-14) (15,-16) (17,-18)

(1,-2) (3,-4) (5,-6)
(7,-8) (9,-10) (11,-12)
(13,-14) (15,-16) (17,-18)

(1,2) (7,8) (13,14)
(3,4) (9,10) (15,16)
(5,6) (11,12) (17,18)
\endcode
@return Reference to changed calling matrix.
*/
    basic_scmatrix& conj() {
        this->_conj();
        return *this;
    }

    // TODO dox
    CVector operator * (const CVector& v) const {
        return this->BaseCMatrix::operator * (v);
    }

// special exclusion since matrix product is not commutative
/**
@brief Matrix-matrix product

Creates an object of type \ref cmatrix as a product of a calling square complex matrix and a matrix \c m.
Operator throws \ref cvmexception if number of columns of a calling matrix
differs from number of rows of the matrix \c m.
Use \ref mult() to avoid new object creation.
\par Example:
\code
using namespace cvm;
try {
    scmatrix ms(3);
    cmatrix m(3,2);
    ms.set(std::complex<double>(1.,1.));
    m.set(std::complex<double>(1.,1.));
    std::cout << ms * m;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(0,6) (0,6)
(0,6) (0,6)
(0,6) (0,6)
\endcode
@param[in] m \ref cmatrix to compute product with.
@return Result object.
*/
    BaseCMatrix operator * (const BaseCMatrix& m) const {
        return this->BaseCMatrix::operator * (m);
    }

/**
@brief Matrix-matrix product

Creates an object of type \ref scmatrix as a product of a calling matrix and square matrix \c m.
Operator throws \ref cvmexception if number of columns of a calling matrix
differs from number of rows of the matrix \c m.
Use \ref mult() to avoid new object creation.
\par Example:
\code
using namespace cvm;
try {
    scmatrix m1(3), m2(3);
    m1.set(std::complex<double>(1.,1.));
    m2.set(std::complex<double>(1.,1.));
    std::cout << m1 * m2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(0,6) (0,6) (0,6)
(0,6) (0,6) (0,6)
(0,6) (0,6) (0,6)
\endcode
@param[in] m \ref scmatrix to compute product with.
@return Result object.
*/
    basic_scmatrix operator * (const basic_scmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        basic_scmatrix mRes(this->msize());
        mRes.mult(*this, m);
        return mRes;
    }

/**
@brief Matrix-matrix product with assignment

Sets calling matrix to be equal to product of itself and square complex matrix \c m
and returns a reference to the object it changes.
Operator throws \ref cvmexception in case of different dimensions of the operands.
\par Example:
\code
using namespace cvm;
try {
    scmatrix m1(3), m2(3);
    m1.set(std::complex<double>(1.,2.));
    m2.set(std::complex<double>(2.,1.));
    m1 *= m2;
    m2 *= m2;
    std::cout << m1 << std::endl << m2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(0,15) (0,15) (0,15)
(0,15) (0,15) (0,15)
(0,15) (0,15) (0,15)

(9,12) (9,12) (9,12)
(9,12) (9,12) (9,12)
(9,12) (9,12) (9,12)
\endcode
@param[in] m \ref scmatrix to compute product with.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& operator *= (const basic_scmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        const basic_scmatrix mTmp(*this);
        this->mult(mTmp, m);
        return *this;
    }

    // TODO dox
    basic_scmatrix& swap_rows(tint n1, tint n2) {
        this->_swap_rows(n1, n2);
        return *this;
    }

    basic_scmatrix& swap_cols(tint n1, tint n2) {
        this->_swap_cols(n1, n2);
        return *this;
    }

// linear solvers
/**
@brief Linear solver

Creates \ref cvector object as solution \f$x\f$ of linear equation
\f$A*x=b\f$ where calling matrix is square complex matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
It also sets output parameter \c dErr to be equal
to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    scmatrix ma(re, im, 3);
    cmatrix  mb(3,2);
    cmatrix  mx(3,2);
    double dErr;

    mb(1).set(std::complex<double>(1.,1.));
    mb(1,2) = std::complex<double>(1.,1.);
    mb(2,2) = std::complex<double>(2.,2.);
    mb(3,2) = std::complex<double>(3.,3.);

    mx.solve(ma, mb, dErr);
    std::cout << mx << dErr
              << std::endl << ma * mx - mb << std::endl;

    cvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve(vb, dErr);
    std::cout << vx << dErr << std::endl << ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-6.25e-002,-2.71e-001) (-1.25e-001,+1.13e+000)
(+1.25e-001,+2.08e-001) (+2.50e-001,-2.50e-001)
(+6.25e-002,+6.25e-002) (+1.25e-001,+1.25e-001)
+1.45e-014
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
(-2.22e-016,+4.44e-016) (+0.00e+000,+0.00e+000)
(+2.22e-016,+0.00e+000) (+0.00e+000,+0.00e+000)

(-1.25e-001,+1.13e+000) (+2.50e-001,-2.50e-001) (+1.25e-001,+1.25e-001)
+7.41e-015
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
\endcode
@see solve(const CVector&)const
@param[in] vB \ref cvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    CVector solve(const CVector& vB, TR& dErr) const {
        return _solve_helper(vB, dErr, 0);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Creates \ref cvector object as solution \f$x\f$ of linear equation
\f$A^T*x=b\f$ (which is equivalent to \f$x*A=b\f$) where calling matrix is square complex matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
It also sets output parameter \c dErr to be equal
to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    scmatrix ma(re, im, 3);
    cmatrix  mb(3,2);
    cmatrix  mx(3,2);
    double dErr;

    mb(1).set(std::complex<double>(1.,1.));
    mb(1,2) = std::complex<double>(1.,1.);
    mb(2,2) = std::complex<double>(2.,2.);
    mb(3,2) = std::complex<double>(3.,3.);

    mx.solve_tran(ma, mb, dErr);
    std::cout << mx << dErr
              << std::endl << !ma * mx - mb
              << std::endl << !mx * ma - !mb << std::endl;

    cvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve_tran(vb, dErr);
    std::cout << vx << dErr << std::endl << vx * ma - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+3.13e-002,-5.31e-001) (+9.38e-002,-9.38e-002)
(+6.25e-002,+6.25e-002) (+1.88e-001,+1.88e-001)
(+3.13e-002,+4.69e-001) (+9.38e-002,+2.40e-001)
+1.02e-014
(-2.22e-016,-2.22e-016) (+0.00e+000,+0.00e+000)
(-4.44e-016,-4.44e-016) (+0.00e+000,+0.00e+000)
(+8.88e-016,-8.88e-016) (+0.00e+000,+0.00e+000)

(-2.22e-016,-2.22e-016) (-4.44e-016,-4.44e-016) (+8.88e-016,-8.88e-016)
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)

(+9.38e-002,-9.38e-002) (+1.88e-001,+1.88e-001) (+9.38e-002,+2.40e-001)
+1.02e-014
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
\endcode
@see solve_tran(const CVector&)const
@param[in] vB \ref cvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    CVector solve_tran(const CVector& vB, TR& dErr) const {
        return _solve_helper(vB, dErr, 1);
    }

// 6.1: conjugate added
/**
@brief Linear solver (Hermitian conjugated)

Creates \ref cvector object as solution \f$x\f$ of linear equation
\f$A^H*x=b\f$ where calling matrix is square complex matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
It also sets output parameter \c dErr to be equal
to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    scmatrix ma(re, im, 3);
    cmatrix  mb(3,2);
    cmatrix  mx(3,2);
    double dErr;

    mb(1).set(std::complex<double>(1.,1.));
    mb(1,2) = std::complex<double>(1.,1.);
    mb(2,2) = std::complex<double>(2.,2.);
    mb(3,2) = std::complex<double>(3.,3.);

    mx.solve_conj(ma, mb, dErr);
    std::cout << mx << dErr
              << std::endl << ~ma * mx - mb
              << std::endl << ~mx * ma - ~mb << std::endl;

    cvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve_conj(vb, dErr);
    std::cout << vx << dErr << std::endl << ~ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-5.31e-001,+3.13e-002) (-9.38e-002,+9.38e-002)
(+6.25e-002,+6.25e-002) (+1.88e-001,+1.88e-001)
(+4.69e-001,+3.13e-002) (+2.40e-001,+9.38e-002)
+1.02e-014
(-2.22e-016,-2.22e-016) (+0.00e+000,+0.00e+000)
(-4.44e-016,-4.44e-016) (+0.00e+000,+0.00e+000)
(-8.88e-016,+8.88e-016) (+0.00e+000,+0.00e+000)

(-2.22e-016,+2.22e-016) (-4.44e-016,+4.44e-016) (-8.88e-016,-8.88e-016)
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)

(-9.38e-002,+9.38e-002) (+1.88e-001,+1.88e-001) (+2.40e-001,+9.38e-002)
+1.02e-014
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
\endcode
@see solve_conj(const CVector&)const
@param[in] vB \ref cvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    CVector solve_conj(const CVector& vB, TR& dErr) const {
        return _solve_helper(vB, dErr, 2);
    }

/**
@brief Linear solver

Creates \ref cvector object as solution \f$x\f$ of linear equation
\f$A*x=b\f$ where calling matrix is square complex matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    scmatrix ma(re, im, 3);
    cmatrix  mb(3,2);
    cmatrix  mx(3,2);

    mb(1).set(std::complex<double>(1.,1.));
    mb(1,2) = std::complex<double>(1.,1.);
    mb(2,2) = std::complex<double>(2.,2.);
    mb(3,2) = std::complex<double>(3.,3.);

    mx.solve(ma, mb);
    std::cout << mx << std::endl << ma * mx - mb << std::endl;

    cvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve(vb);
    std::cout << vx << std::endl << ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-6.25e-002,-2.71e-001) (-1.25e-001,+1.13e+000)
(+1.25e-001,+2.08e-001) (+2.50e-001,-2.50e-001)
(+6.25e-002,+6.25e-002) (+1.25e-001,+1.25e-001)

(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
(-2.22e-016,+4.44e-016) (+0.00e+000,+0.00e+000)
(+2.22e-016,+0.00e+000) (+0.00e+000,+0.00e+000)

(-1.25e-001,+1.13e+000) (+2.50e-001,-2.50e-001) (+1.25e-001,+1.25e-001)

(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
\endcode
@see solve(const CVector&,TR&)const
@param[in] vB \ref cvector \f$b\f$.
@return Result object.
*/
    [[nodiscard]] CVector solve(const CVector& vB) const {
        TR dErr(0.);
        return this->solve(vB, dErr);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Creates \ref cvector object as solution \f$x\f$ of linear equation
\f$A^T*x=b\f$ (which is equivalent to \f$x*A=b\f$) where calling matrix is square complex matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    scmatrix ma(re, im, 3);
    cmatrix  mb(3,2);
    cmatrix  mx(3,2);

    mb(1).set(std::complex<double>(1.,1.));
    mb(1,2) = std::complex<double>(1.,1.);
    mb(2,2) = std::complex<double>(2.,2.);
    mb(3,2) = std::complex<double>(3.,3.);

    mx.solve_tran(ma, mb);
    std::cout << mx
              << std::endl << !ma * mx - mb
              << std::endl << !mx * ma - !mb << std::endl;

    cvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve_tran(vb);
    std::cout << vx << std::endl << vx * ma - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+3.13e-002,-5.31e-001) (+9.38e-002,-9.38e-002)
(+6.25e-002,+6.25e-002) (+1.88e-001,+1.88e-001)
(+3.13e-002,+4.69e-001) (+9.38e-002,+2.40e-001)

(-2.22e-016,-2.22e-016) (+0.00e+000,+0.00e+000)
(-4.44e-016,-4.44e-016) (+0.00e+000,+0.00e+000)
(+8.88e-016,-8.88e-016) (+0.00e+000,+0.00e+000)

(-2.22e-016,-2.22e-016) (-4.44e-016,-4.44e-016) (+8.88e-016,-8.88e-016)
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)

(+9.38e-002,-9.38e-002) (+1.88e-001,+1.88e-001) (+9.38e-002,+2.40e-001)

(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
\endcode
@see solve_tran(const CVector&,TR&)const
@param[in] vB \ref cvector \f$b\f$.
@return Result object.
*/
    [[nodiscard]] CVector solve_tran(const CVector& vB) const {
        TR dErr(0.);
        return this->solve_tran(vB, dErr);
    }

// 6.1: conjugate added
/**
@brief Linear solver (Hermitian conjugated)

Creates \ref cvector object as solution \f$x\f$ of linear equation
\f$A^H*x=b\f$ where calling matrix is square complex matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    scmatrix ma(re, im, 3);
    cmatrix  mb(3,2);
    cmatrix  mx(3,2);

    mb(1).set(std::complex<double>(1.,1.));
    mb(1,2) = std::complex<double>(1.,1.);
    mb(2,2) = std::complex<double>(2.,2.);
    mb(3,2) = std::complex<double>(3.,3.);

    mx.solve_conj(ma, mb);
    std::cout << mx
              << std::endl << ~ma * mx - mb
              << std::endl << ~mx * ma - ~mb << std::endl;

    cvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve_conj(vb);
    std::cout << vx << std::endl << ~ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-5.31e-001,+3.13e-002) (-9.38e-002,+9.38e-002)
(+6.25e-002,+6.25e-002) (+1.88e-001,+1.88e-001)
(+4.69e-001,+3.13e-002) (+2.40e-001,+9.38e-002)

(-2.22e-016,-2.22e-016) (+0.00e+000,+0.00e+000)
(-4.44e-016,-4.44e-016) (+0.00e+000,+0.00e+000)
(-8.88e-016,+8.88e-016) (+0.00e+000,+0.00e+000)

(-2.22e-016,+2.22e-016) (-4.44e-016,+4.44e-016) (-8.88e-016,-8.88e-016)
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)

(-9.38e-002,+9.38e-002) (+1.88e-001,+1.88e-001) (+2.40e-001,+9.38e-002)

(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
\endcode
@see solve_conj(const CVector&,TR&)const
@param[in] vB \ref cvector \f$b\f$.
@return Result object.
*/
    [[nodiscard]] CVector solve_conj(const CVector& vB) const {
        TR dErr(0.);
        return this->solve_conj(vB, dErr);
    }

/**
@brief Linear solver

Creates \ref cmatrix object as solution \f$X\f$ of
matrix linear equation \f$A*X=B\f$ where calling square complex matrix is matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    scmatrix ma(re, im, 3);
    cmatrix  mb(3,2);
    cmatrix  mx(3,2);
    double dErr;

    mb(1).set(std::complex<double>(1.,1.));
    mb(1,2) = std::complex<double>(1.,1.);
    mb(2,2) = std::complex<double>(2.,2.);
    mb(3,2) = std::complex<double>(3.,3.);

    mx.solve(ma, mb, dErr);
    std::cout << mx << dErr
              << std::endl << ma * mx - mb << std::endl;

    cvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve(vb, dErr);
    std::cout << vx << dErr << std::endl << ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-6.25e-002,-2.71e-001) (-1.25e-001,+1.13e+000)
(+1.25e-001,+2.08e-001) (+2.50e-001,-2.50e-001)
(+6.25e-002,+6.25e-002) (+1.25e-001,+1.25e-001)
+1.45e-014
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
(-2.22e-016,+4.44e-016) (+0.00e+000,+0.00e+000)
(+2.22e-016,+0.00e+000) (+0.00e+000,+0.00e+000)

(-1.25e-001,+1.13e+000) (+2.50e-001,-2.50e-001) (+1.25e-001,+1.25e-001)
+7.41e-015
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
\endcode
@see solve(const BaseCMatrix&)const
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    BaseCMatrix solve(const BaseCMatrix& mB, TR& dErr) const {
        return _solve_helper(mB, dErr, 0);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Creates \ref cmatrix object as solution \f$X\f$ of
matrix linear equation \f$A^T*X=B\f$  (which is equivalent to \f$X^T*A=B^T\f$)
where calling matrix is square complex matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    scmatrix ma(re, im, 3);
    cmatrix  mb(3,2);
    cmatrix  mx(3,2);
    double dErr;

    mb(1).set(std::complex<double>(1.,1.));
    mb(1,2) = std::complex<double>(1.,1.);
    mb(2,2) = std::complex<double>(2.,2.);
    mb(3,2) = std::complex<double>(3.,3.);

    mx.solve_tran(ma, mb, dErr);
    std::cout << mx << dErr
              << std::endl << !ma * mx - mb
              << std::endl << !mx * ma - !mb << std::endl;

    cvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve_tran(vb, dErr);
    std::cout << vx << dErr << std::endl << vx * ma - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+3.13e-002,-5.31e-001) (+9.38e-002,-9.38e-002)
(+6.25e-002,+6.25e-002) (+1.88e-001,+1.88e-001)
(+3.13e-002,+4.69e-001) (+9.38e-002,+2.40e-001)
+1.02e-014
(-2.22e-016,-2.22e-016) (+0.00e+000,+0.00e+000)
(-4.44e-016,-4.44e-016) (+0.00e+000,+0.00e+000)
(+8.88e-016,-8.88e-016) (+0.00e+000,+0.00e+000)

(-2.22e-016,-2.22e-016) (-4.44e-016,-4.44e-016) (+8.88e-016,-8.88e-016)
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)

(+9.38e-002,-9.38e-002) (+1.88e-001,+1.88e-001) (+9.38e-002,+2.40e-001)
+1.02e-014
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
\endcode
@see solve_tran(const BaseCMatrix&)const
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    BaseCMatrix solve_tran(const BaseCMatrix& mB, TR& dErr) const {
        return _solve_helper(mB, dErr, 1);
    }

// 6.1: conjugate added
/**
@brief Linear solver (Hermitian conjugated)

Creates \ref cmatrix object as solution \f$X\f$ of
matrix linear equation \f$A^H*X=B\f$  (which is equivalent to \f$X^H*A=B^H\f$)
where calling matrix is square complex matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$.
It also sets output parameter \c dErr to be equal to the norm of computation error.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    scmatrix ma(re, im, 3);
    cmatrix  mb(3,2);
    cmatrix  mx(3,2);
    double dErr;

    mb(1).set(std::complex<double>(1.,1.));
    mb(1,2) = std::complex<double>(1.,1.);
    mb(2,2) = std::complex<double>(2.,2.);
    mb(3,2) = std::complex<double>(3.,3.);

    mx.solve_conj(ma, mb, dErr);
    std::cout << mx << dErr
              << std::endl << ~ma * mx - mb
              << std::endl << ~mx * ma - ~mb << std::endl;

    cvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve_conj(vb, dErr);
    std::cout << vx << dErr << std::endl << ~ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-5.31e-001,+3.13e-002) (-9.38e-002,+9.38e-002)
(+6.25e-002,+6.25e-002) (+1.88e-001,+1.88e-001)
(+4.69e-001,+3.13e-002) (+2.40e-001,+9.38e-002)
+1.02e-014
(-2.22e-016,-2.22e-016) (+0.00e+000,+0.00e+000)
(-4.44e-016,-4.44e-016) (+0.00e+000,+0.00e+000)
(-8.88e-016,+8.88e-016) (+0.00e+000,+0.00e+000)

(-2.22e-016,+2.22e-016) (-4.44e-016,+4.44e-016) (-8.88e-016,-8.88e-016)
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)

(-9.38e-002,+9.38e-002) (+1.88e-001,+1.88e-001) (+2.40e-001,+9.38e-002)
+1.02e-014
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
\endcode
@see solve_conj(const BaseCMatrix&)const
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    BaseCMatrix solve_conj(const BaseCMatrix& mB, TR& dErr) const {
        return _solve_helper(mB, dErr, 2);
    }

/**
@brief Linear solver

Creates \ref cmatrix object as solution \f$X\f$ of
matrix linear equation \f$A*X=B\f$ where calling square complex matrix is matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$.
Function throws \ref cvmexception in case of inappropriate sizes
of the operands or when the matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    scmatrix ma(re, im, 3);
    cmatrix  mb(3,2);
    cmatrix  mx(3,2);

    mb(1).set(std::complex<double>(1.,1.));
    mb(1,2) = std::complex<double>(1.,1.);
    mb(2,2) = std::complex<double>(2.,2.);
    mb(3,2) = std::complex<double>(3.,3.);

    mx.solve(ma, mb);
    std::cout << mx << std::endl << ma * mx - mb << std::endl;

    cvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve(vb);
    std::cout << vx << std::endl << ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-6.25e-002,-2.71e-001) (-1.25e-001,+1.13e+000)
(+1.25e-001,+2.08e-001) (+2.50e-001,-2.50e-001)
(+6.25e-002,+6.25e-002) (+1.25e-001,+1.25e-001)

(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
(-2.22e-016,+4.44e-016) (+0.00e+000,+0.00e+000)
(+2.22e-016,+0.00e+000) (+0.00e+000,+0.00e+000)

(-1.25e-001,+1.13e+000) (+2.50e-001,-2.50e-001) (+1.25e-001,+1.25e-001)

(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
\endcode
@see solve(const BaseCMatrix&,TR&)const
@param[in] mB \ref cmatrix \f$B\f$.
@return Result object.
*/
    [[nodiscard]] BaseCMatrix solve(const BaseCMatrix& mB) const {
        TR dErr(0.);
        return this->solve(mB, dErr);
    }

// 6.1: transpose added
/**
@brief Linear solver (transposed)

Creates \ref cmatrix object as solution \f$X\f$ of
matrix linear equation \f$A^T*X=B\f$  (which is equivalent to \f$X^T*A=B^T\f$)
where calling matrix is square complex matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    scmatrix ma(re, im, 3);
    cmatrix  mb(3,2);
    cmatrix  mx(3,2);

    mb(1).set(std::complex<double>(1.,1.));
    mb(1,2) = std::complex<double>(1.,1.);
    mb(2,2) = std::complex<double>(2.,2.);
    mb(3,2) = std::complex<double>(3.,3.);

    mx.solve_tran(ma, mb);
    std::cout << mx
              << std::endl << !ma * mx - mb
              << std::endl << !mx * ma - !mb << std::endl;

    cvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve_tran(vb);
    std::cout << vx << std::endl << vx * ma - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+3.13e-002,-5.31e-001) (+9.38e-002,-9.38e-002)
(+6.25e-002,+6.25e-002) (+1.88e-001,+1.88e-001)
(+3.13e-002,+4.69e-001) (+9.38e-002,+2.40e-001)

(-2.22e-016,-2.22e-016) (+0.00e+000,+0.00e+000)
(-4.44e-016,-4.44e-016) (+0.00e+000,+0.00e+000)
(+8.88e-016,-8.88e-016) (+0.00e+000,+0.00e+000)

(-2.22e-016,-2.22e-016) (-4.44e-016,-4.44e-016) (+8.88e-016,-8.88e-016)
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)

(+9.38e-002,-9.38e-002) (+1.88e-001,+1.88e-001) (+9.38e-002,+2.40e-001)

(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
\endcode
@see solve_tran(const BaseCMatrix&,TR&)const
@param[in] mB \ref cmatrix \f$B\f$.
@return Result object.
*/
    [[nodiscard]] BaseCMatrix solve_tran(const BaseCMatrix& mB) const {
        TR dErr(0.);
        return this->solve_tran(mB, dErr);
    }

// 6.1: conjugate added
/**
@brief Linear solver (Hermitian conjugated)

Creates \ref cmatrix object as solution \f$X\f$ of
matrix linear equation \f$A^H*X=B\f$  (which is equivalent to \f$X^H*A=B^H\f$)
where calling matrix is square complex matrix \f$A\f$
and parameter \c mB is matrix \f$B\f$.
Function throws \ref cvmexception in case of inappropriate sizes
of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    scmatrix ma(re, im, 3);
    cmatrix  mb(3,2);
    cmatrix  mx(3,2);

    mb(1).set(std::complex<double>(1.,1.));
    mb(1,2) = std::complex<double>(1.,1.);
    mb(2,2) = std::complex<double>(2.,2.);
    mb(3,2) = std::complex<double>(3.,3.);

    mx.solve_conj(ma, mb);
    std::cout << mx
              << std::endl << ~ma * mx - mb
              << std::endl << ~mx * ma - ~mb << std::endl;

    cvector vb(3), vx(3);
    vb = mb(2);
    vx = ma.solve_conj(vb);
    std::cout << vx << std::endl << ~ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-5.31e-001,+3.13e-002) (-9.38e-002,+9.38e-002)
(+6.25e-002,+6.25e-002) (+1.88e-001,+1.88e-001)
(+4.69e-001,+3.13e-002) (+2.40e-001,+9.38e-002)

(-2.22e-016,-2.22e-016) (+0.00e+000,+0.00e+000)
(-4.44e-016,-4.44e-016) (+0.00e+000,+0.00e+000)
(-8.88e-016,+8.88e-016) (+0.00e+000,+0.00e+000)

(-2.22e-016,+2.22e-016) (-4.44e-016,+4.44e-016) (-8.88e-016,-8.88e-016)
(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)

(-9.38e-002,+9.38e-002) (+1.88e-001,+1.88e-001) (+2.40e-001,+9.38e-002)

(+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
\endcode
@see solve_conj(const BaseCMatrix&,TR&)const
@param[in] mB \ref cmatrix \f$B\f$.
@return Result object.
*/
    [[nodiscard]] BaseCMatrix solve_conj(const BaseCMatrix& mB) const {
        TR dErr(0.);
        return this->solve_conj(mB, dErr);
    }

// 6.1: reversed MATLAB-style operator B/A returning solution of X*A=B equation
/**
@brief Linear solver operator (transposed)

Creates \ref cvector object as solution \f$x\f$ of linear equation
\f$A^T*x=b\f$ (which is equivalent to \f$x*A=b\f$) where calling matrix is square complex matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Operator throws \ref cvmexception in case of inappropriate sizes
of the operands or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);
try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);
    vx = ma % vb;
    std::cout << vx * ma - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(+0.0000000e+000,+0.0000000e+000) (+0.0000000e+000,+4.4408921e-016)
\endcode
@param[in] vB \ref cvector \f$b\f$.
@return Result object.
*/
    CVector operator % (const CVector& vB) const {
        return vB / (*this);
    }

// 6.1: reversed vector operator % returns solution of A*X=B equation
/**
@brief Linear solver operator

Creates \ref cvector object as solution \f$x\f$ of linear equation
\f$A*x=b\f$ where calling matrix is square complex matrix \f$A\f$
and parameter \c vB is vector \f$b\f$.
Operator throws \ref cvmexception in case of inappropriate sizes
of the operands or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(7);
try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);
    vx = ma / vb;
    std::cout << ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-6.6613381e-016,+4.4408921e-016) (+0.0000000e+000,+0.0000000e+000)
\endcode
@param[in] vB \ref cvector \f$b\f$.
@return Result object.
*/
    CVector operator / (const CVector& vB) const {
        return vB % (*this);
    }

/**
@brief LU factorization based linear solver

Creates an object of type \ref cvector as
solution \f$x\f$ of linear equation
\f$A*x=b\f$ where calling matrix is square complex matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c vB is vector \f$b\f$.
Function also sets output parameter \c dErr to be equal to the norm of computation error.
This function is useful when you need to solve few linear equations
of kind \f$A*x=b\f$ with the same matrix \f$A\f$ and different vectors \f$b\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time.
It also sets output parameter \c dErr to be equal to the norm of computation error
and throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    scmatrix ma(3);
    scmatrix mLU(3);
    cmatrix  mb1(3,2); cvector vb1(3);
    cmatrix  mb2(3,2); cvector vb2(3);
    cmatrix  mx1(3,2); cvector vx1(3);
    cmatrix  mx2(3,2); cvector vx2(3);
    iarray   nPivots(3);
    double   dErr = 0.;
    ma.randomize_real(-1.1,3.); ma.randomize_imag(-3.7,3.);
    mb1.randomize_real(-1.,3.); mb1.randomize_imag(-1.,3.);
    vb1.randomize_real(-2.,3.); vb1.randomize_imag(-3.,1.);
    mb2.randomize_real(-5.,1.); mb2.randomize_imag(-4.,1.);
    vb2.randomize_real(-1.,6.); vb1.randomize_imag(-4.,4.);
    mLU.low_up(ma, nPivots);
    mx1 = ma.solve_lu(mLU, nPivots, mb1, dErr);
    std::cout << mx1 << dErr << std::endl;
    mx2 = ma.solve_lu(mLU, nPivots, mb2);
    std::cout << mx2 << std::endl;;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;
    vx1 = ma.solve_lu(mLU, nPivots, vb1, dErr);
    std::cout << vx1 << dErr << std::endl;
    vx2 = ma.solve_lu(mLU, nPivots, vb2);
    std::cout << vx2 << std::endl;;
    std::cout << ma * vx1 - vb1 << std::endl << ma * vx2 - vb2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-3.91e-001,-1.62e-001) (-3.17e-001,2.39e-001)
(-3.00e-001,-7.91e-001) (4.71e-001,-9.13e-001)
(-2.34e-001,1.09e+000) (1.10e-001,2.72e-001)
2.78e-015
(-2.60e-001,-5.48e-001) (-3.09e-002,-9.62e-001)
(8.77e-001,8.41e-001) (-6.02e-001,1.87e+000)
(4.20e-003,-9.72e-001) (6.18e-001,-5.64e-001)

(0.00e+000,-2.64e-016) (-1.11e-016,1.11e-016)
(0.00e+000,-2.22e-016) (2.22e-016,-4.44e-016)
(0.00e+000,0.00e+000) (-5.55e-017,0.00e+000)

(6.66e-016,-2.22e-016) (6.18e-016,0.00e+000)
(0.00e+000,1.11e-016) (0.00e+000,0.00e+000)
(0.00e+000,0.00e+000) (-4.44e-016,0.00e+000)
(2.61e-001,2.97e-001) (1.95e+000,-1.07e-001) (-5.51e-001,-1.03e-001)
1.96e-015
(1.26e-001,4.07e-001) (-4.82e-001,-1.14e-002) (2.59e-001,1.60e-001)

(1.11e-016,0.00e+000) (5.55e-017,0.00e+000) (1.11e-016,-2.22e-016)

(-1.11e-016,-7.61e-017) (-2.22e-016,-8.94e-017) (0.00e+000,4.07e-017)
\endcode
@see low_up()
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] vB \ref cvector \f$b\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    CVector solve_lu(const basic_scmatrix& mLU, const tint* pPivots,
                     const CVector& vB, TR& dErr) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vB.size());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mLU.msize());
        CVector vX(this->msize());
        this->_solve(vB, vX, dErr, mLU, pPivots, 0);
        return vX;
    }

/**
@brief LU factorization based linear solver

Creates an object of type \ref cvector as
solution \f$x\f$ of linear equation
\f$A*x=b\f$ where calling matrix is square complex matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c vB is vector \f$b\f$.
Function also sets output parameter \c dErr to be equal to the norm of computation error.
This function is useful when you need to solve few linear equations
of kind \f$A*x=b\f$ with the same matrix \f$A\f$ and different vectors \f$b\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time.
It throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    scmatrix ma(3);
    scmatrix mLU(3);
    cmatrix  mb1(3,2); cvector vb1(3);
    cmatrix  mb2(3,2); cvector vb2(3);
    cmatrix  mx1(3,2); cvector vx1(3);
    cmatrix  mx2(3,2); cvector vx2(3);
    iarray   nPivots(3);
    double   dErr = 0.;
    ma.randomize_real(-1.1,3.); ma.randomize_imag(-3.7,3.);
    mb1.randomize_real(-1.,3.); mb1.randomize_imag(-1.,3.);
    vb1.randomize_real(-2.,3.); vb1.randomize_imag(-3.,1.);
    mb2.randomize_real(-5.,1.); mb2.randomize_imag(-4.,1.);
    vb2.randomize_real(-1.,6.); vb1.randomize_imag(-4.,4.);
    mLU.low_up(ma, nPivots);
    mx1 = ma.solve_lu(mLU, nPivots, mb1, dErr);
    std::cout << mx1 << dErr << std::endl;
    mx2 = ma.solve_lu(mLU, nPivots, mb2);
    std::cout << mx2 << std::endl;;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;
    vx1 = ma.solve_lu(mLU, nPivots, vb1, dErr);
    std::cout << vx1 << dErr << std::endl;
    vx2 = ma.solve_lu(mLU, nPivots, vb2);
    std::cout << vx2 << std::endl;;
    std::cout << ma * vx1 - vb1 << std::endl << ma * vx2 - vb2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-3.91e-001,-1.62e-001) (-3.17e-001,2.39e-001)
(-3.00e-001,-7.91e-001) (4.71e-001,-9.13e-001)
(-2.34e-001,1.09e+000) (1.10e-001,2.72e-001)
2.78e-015
(-2.60e-001,-5.48e-001) (-3.09e-002,-9.62e-001)
(8.77e-001,8.41e-001) (-6.02e-001,1.87e+000)
(4.20e-003,-9.72e-001) (6.18e-001,-5.64e-001)

(0.00e+000,-2.64e-016) (-1.11e-016,1.11e-016)
(0.00e+000,-2.22e-016) (2.22e-016,-4.44e-016)
(0.00e+000,0.00e+000) (-5.55e-017,0.00e+000)

(6.66e-016,-2.22e-016) (6.18e-016,0.00e+000)
(0.00e+000,1.11e-016) (0.00e+000,0.00e+000)
(0.00e+000,0.00e+000) (-4.44e-016,0.00e+000)
(2.61e-001,2.97e-001) (1.95e+000,-1.07e-001) (-5.51e-001,-1.03e-001)
1.96e-015
(1.26e-001,4.07e-001) (-4.82e-001,-1.14e-002) (2.59e-001,1.60e-001)

(1.11e-016,0.00e+000) (5.55e-017,0.00e+000) (1.11e-016,-2.22e-016)

(-1.11e-016,-7.61e-017) (-2.22e-016,-8.94e-017) (0.00e+000,4.07e-017)
\endcode
@see low_up()
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] vB \ref cvector \f$b\f$.
@return Result object.
*/
    CVector solve_lu(const basic_scmatrix& mLU,
                     const tint* pPivots, const CVector& vB) const {
        TR dErr(0.);
        return this->solve_lu(mLU, pPivots, vB, dErr);
    }

/**
@brief LU factorization based linear solver

Creates an object of type \ref cmatrix as
solution \f$X\f$ of a matrix linear equation
\f$A*X=B\f$ where calling matrix is square complex matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c mB is matrix \f$B\f$.
This function is useful when you need to solve few linear equations
of kind \f$A*X=B\f$ with the same matrix \f$A\f$ and different matrices \f$B\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time.
Function also sets output parameter \c dErr to be equal to the norm of computation error
and throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    scmatrix ma(3);
    scmatrix mLU(3);
    cmatrix  mb1(3,2); cvector vb1(3);
    cmatrix  mb2(3,2); cvector vb2(3);
    cmatrix  mx1(3,2); cvector vx1(3);
    cmatrix  mx2(3,2); cvector vx2(3);
    iarray   nPivots(3);
    double   dErr = 0.;
    ma.randomize_real(-1.1,3.); ma.randomize_imag(-3.7,3.);
    mb1.randomize_real(-1.,3.); mb1.randomize_imag(-1.,3.);
    vb1.randomize_real(-2.,3.); vb1.randomize_imag(-3.,1.);
    mb2.randomize_real(-5.,1.); mb2.randomize_imag(-4.,1.);
    vb2.randomize_real(-1.,6.); vb1.randomize_imag(-4.,4.);
    mLU.low_up(ma, nPivots);
    mx1 = ma.solve_lu(mLU, nPivots, mb1, dErr);
    std::cout << mx1 << dErr << std::endl;
    mx2 = ma.solve_lu(mLU, nPivots, mb2);
    std::cout << mx2 << std::endl;;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;
    vx1 = ma.solve_lu(mLU, nPivots, vb1, dErr);
    std::cout << vx1 << dErr << std::endl;
    vx2 = ma.solve_lu(mLU, nPivots, vb2);
    std::cout << vx2 << std::endl;;
    std::cout << ma * vx1 - vb1 << std::endl << ma * vx2 - vb2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-3.91e-001,-1.62e-001) (-3.17e-001,2.39e-001)
(-3.00e-001,-7.91e-001) (4.71e-001,-9.13e-001)
(-2.34e-001,1.09e+000) (1.10e-001,2.72e-001)
2.78e-015
(-2.60e-001,-5.48e-001) (-3.09e-002,-9.62e-001)
(8.77e-001,8.41e-001) (-6.02e-001,1.87e+000)
(4.20e-003,-9.72e-001) (6.18e-001,-5.64e-001)

(0.00e+000,-2.64e-016) (-1.11e-016,1.11e-016)
(0.00e+000,-2.22e-016) (2.22e-016,-4.44e-016)
(0.00e+000,0.00e+000) (-5.55e-017,0.00e+000)

(6.66e-016,-2.22e-016) (6.18e-016,0.00e+000)
(0.00e+000,1.11e-016) (0.00e+000,0.00e+000)
(0.00e+000,0.00e+000) (-4.44e-016,0.00e+000)
(2.61e-001,2.97e-001) (1.95e+000,-1.07e-001) (-5.51e-001,-1.03e-001)
1.96e-015
(1.26e-001,4.07e-001) (-4.82e-001,-1.14e-002) (2.59e-001,1.60e-001)

(1.11e-016,0.00e+000) (5.55e-017,0.00e+000) (1.11e-016,-2.22e-016)

(-1.11e-016,-7.61e-017) (-2.22e-016,-8.94e-017) (0.00e+000,4.07e-017)
\endcode
@see low_up()
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] mB \ref cmatrix \f$B\f$.
@param[out] dErr Norm of computation error.
@return Result object.
*/
    BaseCMatrix solve_lu(const basic_scmatrix& mLU, const tint* pPivots,
                         const BaseCMatrix& mB, TR& dErr) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mB.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mLU.msize());
        BaseCMatrix mX(mB.msize(), mB.nsize());
        this->_solve(mB, mX, dErr, mLU, pPivots, 0);
        return mX;
    }

/**
@brief LU factorization based linear solver

Creates an object of type \ref cmatrix as
solution \f$X\f$ of a matrix linear equation
\f$A*X=B\f$ where calling matrix is square complex matrix \f$A\f$,
parameter \c mLU is LU factorization (see \ref low_up() )
of a matrix \f$A\f$, parameter \c pPivots is an array of pivot numbers
created while factorizing matrix \f$A\f$ and parameter \c mB is matrix \f$B\f$.
This function is useful when you need to solve few linear equations
of kind \f$A*X=B\f$ with the same matrix \f$A\f$ and different matrices \f$B\f$.
In such case you save on matrix \f$A\f$ factorization since it's needed to be
performed just one time.
Function throws \ref cvmexception
in case of inappropriate sizes of the objects or when matrix \f$A\f$ is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    scmatrix ma(3);
    scmatrix mLU(3);
    cmatrix  mb1(3,2); cvector vb1(3);
    cmatrix  mb2(3,2); cvector vb2(3);
    cmatrix  mx1(3,2); cvector vx1(3);
    cmatrix  mx2(3,2); cvector vx2(3);
    iarray   nPivots(3);
    double   dErr = 0.;
    ma.randomize_real(-1.1,3.); ma.randomize_imag(-3.7,3.);
    mb1.randomize_real(-1.,3.); mb1.randomize_imag(-1.,3.);
    vb1.randomize_real(-2.,3.); vb1.randomize_imag(-3.,1.);
    mb2.randomize_real(-5.,1.); mb2.randomize_imag(-4.,1.);
    vb2.randomize_real(-1.,6.); vb1.randomize_imag(-4.,4.);
    mLU.low_up(ma, nPivots);
    mx1 = ma.solve_lu(mLU, nPivots, mb1, dErr);
    std::cout << mx1 << dErr << std::endl;
    mx2 = ma.solve_lu(mLU, nPivots, mb2);
    std::cout << mx2 << std::endl;;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;
    vx1 = ma.solve_lu(mLU, nPivots, vb1, dErr);
    std::cout << vx1 << dErr << std::endl;
    vx2 = ma.solve_lu(mLU, nPivots, vb2);
    std::cout << vx2 << std::endl;;
    std::cout << ma * vx1 - vb1 << std::endl << ma * vx2 - vb2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-3.91e-001,-1.62e-001) (-3.17e-001,2.39e-001)
(-3.00e-001,-7.91e-001) (4.71e-001,-9.13e-001)
(-2.34e-001,1.09e+000) (1.10e-001,2.72e-001)
2.78e-015
(-2.60e-001,-5.48e-001) (-3.09e-002,-9.62e-001)
(8.77e-001,8.41e-001) (-6.02e-001,1.87e+000)
(4.20e-003,-9.72e-001) (6.18e-001,-5.64e-001)

(0.00e+000,-2.64e-016) (-1.11e-016,1.11e-016)
(0.00e+000,-2.22e-016) (2.22e-016,-4.44e-016)
(0.00e+000,0.00e+000) (-5.55e-017,0.00e+000)

(6.66e-016,-2.22e-016) (6.18e-016,0.00e+000)
(0.00e+000,1.11e-016) (0.00e+000,0.00e+000)
(0.00e+000,0.00e+000) (-4.44e-016,0.00e+000)
(2.61e-001,2.97e-001) (1.95e+000,-1.07e-001) (-5.51e-001,-1.03e-001)
1.96e-015
(1.26e-001,4.07e-001) (-4.82e-001,-1.14e-002) (2.59e-001,1.60e-001)

(1.11e-016,0.00e+000) (5.55e-017,0.00e+000) (1.11e-016,-2.22e-016)

(-1.11e-016,-7.61e-017) (-2.22e-016,-8.94e-017) (0.00e+000,4.07e-017)
\endcode
@see low_up()
@param[in] mLU LU factorization of a matrix \f$A\f$.
@param[in] pPivots pivots vector.
@param[in] mB \ref cmatrix \f$B\f$.
@return Result object.
*/
    BaseCMatrix solve_lu(const basic_scmatrix& mLU,
                         const tint* pPivots,
                         const BaseCMatrix& mB) const {
        TR dErr(0.);
        return this->solve_lu(mLU, pPivots, mB, dErr);
    }

/**
@brief Matrix determinant

Returns determinant of a calling matrix.
It uses the LU factorization internally and may throw the same exceptions as the factorizer.
\par Example:
\code
using namespace cvm;
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {-1., 2., -3., -4., 5., -6., 7., -8., 9.};
    const scmatrix m(re, im, 3);
    std::cout << m << std::endl << m.det() << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1,-1) (4,-4) (7,7)
(2,2) (5,5) (8,-8)
(3,-3) (6,-6) (9,9)

(-192,-192)
\endcode
@see low_up()
@return Determinant value.
*/
    [[nodiscard]] TC det() const {
        return this->_det();
    }

/**
@brief Low-up (LU) factorization

Compute LU factorization of square complex matrix \f$A\f$ as
\f[
A=PLU
\f]
where \f$P\f$ is permutation matrix, \f$L\f$ is lower
triangular matrix with unit diagonal
elements and \f$U\f$ is upper triangular matrix.
Function stores result as the matrix \f$L\f$ without
main diagonal combined with \f$U\f$. Function
returns pivot indices as  array of integers
(it should support at least \ref msize() elements)
pointed to by \c nPivots so \f$i\f$-th row
was interchanged with \c nPivots[\f$i\f$]-th row.
This version sets calling matrix to be equal to matrix
\c m's LU factorization.
Function throws \ref cvmexception in case of inappropriate
sizes of the operands or when the matrix to be factorized is close to
singular. It is recommended to use \ref iarray for pivot values.
\par Example:
\code
using namespace cvm;
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.1};
    scmatrix m(re, im, 3);
    scmatrix mLU(3), mLo(3), mUp(3);
    iarray naPivots(3);

    mLU.low_up(m, naPivots);

    mLo.identity();
    mLo.diag(-2) = mLU.diag(-2);
    mLo.diag(-1) = mLU.diag(-1);
    mUp.diag(0) = mLU.diag(0);
    mUp.diag(1) = mLU.diag(1);
    mUp.diag(2) = mLU.diag(2);

    std::cout << mLo << std::endl << mUp
              << std::endl << naPivots << std::endl;

    mLU = mLo * mUp;
    for (int i = 3; i >= 1; i--) {
        mLU.swap_rows(i, naPivots[i]);
    }
    std::cout << mLU << std::endl << m - mLU;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1,0) (0,0) (0,0)
(0.333333,0) (1,0) (0,0)
(0.666667,0) (0.5,0) (1,0)

(3,3) (6,6) (9,9.1)
(0,0) (2,2) (4,3.96667)
(0,0) (0,0) (-1.11022e-016,-0.05)

3 3 3

(1,1) (4,4) (7,7)
(2,2) (5,5) (8,8)
(3,3) (6,6) (9,9.1)

(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
@param[in] m \ref scmatrix to compute LU factorization for.
@param[out] nPivots %Array of pivot indices.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& low_up(const basic_scmatrix& m, tint* nPivots) {
        (*this) = m;
        this->_low_up(nPivots);
        return *this;
    }

/**
@brief Low-up (LU) factorization

Compute LU factorization of square complex matrix \f$A\f$ as
\f[
A=PLU
\f]
where \f$P\f$ is permutation matrix, \f$L\f$ is lower
triangular matrix with unit diagonal
elements and \f$U\f$ is upper triangular matrix.
Function stores result as the matrix \f$L\f$ without
main diagonal combined with \f$U\f$. Function
returns pivot indices as  array of integers
(it should support at least \ref msize() elements)
pointed to by \c nPivots so \f$i\f$-th row
was interchanged with \c nPivots[\f$i\f$]-th row.
This version creates an object of type \ref srmatrix as calling matrix LU factorization.
Function throws \ref cvmexception in case of inappropriate
sizes of the operands or when the matrix to be factorized is close to
singular. It is recommended to use \ref iarray for pivot values.
\par Example:
\code
using namespace cvm;
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.1};
    scmatrix m(re, im, 3);
    scmatrix mLU(3), mLo(3), mUp(3);
    iarray naPivots(3);

    mLU = m.low_up(naPivots);

    mLo.identity();
    mLo.diag(-2) = mLU.diag(-2);
    mLo.diag(-1) = mLU.diag(-1);
    mUp.diag(0) = mLU.diag(0);
    mUp.diag(1) = mLU.diag(1);
    mUp.diag(2) = mLU.diag(2);

    std::cout << mLo << std::endl << mUp
              << std::endl << naPivots << std::endl;

    mLU = mLo * mUp;
    for (int i = 3; i >= 1; i--) {
        mLU.swap_rows(i, naPivots[i]);
    }
    std::cout << mLU << std::endl << m - mLU;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1,0) (0,0) (0,0)
(0.333333,0) (1,0) (0,0)
(0.666667,0) (0.5,0) (1,0)

(3,3) (6,6) (9,9.1)
(0,0) (2,2) (4,3.96667)
(0,0) (0,0) (-1.11022e-016,-0.05)

3 3 3

(1,1) (4,4) (7,7)
(2,2) (5,5) (8,8)
(3,3) (6,6) (9,9.1)

(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
@param[out] nPivots %Array of pivot indices.
@return Result object.
*/
    basic_scmatrix low_up(tint* nPivots) const {
        basic_scmatrix mRes(*this);
        mRes._low_up(nPivots);
        return mRes;
    }

/**
@brief Condition number reciprocal

Returns condition number reciprocal of
a calling matrix \f$A\f$ in the infinity-norm
\f[
\kappa_\infty=\|A\|_\infty \|A^{-1}\|_\infty.
\f]
Less value returned means that matrix \f$A\f$ is closer to singular.
Zero value returned means estimation underflow or
that matrix \f$A\f$ is singular.
The condition number is used for error analysis of systems of linear equations.
Function throws \ref cvmexception in case of LAPACK subroutines failure.
\par Example:
\code
using namespace cvm;
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};

    scmatrix m(re, im, 3);
    std::cout << m.cond() << std::endl
              << m.det() << std::endl << std::endl;

    m(3,3) = std::complex<double>(9.,10.);
    std::cout << m.cond() << std::endl << m.det() << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1.54198e-018
(1.33227e-015,-1.33227e-015)

0.0050679
(6,-1.33227e-015)
\endcode
@see basic_array::norminf()
@return Result value.
*/
    [[nodiscard]] TR cond() const {
        TR dCondNum(0.);
        __cond_num<TR,basic_scmatrix>(*this, dCondNum);  // universal method, no need to virtualize
        return dCondNum;
    }

/**
@brief Matrix inversion

This version sets calling matrix to be equal to square complex matrix \c m inverted.
Function throws \ref cvmexception in case of inappropriate
sizes of the operands or when the matrix to be inverted is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    scmatrix m(re, im, 3);
    scmatrix mi(3);

    mi.inv(m);
    std::cout << mi << std::endl << mi * m - eye_complex(3);
    std::cout << std::endl << mi.inv() * mi - eye_complex(3);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-8.33e-001,-1.67e-001) (6.67e-001,1.33e+000) (4.81e-016,-1.00e+000)
(3.33e-001,1.67e+000) (-1.67e-001,-3.83e+000) (-5.37e-016,2.00e+000)
(2.22e-016,-1.00e+000) (-4.44e-016,2.00e+000) (2.22e-016,-1.00e+000)

(-1.11e-016,1.11e-016) (0.00e+000,2.22e-016) (8.33e-017,1.26e-015)
(4.44e-016,-5.00e-016) (0.00e+000,7.77e-016) (7.22e-016,-1.15e-015)
(-1.11e-016,1.11e-016) (2.22e-016,-6.66e-016) (0.00e+000,1.11e-016)

(4.44e-016,4.44e-016) (-1.18e-015,1.33e-015) (6.66e-016,-7.77e-016)
(-6.85e-016,8.88e-016) (1.33e-015,3.16e-030) (-8.33e-016,-1.77e-030)
(-5.09e-016,6.66e-016) (7.96e-016,-1.78e-015) (-4.44e-016,1.11e-016)
\endcode
@param[in] m \ref scmatrix to invert.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& inv(const basic_scmatrix& m) {
        __inv<basic_scmatrix>(*this, m);
        return *this;
    }

/**
@brief Matrix inversion

This version creates \ref scmatrix object equal to a calling matrix inverted.
Function throws \ref cvmexception in case of memory allocation failure
or when the matrix to be inverted is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    scmatrix m(re, im, 3);
    scmatrix mi(3);

    mi.inv(m);
    std::cout << mi << std::endl << mi * m - eye_complex(3);
    std::cout << std::endl << mi.inv() * mi - eye_complex(3);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-8.33e-001,-1.67e-001) (6.67e-001,1.33e+000) (4.81e-016,-1.00e+000)
(3.33e-001,1.67e+000) (-1.67e-001,-3.83e+000) (-5.37e-016,2.00e+000)
(2.22e-016,-1.00e+000) (-4.44e-016,2.00e+000) (2.22e-016,-1.00e+000)

(-1.11e-016,1.11e-016) (0.00e+000,2.22e-016) (8.33e-017,1.26e-015)
(4.44e-016,-5.00e-016) (0.00e+000,7.77e-016) (7.22e-016,-1.15e-015)
(-1.11e-016,1.11e-016) (2.22e-016,-6.66e-016) (0.00e+000,1.11e-016)

(4.44e-016,4.44e-016) (-1.18e-015,1.33e-015) (6.66e-016,-7.77e-016)
(-6.85e-016,8.88e-016) (1.33e-015,3.16e-030) (-8.33e-016,-1.77e-030)
(-5.09e-016,6.66e-016) (7.96e-016,-1.78e-015) (-4.44e-016,1.11e-016)
\endcode
@return Result object.
*/
    [[nodiscard]] basic_scmatrix inv() const {
        basic_scmatrix mRes(this->msize());
        __inv<basic_scmatrix>(mRes, *this);
        return mRes;
    }

/**
@brief Matrix exponent

Computes exponent of square complex matrix using Pade approximation defined as
\f[
R_{pq}(z)=D_{pq}(z)^{-1}N_{pq}(z)=1+z+\dots+z^p/p!\,,
\f]
where
\f[\begin{aligned}
N_{pq}(z)&=\sum_{k=0}^p\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}z^k,\\
D_{pq}(z)&=\sum_{k=0}^q\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}(-z)^k
\end{aligned}\f]
along with the matrix normalizing as described in
<em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 572.
Function uses \ref DMEXP (or \ref SMEXP for \c float version)
\c FORTRAN subroutine implementing the algorithm.
This version sets calling matrix to be equal to
exponent of \c m and returns a reference to the matrix changed.
The algorithm uses parameter \c tol as \f$\varepsilon(p,q)\f$ in order to choose constants \f$p\f$ and \f$q\f$
so that
\f[
\varepsilon(p,q)\ge 2^{3-(p+q)}\frac{p!q!}{(p+q)!(p+q+1)!}.
\f]
This parameter is equal to the <em>largest relative spacing</em> (see cvmMachSp() ) by default.
Functions throw \ref cvmexception in case of
inappropriate sizes of the operands or when LAPACK subroutine fails.
\par Example
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(15);
try {
    scmatrix m(2);
    m(1,1) = std::complex<double>(-49.,1.);
    m(1,2) = std::complex<double>(24.,1.);
    m(2,1) = std::complex<double>(-64.,1.);
    m(2,2) = std::complex<double>(31.,1.);

    m.exp(m);
    std::cout << m(1,1) << std::endl << "   "
              << m(1,2) << std::endl;
    std::cout << m(2,1) << std::endl << "   "
              << m(2,2) << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-4.508497580069049e-001,7.900659666738140e-001)
   (3.199576050797298e-001,-6.081804753523605e-001)
(-7.584316151930286e-001,1.666747485117659e+000)
   (5.295040786046933e-001,-1.278050361026203e+000)
   \endcode
Matlab output:
\code
  Column 1

    -4.508497580070262e-001 +7.900659666739607e-001i
    -7.584316151932523e-001 +1.666747485117982e+000i

  Column 2

     3.199576050798204e-001 -6.081804753524764e-001i
     5.295040786048589e-001 -1.278050361026457e+000i
\endcode
@param[in] m \ref scmatrix to compute exponent for.
@param[in] tol Computation tolerance.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& exp(const basic_scmatrix& m, TR tol = basic_cvmMachSp<TR>()) {
        __exp<basic_scmatrix, TR>(*this, m, tol);
        return *this;
    }

/**
@brief Matrix exponent

Computes exponent of square matrix using Pade approximation defined as
\f[
R_{pq}(z)=D_{pq}(z)^{-1}N_{pq}(z)=1+z+\dots+z^p/p!\,,
\f]
where
\f[\begin{aligned}
N_{pq}(z)&=\sum_{k=0}^p\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}z^k,\\
D_{pq}(z)&=\sum_{k=0}^q\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}(-z)^k
\end{aligned}\f]
along with the matrix normalizing as described in
<em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 572.
Function uses \ref DMEXP (or \ref SMEXP for \c float version)
\c FORTRAN subroutine implementing the algorithm.
This version creates an object of type \c scmatrix as exponent of a calling matrix.
The algorithm uses parameter \c tol as \f$\varepsilon(p,q)\f$ in order to choose constants \f$p\f$ and \f$q\f$
so that
\f[
\varepsilon(p,q)\ge 2^{3-(p+q)}\frac{p!q!}{(p+q)!(p+q+1)!}.
\f]
This parameter is equal to the <em>largest relative spacing</em> (see cvmMachSp() ) by default.
Functions throw \ref cvmexception in case of
inappropriate sizes of the operands or when LAPACK subroutine fails.
\par Example
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(15);
try {
    scmatrix m(2);
    m(1,1) = std::complex<double>(-49.,1.);
    m(1,2) = std::complex<double>(24.,1.);
    m(2,1) = std::complex<double>(-64.,1.);
    m(2,2) = std::complex<double>(31.,1.);

    m = m.exp();
    std::cout << m(1,1) << std::endl << "   "
              << m(1,2) << std::endl;
    std::cout << m(2,1) << std::endl << "   "
              << m(2,2) << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(-4.508497580070061e-001,7.900659666739228e-001)
   (3.199576050798058e-001,-6.081804753524478e-001)
(-7.584316151932173e-001,1.666747485117903e+000)
   (5.295040786048336e-001,-1.278050361026397e+000)
\endcode
Matlab output:
\code
  Column 1

    -4.508497580070262e-001 +7.900659666739607e-001i
    -7.584316151932523e-001 +1.666747485117982e+000i

  Column 2

     3.199576050798204e-001 -6.081804753524764e-001i
     5.295040786048589e-001 -1.278050361026457e+000i
\endcode
@param[in] tol Computation tolerance.
@return Result object.
*/
    [[nodiscard]] basic_scmatrix exp(TR tol = basic_cvmMachSp<TR>()) const {
        basic_scmatrix mRes(this->msize());
        __exp<basic_scmatrix, TR>(mRes, *this, tol);
        return mRes;
    }

// this = v(1)*I + v(2)*m + v(3)*m^2 + ... + v(N)*m^(N-1)
/**
@brief Matrix polynomial

Computes matrix polynomial defined as
\f[
p(A)=b_0I+b_1A+\dots+b_qA^q
\f]
using the Horner's rule:
\f[
\newcommand{\floor}{\operatorname{floor}}p(A)=\sum_{k=0}^r B_k(A^s)^k,\quad s=\floor(\!\sqrt{q}\,),\ r=\floor(q/s)
\f]
where
\f[
B_k=\begin{cases}
\sum\limits_{i=0}^{s-1}b_{sk+i} A^i, & k=0,1,\dots,r-1\\
\sum\limits_{i=0}^{q-sr}b_{sr+i} A^i, & k=r.
\end{cases}
\f]
See also <em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 568.
The coefficients \f$b_0,b_1,\dots,b_q\f$ are passed in parameter \c v,
where \f$q\f$ is equal to \c v.size()-1, so the function
computes matrix polynomial equal to
\f[
\mathtt{v[1]*I + v[2]*m +\cdots + v[v.size()]*m^{v.size()-1}}
\f]
This version sets calling matrix to be equal to the polynomial of \c m.
Function uses \ref DPOLY (or \ref SPOLY for \c float version) \c FORTRAN subroutine implementing the Horner's algorithm.
Function throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(15);
try {
    const double re[] = {2.2, 1.3, 1.1, -0.9, 0.2,
                        -0.45, 45., -30., 10., 3., 0.};
    const double im[] = {0.5, -2, 0, 1, 3,
                        -3., 30., 0., -9., 0., 1.};
    const cvector v(re, im, 11);
    scmatrix m(2), mp(2);
    m(1,1) = std::complex<double>(0.1, -0.2);
    m(1,2) = std::complex<double>(0.1, -0.2);
    m(2,1) = std::complex<double>(0.5, -0.6);
    m(2,2) = std::complex<double>(0.3, -0.4);

    mp.polynom(m, v);
    std::cout << mp(1,1) << std::endl << "   "
              << mp(1,2) << std::endl;
    std::cout << mp(2,1) << std::endl << "   "
              << mp(2,2) << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(2.485652665600000e+000,3.791263308800001e+000)
   (2.817786176000004e-001,2.301942860800001e+000)
(-8.835069888000001e-001,8.052028620800002e+000)
   (1.903009862400001e+000,6.666306188800002e+000)
\endcode
Matlab output:
\code
  Column 1

     2.485652665600000e+000 +3.791263308800001e+000i
    -8.835069887999991e-001 +8.052028620800002e+000i

  Column 2

     2.817786176000000e-001 +2.301942860800001e+000i
     1.903009862399999e+000 +6.666306188800003e+000i
\endcode
@param[in] m \ref scmatrix to compute polynomial for.
@param[in] v Vector of coefficients.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& polynom(const basic_scmatrix& m, const CVector& v) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        CVector v1;
        if (v.incr() > 1) v1 << v;  // to make sure incr = 1
        __polynom<TC, CVector>(this->get(), this->ld(), this->msize(), m._pd(), m._ldm(), v.incr() > 1 ? v1 : v);
        return *this;
    }

// returns v(1)*I + v(2)*this + v(3)*this^2 + ... + v(N)*this^(N-1)
/**
@brief Matrix polynomial

Computes matrix polynomial defined as
\f[
p(A)=b_0I+b_1A+\dots+b_qA^q
\f]
using the Horner's rule:
\f[
\newcommand{\floor}{\operatorname{floor}}p(A)=\sum_{k=0}^r B_k(A^s)^k,\quad s=\floor(\!\sqrt{q}\,),\ r=\floor(q/s)
\f]
where
\f[
B_k=\begin{cases}
\sum\limits_{i=0}^{s-1}b_{sk+i} A^i, & k=0,1,\dots,r-1\\
\sum\limits_{i=0}^{q-sr}b_{sr+i} A^i, & k=r.
\end{cases}
\f]
See also <em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 568.
The coefficients \f$b_0,b_1,\dots,b_q\f$ are passed in parameter \c v,
where \f$q\f$ is equal to \c v.size()-1, so the function
computes matrix polynomial equal to
\f[
\mathtt{v[1]*I + v[2]*m +\cdots + v[v.size()]*m^{v.size()-1}}
\f]
This version creates an object of type \ref srmatrix as the polynomial of a calling matrix.
Function uses \ref DPOLY (or \ref SPOLY for \c float version) \c FORTRAN subroutine implementing the Horner's algorithm.
Function throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(15);
try {
    const double re[] = {2.2, 1.3, 1.1, -0.9, 0.2,
                        -0.45, 45., -30., 10., 3., 0.};
    const double im[] = {0.5, -2, 0, 1, 3,
                        -3., 30., 0., -9., 0., 1.};
    const cvector v(re, im, 11);
    scmatrix m(2), mp(2);
    m(1,1) = std::complex<double>(0.1, -0.2);
    m(1,2) = std::complex<double>(0.1, -0.2);
    m(2,1) = std::complex<double>(0.5, -0.6);
    m(2,2) = std::complex<double>(0.3, -0.4);

    mp = m.polynom(v);
    std::cout << mp(1,1) << std::endl << "   "
              << mp(1,2) << std::endl;
    std::cout << mp(2,1) << std::endl << "   "
              << mp(2,2) << std::endl;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(2.485652665600000e+000,3.791263308800001e+000)
   (2.817786176000004e-001,2.301942860800001e+000)
(-8.835069888000001e-001,8.052028620800002e+000)
   (1.903009862400001e+000,6.666306188800002e+000)
\endcode
Matlab output:
\code
  Column 1

     2.485652665600000e+000 +3.791263308800001e+000i
    -8.835069887999991e-001 +8.052028620800002e+000i

  Column 2

     2.817786176000000e-001 +2.301942860800001e+000i
     1.903009862399999e+000 +6.666306188800003e+000i
\endcode
@param[in] v Vector of coefficients.
@return Result object.
*/
    [[nodiscard]] basic_scmatrix polynom(const CVector& v) const {
        basic_scmatrix mRes(this->msize());
        CVector v1;
        if (v.incr() > 1) v1 << v;  // to make sure incr = 1
        __polynom<TC, CVector>(mRes.get(), mRes.ld(), this->msize(), this->get(), this->ld(), v.incr() > 1 ? v1 : v);
        return mRes;
    }

/**
@brief Eigenvalues and eigenvectors

Solves eigenvalue problem and creates \ref cvector object equal to eigenvalues
of a calling matrix.
The eigenvalue problem is defined as follows: given square matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
Some eigenvalues may be complex even for real matrix \f$A\f$.
Moreover, if real nonsymmetric matrix has a complex eigenvalue \f$a+bi\f$
corresponding to an eigenvector \f$z\f$, then \f$a-bi\f$ is also an eigenvalue.
The eigenvalue \f$a-bi\f$ corresponds to the eigenvector whose elements
are complex conjugate to the elements of \f$z\f$.
Function sets output parameter \c mEigVect to be equal to square matrix containing eigenvectors as columns.
Function also computes "left" eigenvectors if parameter \c bRightVect is set to \c false.
Left eigencectors satisfy
\f[
z^HA = \lambda z^H.
\f]
Function throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    scmatrix m(re, im, 3);
    scmatrix me(3);
    cvector vl(3);

    vl = m.eig(me);
    std::cout << vl << std::endl;
    std::cout.setf(std::ios::scientific | std::ios::left);
    std::cout.precision(2);
    std::cout << m * me(1) - me(1) * vl(1);
    std::cout << m * me(2) - me(2) * vl(2);
    std::cout << m * me(3) - me(3) * vl(3);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(16.1096,16.7004) (-1.09351,-0.88358) (-0.0161248,0.183218)

(-9.44e-016,-3.55e-015) (-1.11e-016,-1.07e-014) (2.66e-015,-1.42e-014)
(-5.55e-016,-4.44e-016) (-1.80e-015,9.44e-016) (-2.00e-015,7.22e-016)
(9.92e-016,1.24e-015) (1.05e-015,2.78e-017) (1.64e-015,9.30e-016)
\endcode
@see cvector::eig()
@param[out] mEigVect Eigenvectors of \c mA.
@param[in] bRightVect \c true (default) to compute right eigenvectors.
@return Result object.
*/
    CVector eig(basic_scmatrix& mEigVect, bool bRightVect = true) const {
        CVector vEig(this->msize());
        this->_eig(vEig, &mEigVect, bRightVect);
        return vEig;
    }

/**
@brief Eigenvalues

Solves eigenvalue problem and creates \ref cvector object equal to eigenvalues
of a calling matrix.
The eigenvalue problem is defined as follows: given square matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
Some eigenvalues may be complex even for real matrix \f$A\f$.
Moreover, if real nonsymmetric matrix has a complex eigenvalue \f$a+bi\f$
corresponding to an eigenvector \f$z\f$, then \f$a-bi\f$ is also an eigenvalue.
The eigenvalue \f$a-bi\f$ corresponds to the eigenvector whose elements
are complex conjugate to the elements of \f$z\f$.
Function throws \ref cvmexception
in case of in caso of memory allocation failure or convergence error.
\par Example:
\code
using namespace cvm;
try {
    double re[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
    double im[] = {1., 2., 3., 4., 5., 6., 7., 8., 10.};
    scmatrix m(re, im, 3);
    std::cout << m.eig();
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(16.1096,16.7004) (-1.09351,-0.88358) (-0.0161248,0.183218)
\endcode
@see cvector::eig()
@return Result object.
*/
    [[nodiscard]] CVector eig() const {
        CVector vEig(this->msize());
        this->_eig(vEig, nullptr, false);
        return vEig;
    }

/**
@brief Cholesky factorization

Forms the Cholesky factorization of Hermitian positive-definite complex matrix \f$A\f$ defined as
\f[
A=U^T U,
\f]
where \f$U\f$ is upper triangular matrix.
It utilizes one of \c ZPOTRF routines of the
\c LAPACK library. Function sets calling matrix to be equal to the factorization
of Hermitian positive-definite matrix \c m.
Function throws \ref cvmexception in case of inappropriate sizes of the operands
or in case of convergence error.
\par Example:
\code
using namespace cvm;
try {
    double r[] = {1., 2., 1., 2., 15., -1., 1., -1., 20.};
    double i[] = {0., -1., 2., 1., 0., 3., -2., -3., 0.};
    const schmatrix m(r, i, 3);
    scmatrix c(3);

    c.cholesky(m);

    std::cout << c << std::endl;
    std::cout << ~c * c - m;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(1,0) (2,1) (1,-2)
(0,-0) (3.16228,0) (-0.316228,0.632456)
(0,0) (-0,0) (3.80789,0)

(0,0) (0,0) (0,0)
(0,0) (1.77636e-015,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
@see http://www.netlib.org/lapack
@param[in] m \ref schmatrix to factorize.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& cholesky(const basic_schmatrix<TR,TC>& m) {
        this->_check_cholesky();  // doesn't work for band matrices
        *this = m;
        tint nOutInfo = __cholesky<basic_scmatrix>(*this);
        _check_negative(CVM_WRONGMKLARG, nOutInfo);
        _check_positive(CVM_NOTPOSITIVEDEFINITE, nOutInfo);
        this->_clean_low_triangle();
        return *this;
    }

/**
@brief Bunch-Kaufman factorization

Forms the Bunch-Kaufman factorization of Hermitian matrix (cited from the MKL library documentation):
\f[
A=PUDU^TP^T,
\f]
where \f$A\f$ is the input matrix passed in parameter \c m,
\f$P\f$ is a permutation matrix, \f$U\f$ and \f$L\f$ are upper and lower triangular
matrices with unit diagonal, and \f$D\f$ is a symmetric
block-diagonal matrix with 1-by-1 and 2-by-2
diagonal blocks. \f$U\f$ and \f$L\f$ have 2-by-2 unit diagonal
blocks corresponding to the 2-by-2 blocks of \f$D\f$.
It utilizes one of \c ZHETRF routines of the \c LAPACK library.
Function sets calling matrix to be equal to the factorization
of symmetric positive-definite matrix \c m.
Function throws \ref cvmexception in case of inappropriate sizes of the operands
or in case of convergence error.
Function is mostly designed to be used for subsequent calls
of \c ZHETRS, \c ZHECON and \c ZHETRI routines of the
\c LAPACK library.
Currently it's used internally in \ref det() flow
when argument is symmetric but not positive-definite.

@see http://www.netlib.org/lapack
@param[in] m \ref schmatrix to factorize.
@param[out] nPivots Pivot indices array.
@return Reference to changed calling matrix.
*/
    basic_scmatrix& bunch_kaufman(const basic_schmatrix<TR,TC>& m, tint* nPivots) {
        this->_check_bunch_kaufman();  // doesn't work for band matrices
        *this = m;
        __bunch_kaufman<basic_scmatrix>(*this, nPivots);
        return *this;
    }

/**
@brief QR factorization

Computes QR factorization as
\f[
A=QR
\f]
where \f$A\f$ is calling square complex matrix, orthogonal matrix \f$Q\f$
and upper triangular matrix \f$R\f$ are \c mQ and \c mR respectively.
Function throws \ref cvmexception in case if inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal ar[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
treal ai[] = {1., -1., 2., -2., 3., -3., 4., -4., 5.};
const cvm::scmatrix m(ar, ai, 3);
cvm::scmatrix q(3), r(3);
m.qr(q,r);
std::cout << (eye_complex(3) - ~q * q).norm()
          << " " << (m - q * r).norm() << std::endl;
\endcode
prints
\code
+3.7957075e-16 +1.9641850e-15
\endcode
@param[out] mQ \ref scmatrix \f$Q\f$.
@param[out] mR \ref scmatrix \f$R\f$.
*/
    void qr(basic_scmatrix<TR,TC>& mQ, basic_scmatrix<TR,TC>& mR) const {
        this->_qr_ss(mQ, mR);
    }

/**
@brief LQ factorization

Computes LQ factorization as
\f[
A=LQ
\f]
where \f$A\f$ is calling square complex matrix, lower triangular matrix \f$L\f$
and orthogonal matrix \f$Q\f$ are \c mL and \c mQ respectively.
Function throws \ref cvmexception in case if inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal ar[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
treal ai[] = {1., -1., 2., -2., 3., -3., 4., -4., 5.};
const cvm::scmatrix m(ar, ai, 3);
cvm::scmatrix l(3), q(3);
m.lq(l,q);
std::cout << (eye_complex(3) - ~q * q).norm()
          << " " << (m - l * q).norm() << std::endl;
\endcode
prints
\code
+3.5331153e-016 +3.0526086e-015
\endcode
@param[out] mL \ref scmatrix \f$L\f$.
@param[out] mQ \ref scmatrix \f$Q\f$.
*/
    void lq(basic_scmatrix<TR,TC>& mL, basic_scmatrix<TR,TC>& mQ) const {
        this->_lq_ss(mL, mQ);
    }

/**
@brief QL factorization

Computes QL factorization as
\f[
A=QL
\f]
where \f$A\f$ is calling square complex matrix, orthogonal matrix \f$Q\f$
and lower triangular matrix \f$L\f$ are \c mQ and \c mL respectively.
Function throws \ref cvmexception in case if inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal ar[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
treal ai[] = {1., -1., 2., -2., 3., -3., 4., -4., 5.};
const cvm::scmatrix m(ar, ai, 3);
cvm::scmatrix q(3), l(3);
m.ql(q,l);
std::cout << (eye_complex(3) - ~q * q).norm()
          << " " << (m - q * l).norm() << std::endl;
\endcode
prints
\code
+8.8904536e-016 +4.5789129e-015
\endcode
@param[out] mQ \ref scmatrix \f$Q\f$.
@param[out] mL \ref scmatrix \f$L\f$.
*/
    void ql(basic_scmatrix<TR,TC>& mQ, basic_scmatrix<TR,TC>& mL) const {
        this->_ql_ss(mQ, mL);
    }

/**
@brief RQ factorization

Computes RQ factorization as
\f[
A=RQ
\f]
where \f$A\f$ is calling square complex matrix, upper triangular matrix \f$R\f$
and orthogonal matrix \f$Q\f$ are \c mR and \c mQ respectively.
Function throws \ref cvmexception in case if inappropriate sizes of the operands passed.
\par Example:
\code
using namespace cvm;
treal ar[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.};
treal ai[] = {1., -1., 2., -2., 3., -3., 4., -4., 5.};
const cvm::scmatrix m(ar, ai, 3);
cvm::scmatrix r(3), q(3);
m.rq(r,q);
std::cout << (eye_complex(3) - ~q * q).norm()
          << " " << (m - r * q).norm() << std::endl;
\endcode
prints
\code
+3.3357248e-016 +3.4488467e-015
\endcode
@param[out] mR \ref scmatrix \f$R\f$.
@param[out] mQ \ref scmatrix \f$Q\f$.
*/
    void rq(basic_scmatrix<TR,TC>& mR, basic_scmatrix<TR,TC>& mQ) const {
        this->_rq_ss(mR, mQ);
    }

/**
@brief Identity matrix

Sets calling square complex matrix to be equal to identity matrix and returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
scmatrix m(3);
m.randomize_real(0.,3.);
m.randomize_imag(-1.,2.);
std::cout << m << std::endl;
std::cout << m.identity();
\endcode
prints
\code
(1.31162,-0.52501) (2.8612,-0.531144) (1.31849,0.547838)
(1.19929,1.48253) (0.535417,0.41316) (0.459883,1.7019)
(0.415937,-0.491134) (2.0969,-0.218024) (0.545305,1.17866)

(1,0) (0,0) (0,0)
(0,0) (1,0) (0,0)
(0,0) (0,0) (1,0)
\endcode
@return Reference to changed calling matrix.
*/
    basic_scmatrix& identity() {
        this->_vanish();
        this->_plus_plus();
        return *this;
    }

/**
@brief Set matrix to zero

Sets every element of a calling square complex matrix to be equal to zero
and returns a reference to the matrix changed. This function is faster
than, for example, set(TR) with zero parameter passed.
\par Example:
\code
using namespace cvm;
scmatrix m(3);
m.randomize_real(0.,3.);
m.randomize_imag(-1.,2.);
std::cout << m << std::endl;
std::cout << m.vanish();
\endcode
prints
\code
(1.34834,-0.758385) (0.837825,-0.225532) (0.367687,0.791833)
(2.23698,-0.183142) (2.6878,0.741111) (0.495865,0.698904)
(0.584124,0.00491348) (1.31574,0.687643) (0.482131,1.66482)

(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
@return Reference to changed calling matrix.
*/
    basic_scmatrix& vanish() {
        this->_vanish();
        return *this;
    }

    basic_scmatrix& randomize_real(TR dFrom, TR dTo) {
        this->_randomize_real(dFrom, dTo);
        return *this;
    }

    basic_scmatrix& randomize_imag(TR dFrom, TR dTo) {
        this->_randomize_imag(dFrom, dTo);
        return *this;
    }

//! @cond INTERNAL
    virtual void _eig(CVector& vEig, basic_scmatrix<TR,TC>* mEigVect,
                      bool bRightVect) const {
        __eig<CVector, basic_scmatrix, basic_scmatrix>(vEig, *this, mEigVect, bRightVect);
    }

    virtual void _solve(const CVector& vB, CVector& vX,
                        TR& dErr, const TC* pLU,
                        const tint* pPivots, int transp_mode) const {
        vX = vB;
        CVector vB1;
        CVector vX1;
        if (vB.incr() > 1) vB1 << vB;  // to make sure incr = 1
        if (vX.incr() > 1) vX1 << vX;
        __solve<TR,TC, basic_scmatrix>(*this, 1, vB.incr() > 1 ? vB1 : vB, vB.size(), vX.incr() > 1 ? vX1 : vX, vX.size(),
                                        dErr, pLU, pPivots, transp_mode);
        if (vX.incr() > 1) vX = vX1;
    }

    virtual void _solve(const BaseCMatrix& mB, BaseCMatrix& mX,
                        TR& dErr, const TC* pLU,
                        const tint* pPivots, int transp_mode) const {
        mX = mB;
        __solve<TR,TC, basic_scmatrix>(*this, mB.nsize(), mB, mB.ld(), mX, mX.ld(), dErr, pLU, pPivots, transp_mode);
    }

    [[nodiscard]] const TC* _pv() const override {
        return this->get();
    }

    TC* _pv() override {
        return this->get();
    }

protected:
    // protected constructors for inherited stuff
    basic_scmatrix(tint nDim, tint nLD, bool bZeroMemory)
      : BaseCMatrix(nDim, nDim, nLD, bZeroMemory)
    {}

    basic_scmatrix(tint size, tint incr, tint msize, tint nsize, tint ld)
      : BaseCMatrix(size, incr, msize, nsize, ld)
    {}

    // non-const version shares memory
    basic_scmatrix(TC* pd, tint nDim, tint nLD, tint nSize)
      : BaseCMatrix(pd, nDim, nDim, nLD, nSize)
    {}

    // const version makes a copy
    basic_scmatrix(const TC* pd, tint nDim, tint nLD, tint nSize)
      : BaseCMatrix(pd, nDim, nDim, nLD, nSize)
    {}

    [[nodiscard]] tint _size() const override {
        return this->size();
    }

    [[nodiscard]] tint _msize() const override {
        return this->msize();
    }

    [[nodiscard]] tint _nsize() const override {
        return this->nsize();
    }

    [[nodiscard]] tint _ld() const override {
        return this->ld();
    }

    // returns diagonal which IS l-value (shares memory)
    // 0 - main, negative - low, positive - up
    CVector _diag(tint nDiag) override {
        const tint nD = std::abs(nDiag);
        _check_ge(CVM_INDEX_GE, nD, this->msize());
        return CVector(this->get() + (nDiag > 0 ? nDiag * this->ld() : nD), this->msize() - nD, this->ld() + 1);
    }

    // returns diagonal which IS NOT l-value (creates a copy)
    // 0 - main, negative - low, positive - up
    [[nodiscard]] CVector _diag(tint nDiag) const override {
        const tint nD = std::abs(nDiag);
        _check_ge(CVM_INDEX_GE, nD, this->msize());
        return CVector(this->get() + (nDiag > 0 ? nDiag * this->ld() : nD), this->msize() - nD, this->ld() + 1);
    }

    // returns main diagonal of low_up factorization
    virtual CVector _low_up_diag(basic_array<tint,tint>& naPivots) const {
        // let temp matrix be const to get a copy of its main diagonal
        const basic_scmatrix lu = this->low_up(naPivots);
        return lu.diag(0);
    }

    virtual void _transp() {
        this->_sq_transp();
    }

    // 6.1: it's reused in scb, overridden in sch
    virtual void _conj() {
        this->_transp();
        __conj<TC>(this->get(), this->size(), this->incr());
    }

    virtual void _plus_plus() {
        this->_sq_plus_plus();
    }

    virtual void _minus_minus() {
        this->_sq_minus_minus();
    }

    [[nodiscard]] virtual TC _det() const {
        TC cDet(0.);
        switch (this->msize()) {
        case 0:
            break;
        case 1:
            cDet = this->_ij_val(0, 0);
            break;
        case 2:
            cDet = this->_ij_val(0, 0) * this->_ij_val(1, 1) -
               this->_ij_val(1, 0) * this->_ij_val(0, 1);
            break;
        default:
            try {
                const TC one(1., 0.);
                basic_array<tint,tint> naPivots(this->msize());
                CVector vUpDiag = this->_low_up_diag(naPivots);

                cDet = one;
                for (tint i = 0; i <= this->msize() - 1; ++i) {
                    cDet *= vUpDiag[i];
                    if (i + 1 != naPivots[i]) {
                        cDet = -cDet;
                    }
                }
            }
            catch (const cvmexception& e) {
                if (e.cause() != CVM_SINGULARMATRIX) throw e;
            }
            break;
        }
        return cDet;
    }

    virtual void _low_up(tint* nPivots) {
        __low_up<basic_scmatrix>(*this, nPivots);
    }

    // QR - "economy" mode
    void _qr_ss(basic_scmatrix<TR,TC>& mQ, basic_scmatrix<TR,TC>& mR) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mR.msize());
        __qre<basic_cmatrix<TR,TC>, basic_scmatrix<TR,TC>> (*this, mQ, mR);
    }

    // RQ - "economy" mode
    void _rq_ss(basic_scmatrix<TR,TC>& mR, basic_scmatrix<TR,TC>& mQ) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mR.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        __rqe<basic_cmatrix<TR,TC>, basic_scmatrix<TR,TC>> (*this, mR, mQ);
    }

    // LQ - "economy" mode
    void _lq_ss(basic_scmatrix<TR,TC>& mL, basic_scmatrix<TR,TC>& mQ) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mL.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        __lqe<basic_cmatrix<TR,TC>, basic_scmatrix<TR,TC>> (*this, mL, mQ);
    }

    // QL - "economy" mode
    void _ql_ss(basic_scmatrix<TR,TC>& mQ, basic_scmatrix<TR,TC>& mL) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mQ.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mL.msize());
        __qle<basic_cmatrix<TR,TC>, basic_scmatrix<TR,TC>> (*this, mQ, mL);
    }

    virtual void _check_cholesky() { }
    virtual void _check_bunch_kaufman() { }

private:
    CVector _solve_helper(const CVector& vB, TR& dErr, int transp_mode) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vB.size());
        CVector vX(this->msize());
        this->_solve(vB, vX, dErr, nullptr, nullptr, transp_mode);
        return vX;
    }

    BaseCMatrix _solve_helper(const BaseCMatrix& mB,
                              TR& dErr, int transp_mode) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mB.msize());
        BaseCMatrix mX(mB.msize(), mB.nsize());
        this->_solve(mB, mX, dErr, nullptr, nullptr, transp_mode);
        return mX;
    }
//! @endcond
};


/**
@brief Generalized band matrix class (not end-user)

\c TR type stands for \ref treal, \c TC type stands for \ref tcomplex. Please use inherited band square matrix classes.
This one provides some member functions which are common for all band square matrices. Way of elements storage:
\code
L=1, U=2          L=2, U=3        L=0, U=0      L=1, U=0

-                 -               d             d
--                --               d            *d
d**               ---               d            *d
*d**              d***               d            *d
 *d**             *d***               d            *d
  *d**            **d***               d            *d
   *d**            **d**                d            _
    *d*             **d*
     *d              **d
      -               --
                       -
\endcode
@see Matrix
*/
template<typename TR, typename TC>
class BandMatrix
{
protected:
    tint mkl;  //!< Number of sub-diagonals
    tint mku;  //!< Number of super-diagonals

    //! internal protected constructor
    BandMatrix()
      : mkl(0),
        mku(0)
    {}

    //! internal protected constructor
    BandMatrix(tint nKL, tint nKU)
      : mkl(nKL),
        mku(nKU)
    {}

    //! Destructor
    virtual ~BandMatrix() = default;

//! @cond INTERNAL
    [[nodiscard]] virtual tint _size() const = 0;
    [[nodiscard]] virtual tint _msize() const = 0;
    [[nodiscard]] virtual tint _nsize() const = 0;
    [[nodiscard]] virtual tint _ld() const = 0;
    virtual void _set_p(TC* pf) = 0;
    virtual void _set(TC* pf, tint nSize, tint nM, tint nN, tint nIncr, tint nLD) = 0;
    [[nodiscard]] virtual bool _is_empty_b() const = 0;
    virtual const TC* _pb() const = 0;
    virtual TC* _pb() = 0;

#ifdef CVM_USE_POOL_MANAGER
    void _bresize(tint nNewM)
#else
    void _bresize(std::shared_ptr<TC>& mp, tint nNewM)
#endif
    {
        const tint mm = this->_msize();
        const tint nSize = this->_size();
        const bool is_empty = this->_is_empty_b();
        if (nNewM != mm || is_empty) {
            _check_lt(CVM_WRONGSIZE_LT, nNewM, tint());
            const tint nNewSize = nNewM * (1 + this->lsize() + this->usize());
            TC* pd = cvmMalloc<TC>(nNewSize);
            if (nNewSize > nSize) cvmZeroMemory<TC>(pd, nNewSize);
            const tint nMinSize = _cvm_min<tint>(nSize, nNewSize);
            if (nMinSize > 0 && !is_empty) {
                __copy<TC>(nMinSize, this->_pb(), 1, pd, 1);
            }
            CVM_ASSERT(pd, nNewSize * sizeof(TC))
#ifdef CVM_USE_POOL_MANAGER
            TC* pB = this->_pb();
            cvmFree<TC>(pB);
            this->_set(pd, nNewSize, nNewM, nNewM, 1, nNewSize > 0 ? 1 + this->lsize() + this->usize() : 0);
#else
            mp.reset(pd, ArrayDeleter<TC>());
            this->_set(nullptr, nNewSize, nNewM, nNewM, 1, nNewSize > 0 ? 1 + this->lsize() + this->usize() : 0);
#endif
        }
    }

    void _check_dimensions() const {
        _check_lt(CVM_WRONGSIZE_LT, this->lsize(), tint());
        _check_lt(CVM_WRONGSIZE_LT, this->usize(), tint());
    }

    void _check_dimensions(const BandMatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->_msize(), m._msize());
        _check_ne(CVM_SIZESMISMATCH, this->lsize(), m.lsize());
        _check_ne(CVM_SIZESMISMATCH, this->usize(), m.usize());
    }

    [[nodiscard]] bool _bcontinuous() const {
        return this->_msize() == 0 || this->_ld() == 1 + this->lsize() + this->usize();
    }

    // m is a band matrix here
    void _mbassign(const Matrix<TR,TC>& m) {
        TC* pd = _pb();
        if (pd != m.get()) {
            __copy<TC>(this->_size(), m, m.incr(), pd, 1);
        }
    }

    // fills the content, doesn't touch head and tail
    void _b_for_each(TC d, bool bRandom, bool bReal, TR dFrom, TR dTo) {
        tint i, jc, ju, jl;
        const tint nCol = 1 + this->lsize() + this->usize();
        TC* pB = _pb();
        const tint mn = this->_nsize();
        for (tint j = 0; j < mn; ++j) {
            jc = j * nCol;
            ju = this->usize() - j;
            jl = ju + mn;
            for (i = 0; i < nCol; ++i) {
                if (i >= ju && i < jl) {
                    CVM_ASSERT(pB, (jc + i + 1) * sizeof(TC))
                    if (bRandom) {
                        TR* pd = bReal ? __get_real_p<TR>(pB + (jc + i)) : __get_imag_p<TR>(pB + (jc + i));
                        *pd = Randomizer<TR>::get(dFrom, dTo);
                    } else {
                        pB[jc + i] = d;
                    }
                }
            }
        }
    }

    // fills the content, doesn't touch head and tail
    void _bset(TC d) {
        const TR zero = TR(0.);
        this->_b_for_each(d, false, false, zero, zero);
    }

    // fills the content, doesn't touch head and tail
    void _b_randomize(bool bReal, TR dFrom, TR dTo) {
        const TC zero(0.);
        this->_b_for_each(zero, true, bReal, dFrom, dTo);
    }

    // 1-norm
    TR _bnorm1() const {
        tint i, j;
        tint nLen   = 0;
        tint nShift = 0;
        TR  rNorm  = TR(0.);
        TR  rSum;
        const tint mn = this->_nsize();
        basic_array<TR,TC> rv(this->_msize());

        for (j = 0; j < mn; ++j) {
            rSum = TR(0.);
            this->_get_col(j, rv, 1, &nLen, &nShift);

            nLen += nShift;
            for (i = nShift + 1; i <= nLen; ++i) {
                rSum += std::abs(rv[i - 1]);
            }

            if (rSum > rNorm) {
                rNorm = rSum;
            }
        }
        return rNorm;
    }

    // infinity-norm
    TR _bnorminf() const {
        tint i, j;
        tint nLen = 0;
        tint nShift = 0;
        TR  rNorm = TR(0.);
        TR  rSum;
        const tint mm = this->_msize();
        basic_array<TR,TC> rv(this->_nsize());

        for (i = 0; i < mm; ++i) {
            rSum = TR(0.);
            this->_get_row(i, rv, 1, &nLen, &nShift);

            nLen += nShift;
            for (j = nShift + 1; j <= nLen; ++j) {
                rSum += std::abs(rv[j - 1]);
            }

            if (rSum > rNorm) {
                rNorm = rSum;
            }
        }
        return rNorm;
    }

    void _bvanish() {
        this->_bset(TC(0.));
    }

    type_proxy<TC,TR> _b_ij_proxy_val(tint i, tint j) {
        const TC zero = TC(0.);
        TC* pd = _pb();
        const tint nA = j - this->usize();
        CVM_ASSERT(pd, (i + j * (1 + this->lsize() + this->usize()) - nA + 1) * sizeof(TC))
        return(nA < 0 || i >= nA) && i <= this->lsize() + j ?
              type_proxy<TC,TR>(pd[i + j * (1 + this->lsize() + this->usize()) - nA], false) :
              type_proxy<TC,TR>(zero);
    }

    // zero based
    TC _b_ij_val(tint i, tint j) const {
        const TC zero = TC(0.);
        const TC* pd = _pb();
        const tint nA = j - this->usize();
        CVM_ASSERT(pd, (i + j * (1 + this->lsize() + this->usize()) - nA + 1) * sizeof(TC))
        return (nA < 0 || i >= nA) &&
            i <= this->lsize() + j ? pd[i + j * (1 + this->lsize() + this->usize()) - nA] : zero;
    }

    void _get_col(tint i, TC* pCol, tint nIncr, tint* pnLen = nullptr,
                  tint* pnShift = nullptr) const {
        const TC* pd = _pb();
        const tint mm = this->_msize();
        const tint mn = this->_nsize();
        const tint nCol = 1 + this->lsize() + this->usize();
        tint nS         = nCol;
        tint nShiftSrc  = 0;
        tint nShiftDest = 0;

        if (i > this->usize()) {
            nShiftDest = i - this->usize();
        } else {
            nShiftSrc = this->usize() - i;
            nS -= nShiftSrc;
        }

        if (mm - i <= this->lsize()) {
            nS -= this->lsize() + 1 - (mn - i);
        }

        __copy<TC>(nS,
                   pd + i * nCol + nShiftSrc,
                   1,
                   pCol + nShiftDest,
                   nIncr);

        if (pnLen) *pnLen = nS;
        if (pnShift) *pnShift = nShiftDest;
    }

    void _get_row(tint i, TC* pCol, tint nIncr,
                  tint* pnLen = nullptr, tint* pnShift = nullptr) const {
        const TC* pd = _pb();
        const tint mm = this->_msize();
        const tint mn = this->_nsize();
        const tint nCol = this->lsize() + this->usize();
        tint nS         = mn;
        tint nShiftSrc  = i + this->usize();
        tint nShiftDest = 0;

        if (i > this->lsize()) {
            nShiftDest = i - this->lsize();
            nShiftSrc += nShiftDest * nCol;
            nS -= nShiftDest;
        }
        if (mn - i > this->usize()) {
            nS -= (mm - i) - this->usize() - 1;
        }

        __copy<TC>(nS,
                   pd + nShiftSrc,
                   nCol,
                   pCol + nShiftDest,
                   nIncr);

        if (pnLen) *pnLen = nS;
        if (pnShift) *pnShift = nShiftDest;
    }

// matrix replacement, no assignment
#ifdef CVM_USE_POOL_MANAGER
    void _btransp()
#else
    void _btransp(std::shared_ptr<TC>& mp)
#endif
    {
        TC* mpd = _pb();
        const tint mn = this->_nsize();
        if (this->lsize() > 0 || this->usize() > 0) {
            const tint nLU  = this->lsize() + this->usize();
            const tint nCol = 1 + nLU;
            const tint nEls = nCol * mn;
            tint nS, nShiftSrc;
            TC* pL;
            TC* pR;
            TC* pd = cvmMalloc<TC>(nEls);
            cvmZeroMemory(pd, nEls);

            for (tint i = 0; i < mn; ++i) {
                nS = nCol;
                nShiftSrc = 0;

                if (i < this->usize()) {
                    nShiftSrc = this->usize() - i;
                    nS -= nShiftSrc;
                }
                if (mn - i <= this->lsize()) {
                    nS -= this->lsize() + 1 - (mn - i);
                }

                pL = mpd + i * nCol + nShiftSrc;
                pR = pd + (i > this->usize() ? (i - this->usize() + 1) * nCol - 1 : this->lsize() + i);

                __copy<TC>(nS, pL, 1, pR, nLU);
            }
            std::swap(mkl, mku);
#ifdef CVM_USE_POOL_MANAGER
            cvmFree<TC>(mpd);
            this->_set_p(pd);
#else
            this->_set_p(nullptr);
            mp.reset(pd, ArrayDeleter<TC>());
#endif
        }
    }

    void _b_plus_plus() {
        TC* pd = _pb();
        const TC one(1.);
        const tint mn = this->_nsize();
        const tint nNext = 1 + this->lsize() + this->usize();
        const tint nSize = nNext * mn;
        CVM_ASSERT(pd, nSize * sizeof(TC))
        for (tint i = this->usize(); i < nSize; i += nNext) {
            pd[i] += one;
        }
    }

    void _b_minus_minus() {
        TC* pd = _pb();
        const TC one(1.);
        const tint mn = this->_nsize();
        const tint nNext = 1 + this->lsize() + this->usize();
        const tint nSize = nNext * mn;
        CVM_ASSERT(pd, nSize * sizeof(TC))
        for (tint i = this->usize(); i < nSize; i += nNext) {
            pd[i] -= one;
        }
    }

    // matrix replacement, no assignment
#ifdef CVM_USE_POOL_MANAGER
    void _b_replace(const BandMatrix& m)
#else
    void _b_replace(std::shared_ptr<TC>& mp, const BandMatrix& m)
#endif
    {
#ifdef CVM_USE_POOL_MANAGER
        TC* pB = _pb();
        cvmFree<TC>(pB);
#endif
        tint nSize = m._size();
        TC* pd = cvmMalloc<TC>(nSize);
        CVM_ASSERT(pd, (nSize * sizeof(TC)))
        mkl = m.lsize();
        mku = m.usize();
#ifdef CVM_USE_POOL_MANAGER
        this->_set(pd, nSize, m._msize(), m._nsize(), 1, m._ld());
#else
        mp.reset(pd, ArrayDeleter<TC>());
        this->_set(nullptr, nSize, m._msize(), m._nsize(), 1, m._ld());
#endif
    }

#ifdef CVM_USE_POOL_MANAGER
    void _resize_lu(tint nNewKL, tint nNewKU)
#else
    void _resize_lu(std::shared_ptr<TC>& mp, tint nNewKL, tint nNewKU)
#endif
    {
        if (nNewKL != this->lsize() || nNewKU != this->usize()) {
            if (this->lsize() < 0) throw cvmexception(CVM_WRONGSIZE, this->lsize());
            if (this->usize() < 0) throw cvmexception(CVM_WRONGSIZE, this->usize());
            TC* pB = _pb();
            const tint mm = this->_msize();
            const tint mn = this->_nsize();
            const tint nOldLD = 1 + this->lsize() + this->usize();
            const tint nNewLD = 1 + nNewKL + nNewKU;
            const tint nMinKL = _cvm_min<tint>(this->lsize(), nNewKL);
            const tint nMinKU = _cvm_min<tint>(this->usize(), nNewKU);
            const tint nNewSize = mn * (1 + nNewKL + nNewKU);
            TC* pd = cvmMalloc<TC>(nNewSize);
            CVM_ASSERT(pd, nNewSize * sizeof(TC))
            cvmZeroMemory<TC>(pd, nNewSize);
            for (tint i = -nMinKU; i <= nMinKL; ++i) {
                __copy<TC>(mn, pB + (this->usize() + i), nOldLD, pd + (nNewKU + i), nNewLD);
            }
            mkl = nNewKL;
            mku = nNewKU;
#ifdef CVM_USE_POOL_MANAGER
            cvmFree<TC>(pB);
            this->_set(pd, nNewSize, mm, mn, 1, nNewLD);
#else
            mp.reset(pd, ArrayDeleter<TC>());
            this->_set(nullptr, nNewSize, mm, mn, 1, nNewLD);
#endif
        }
    }
//! @endcond

public:
/**
@brief Number of lower sub-diagonals

Returns number of lower sub-diagonals of a calling band matrix.
\par Example:
\code
using namespace cvm;
srbmatrix m(4,2,1);
m.set(1.);
std::cout << m;
std::cout << m.msize() << " " << m.nsize() << " " << m.size();
std::cout << " " << m.lsize() << " " << m.usize() << std::endl;
\endcode
prints
\code
1 1 0 0
1 1 1 0
1 1 1 1
0 1 1 1
4 4 16 2 1
\endcode
@return Result value.
*/
    [[nodiscard]] tint lsize() const {
        return mkl;
    }

/**
@brief Number of upper super-diagonals

Returns number of upper super-diagonals of a calling band matrix.
\par Example:
\code
using namespace cvm;
srbmatrix m(4,2,1);
m.set(1.);
std::cout << m;
std::cout << m.msize() << " " << m.nsize() << " " << m.size();
std::cout << " " << m.lsize() << " " << m.usize() << std::endl;
\endcode
prints
\code
1 1 0 0
1 1 1 0
1 1 1 1
0 1 1 1
4 4 16 2 1
\endcode
@return Result value.
*/
    [[nodiscard]] tint usize() const {
        return mku;
    }

//! @cond INTERNAL
    [[nodiscard]] const tint* _pl() const {
        return&mkl;
    }

    [[nodiscard]] const tint* _pu() const {
        return&mku;
    }
//! @endcond
};


/**
@brief End-user class encapsulating band square matrix of real numbers

\c TR type stands for \ref treal. Please use predefined \ref srbmatrix class in your applications.
Band storage can be described as follows (cited from MKL manual): an \f$m\f$ by \f$n\f$ band matrix
with \f$k_l\f$ sub-diagonals and \f$k_u\f$ super-diagonals is stored
compactly in a two-dimensional array with \f$k_l+k_u+1\f$ rows and \f$n\f$ columns. Columns of the
matrix are stored in the corresponding columns of the array, and diagonals of the matrix are
stored in rows of the array}. This way of storage can be illustrated as follows
(referenced elements are shown as \f$*\f$, not referenced as \f$-\f$, zeros are not stored):
\f[\begin{aligned}
m=n=3, k_l=0, k_u=0&:\ \begin{bmatrix} * & 0 & 0 \\
0 & * & 0 \\
0 & 0 & * \end{bmatrix}\\
m=n=4, k_l=1, k_u=0&:\ \begin{bmatrix} * & 0 & 0 & 0 \\ * & * & 0 & 0 \\
0 & * & * & 0 \\
0 & 0 & * & * \\
&   &   & - \end{bmatrix}\\
m=n=6, k_l=1, k_u=2&:\ \begin{bmatrix} - &   &   &   &   &  \\ - & - &   &   &   &  \\ * & * & * & 0 & 0 & 0 \\ * & * & * & * & 0 & 0 \\
0 & * & * & * & * & 0 \\
0 & 0 & * & * & * & * \\
0 & 0 & 0 & * & * & * \\
0 & 0 & 0 & 0 & * & * \\
&   &   &   &   & - \end{bmatrix}
\end{aligned}\f]
CVM library implements square band matrices only, therefore \f$m=n\f$ is satisfied for them.
@see BandMatrix
*/
template<typename TR>
class basic_srbmatrix : public basic_srmatrix<TR>, public BandMatrix<TR,TR>
{
    using TC = std::complex<TR>;  //!< complex number type
    using RVector = basic_rvector<TR>;  //!< \ref rvector
    using CVector = basic_cvector<TR,TC>;  //!< \ref cvector
    using BaseArray = basic_array<TR,TR>;  //!< Base basic_array class
    using BaseMatrix = Matrix<TR,TR>;  //!< Base Matrix class
    using BaseRMatrix = basic_rmatrix<TR>;  //!< Base \ref rmatrix class
    using BaseSRMatrix = basic_srmatrix<TR>;  //!< Base \ref srmatrix class
    using BaseBandMatrix = BandMatrix<TR,TR>;  //!< Base BandMatrix class

    friend class basic_scbmatrix<TR,TC>;  // basic_scbmatrix constructor

protected:
    mutable BaseSRMatrix mSM;  //!< Temporary storage for square matrix enclosing band one (if needed)

public:
/**
@brief Default constructor

Creates empty square band matrix. No memory gets allocated.
\par Example:
\code
using namespace cvm;
srbmatrix m;
std::cout << m.msize() << " " << m.nsize() << " " << m.size();
std::cout << " " << m.lsize() << " " << m.usize() << std::endl;
m.resize(3);
m.resize_lu(1,0);
m.set(1.);
std::cout << m;
\endcode
prints
\code
0 0 0 0 0
1 0 0
1 1 0
0 1 1
\endcode
*/
    basic_srbmatrix()
      : mSM()
    {}

/**
@brief Diagonal band matrix constructor

Creates \f$n\times n\f$ \ref srbmatrix object where dimension \f$n\f$ is passed in
\c nDim parameter. The matrix created is diagonal, i.e. \f$k_l=k_u=0\f$.
Constructor throws \ref cvmexception in case of non-positive size passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
srbmatrix m(4);
std::cout << m.msize() << " " << m.nsize() << " " << m.size();
std::cout << " " << m.lsize() << " " << m.usize() << std::endl;
m.set(1.);
std::cout << m;
\endcode
prints
\code
4 4 4 0 0
1 0 0 0
0 1 0 0
0 0 1 0
0 0 0 1
\endcode
@param[in] nDim Number of rows and columns.
*/
    explicit basic_srbmatrix(tint nDim)
      : BaseSRMatrix(nDim, 1, true),
        BaseBandMatrix(0, 0)
    {}

/**
@brief Band matrix constructor

Creates \ref srbmatrix object of dimension passed in \c nDim parameter. The matrix created has \c nKL
sub-diagonals and \c nKU super-diagonals. Constructor throws \ref cvmexception
in case of non-positive size or negative number of sub-diagonals or super-diagonals
passed or in case of memory allocation failure.
Example:
\code
using namespace cvm;
srbmatrix m(5,1,1);
m.set(1.);
std::cout << m << std::endl
          << m.msize() << " " << m.nsize() << " " << m.size()
          << " " << m.lsize() << " " << m.usize() << std::endl;
\endcode
prints
\code
1 1 0 0 0
1 1 1 0 0
0 1 1 1 0
0 0 1 1 1
0 0 0 1 1

5 5 15 1 1
\endcode
@param[in] nDim Number of rows and columns.
@param[in] nKL Number of lower sub-diagonals.
@param[in] nKU Number of upper super-diagonals.
*/
    basic_srbmatrix(tint nDim, tint nKL, tint nKU)
      : BaseSRMatrix(nDim, 1 + nKL + nKU, true),
        BaseBandMatrix(nKL, nKU), mSM() {
        this->_check_dimensions();
    }

/**
@brief Constructor

Creates \f$n\times n\f$ \ref srbmatrix object where \f$n\f$ is passed in \c nDim parameter.
The matrix created has \c nKL
sub-diagonals and \c nKU super-diagonals. Constructor throws \ref cvmexception
in case of non-positive size or negative number of sub-diagonals or super-diagonals
passed or in case of memory allocation failure.
Unlike others, this constructor <b>does not allocate memory</b>.
It just shares memory with an array pointed to by \c pd (for matrices \c nIncr=1 is always satisfied).
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
srbmatrix ml(a,4,1,0);
srbmatrix mu(a,4,0,1);
ml(2,1) = 9.;
std::cout << ml << std::endl << mu << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << " "
          << a[3] << " " << a[4] << " " << a[5] << " " << std::endl;
\endcode
prints
\code
1 0 0 0
9 3 0 0
0 4 5 0
0 0 6 7

9 3 0 0
0 4 5 0
0 0 6 7
0 0 0 8

1 9 3 4 5 6
\endcode
@see http://cvmlib.com/faq.htm
@see basic_rmatrix::basic_rmatrix(TR*,tint,tint)
@param[in] pd Pointer to an array to share memory with.
@param[in] nDim Number of rows and columns.
@param[in] nKL Number of lower sub-diagonals.
@param[in] nKU Number of upper super-diagonals.
*/
    basic_srbmatrix(TR* pd, tint nDim, tint nKL, tint nKU)
      : BaseSRMatrix(pd, nDim, 1 + nKL + nKU, nDim * (1 + nKL + nKU)),
        BaseBandMatrix(nKL, nKU), mSM() {
        this->_check_dimensions();
    }

/**
@brief Constructor

Creates \f$n\times n\f$ \ref srbmatrix object where \f$n\f$ is passed in \c nDim parameter.
The matrix created has \c nKL
sub-diagonals and \c nKU super-diagonals. Constructor throws \ref cvmexception
in case of non-positive size or negative number of sub-diagonals or super-diagonals
passed or in case of memory allocation failure.
Then constructor copies \f$(k_l + k_u + 1)*n\f$ elements of an array  \c pd to the
matrix according to band storage.
\par Example:
\code
using namespace cvm;
const double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
srbmatrix ml(a,4,1,0);
srbmatrix mu(a,4,0,1);
ml(2,1) = 9.;
std::cout << ml << std::endl << mu << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << " "
          << a[3] << " " << a[4] << " " << a[5] << " " << std::endl;
\endcode
prints
\code
1 0 0 0
9 3 0 0
0 4 5 0
0 0 6 7

2 3 0 0
0 4 5 0
0 0 6 7
0 0 0 8

1 2 3 4 5 6
\endcode
@see http://cvmlib.com/faq.htm
@see basic_rmatrix::basic_rmatrix(TR*,tint,tint)
@param[in] pd Pointer to an array to share memory with.
@param[in] nDim Number of rows and columns.
@param[in] nKL Number of lower sub-diagonals.
@param[in] nKU Number of upper super-diagonals.
*/
    basic_srbmatrix(const TR* pd, tint nDim, tint nKL, tint nKU)
      : BaseSRMatrix(pd, nDim, 1 + nKL + nKU, nDim * (1 + nKL + nKU)),
        BaseBandMatrix(nKL, nKU), mSM() {
        this->_check_dimensions();
    }

/**
@brief Copy constructor

Creates \ref srbmatrix object as a copy of band matrix \c m.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
srbmatrix m(a,4,1,0);
srbmatrix mc(m);
m(1,1) = 7.77;
std::cout << m << std::endl << mc;
\endcode
prints
\code
7.77 0 0 0
2 3 0 0
0 4 5 0
0 0 6 7

1 0 0 0
2 3 0 0
0 4 5 0
0 0 6 7
\endcode
@param[in] m \ref srbmatrix to copy from.
*/
    basic_srbmatrix(const basic_srbmatrix& m)
      : BaseSRMatrix(m.msize(), 1 + m.lsize() + m.usize(), false),
        BaseBandMatrix(m.lsize(), m.usize()), mSM() {
        this->_massign(m);
    }

/**
@brief Move constructor

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to newly created object.
It's usually executed implicitly in cases like this:
\code
rvector a(b + c);
\endcode
or this
\code
rvector a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to newly created object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_srbmatrix(basic_srbmatrix&& m) noexcept
      : BaseSRMatrix(m.size(), m.incr(), m.msize(), m.nsize(), m.ld()),
        BaseBandMatrix(m.lsize(), m.usize()), mSM() {
        this->_mmove(std::move(m));
    }

/**
@brief Constructor

Creates \ref srbmatrix object as a copy of \e sliced
matrix \c m, i.e. it copies main diagonal, \c nKL sub-diagonals and \c nKU super-diagonals of a matrix \c m.
It's assumed that \f$m\times n\f$ matrix \c m must have equal sizes, i.e. \f$m = n\f$ is satisfied.
Constructor throws \ref cvmexception if this is not true or in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16.};
srmatrix m(a,4);
srbmatrix mb(m,1,2);
std::cout << m << std::endl << mb;
\endcode
prints
\code
1 5 9 13
2 6 10 14
3 7 11 15
4 8 12 16

1 5 9 0
2 6 10 14
0 7 11 15
0 0 12 16
\endcode
@param[in] m \ref rmatrix to copy diagonal and subdiagonals from.
@param[in] nKL Number of lower sub-diagonals.
@param[in] nKU Number of upper super-diagonals.
*/
    basic_srbmatrix(const BaseRMatrix& m, tint nKL, tint nKU)
      : BaseSRMatrix(m.msize(), 1 + nKL + nKU, false), BaseBandMatrix(nKL, nKU), mSM() {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), this->nsize());
        this->_check_dimensions();
        _copy_b_matrix<TR,TR, BaseRMatrix,
            basic_srbmatrix>(const_cast<BaseRMatrix&>(m), *this, true);
    }

/**
@brief Constructor

Creates \ref srbmatrix object of size \c v.size() by \c v.size()
and assigns vector \c v to its main diagonal.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5.};
rvector v(a, 5);
srbmatrix m(v);
std::cout << m;
\endcode
prints
\code
1 0 0 0 0
0 2 0 0 0
0 0 3 0 0
0 0 0 4 0
0 0 0 0 5
\endcode
@param[in] v \ref rvector to copy main diagonal from.
*/
    explicit basic_srbmatrix(const RVector& v)
      : BaseSRMatrix(v.size(), 1, false),
        BaseBandMatrix(0, 0) {
        __copy<TR>(this->msize(), v, v.incr(), this->get(), 1);
    }

/**
@brief Assignment operator

Sets every element of a calling \ref srbmatrix to be equal to
appropriate element of a matrix \c m and returns a reference to
the matrix changed.
Operator throws \ref cvmexception in case of different matrix dimensions.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
    const srbmatrix m1(a,4,1,0);
    srbmatrix m2(4,1,0);

    m2 = m1;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1 0 0 0
2 3 0 0
0 4 5 0
0 0 6 7
\endcode
@param[in] m \ref srbmatrix to assign from.
@return Reference to changed calling matrix.
*/
    basic_srbmatrix& operator = (const basic_srbmatrix& m) {
        this->_check_dimensions(m);
        this->_massign(m);
        return *this;
    }

/**
@brief Move assignment operator

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to a calling object.
It's usually executed implicitly in cases like this:
\code
a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to a calling object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_srbmatrix& operator = (basic_srbmatrix&& m) noexcept {
        this->_check_dimensions(m);
        BaseSRMatrix::operator = (std::move(m));
        return *this;
    }

    // assigns vector
    basic_srbmatrix& assign(const RVector& v) {
        _check_gt(CVM_SIZESMISMATCH_GT, this->size(), v.size());
        this->_assign(v, v.incr());
        return *this;
    }

    // assigns external array (nIncr = 1)
    basic_srbmatrix& assign(const TR* pd) {
        this->_assign(pd, 1);
        return *this;
    }

    // fills the content
    basic_srbmatrix& set(TR d) {
        this->_set(d);
        return *this;
    }

    basic_srbmatrix& resize(tint nNewDim) {
        this->_resize2(nNewDim, nNewDim);
        return *this;
    }

/**
@brief Changes number of sub- and super-diagonals

Changes number of sub- and super-diagonals of a calling band matrix to \c nNewKL and \c nNewKU respectively
and returns a reference to the matrix changed. In case of increasing of the numbers, calling matrix
is filled up with zeroes.
Function throws \ref cvmexception in case of negative number passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
    srbmatrix m(a,4,1,0);
    std::cout << m << std::endl;
    m.resize_lu(0,1);
    m.diag(1).set(9.);
    std::cout << m;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1 0 0 0
2 3 0 0
0 4 5 0
0 0 6 7

1 9 0 0
0 3 9 0
0 0 5 9
0 0 0 7
\endcode
@param[in] nNewKL New number of lower sub-diagonals.
@param[in] nNewKU New number of upper super-diagonals.
@return Reference to changed calling matrix.
*/
    basic_srbmatrix& resize_lu(tint nNewKL, tint nNewKU) {
#ifdef CVM_USE_POOL_MANAGER
        this->_resize_lu(nNewKL, nNewKU);
#else
        this->_resize_lu(this->mp, nNewKL, nNewKU);
#endif
        return *this;
    }

/**
@brief Band matrix comparison

Operator compares calling band matrix with band matrix \c m
and returns \c true if they have same dimensions
and their appropriate elements differ by not more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4.};
srbmatrix m1(a,2,1,0);
srbmatrix m2(2,1,0);
std::cout << m1 << std::endl;
m2(1,1) = 1.;
m2(2,1) = 2.; m2(2,2) = 3.;
std::cout << (m1 == m2) << std::endl;
\endcode
prints
\code
1 0
2 3

1
\endcode
@see operator !=()
@param[in] m \ref srbmatrix to compare to.
@return bool Result of comparison.
*/
    bool operator == (const basic_srbmatrix& m) const {
        return this->msize() == m.msize() && this->nsize() == m.nsize() &&
            this->lsize() == m.lsize() && this->usize() == m.usize() &&
            this->_mequals(m);
    }

/**
@brief Band matrix comparison

Operator compares calling band matrix with band matrix \c m
and returns \c true if they have different dimensions
or at least one of their appropriate elements differs by more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4.};
srbmatrix m1(a,2,1,0);
srbmatrix m2(2,1,0);
std::cout << m1 << std::endl;
m2(1,1) = 1.;
m2(2,1) = 2.; m2(2,2) = 3.;
std::cout << (m1 == m2) << std::endl;
\endcode
prints
\code
1 0
2 3

0
\endcode
@see operator ==()
@param[in] m \ref srbmatrix to compare to.
@return bool Result of comparison.
*/
    bool operator != (const basic_srbmatrix& m) const {
        return !(this->operator == (m));
    }

/**
@brief Matrix replacement

Destroys calling band matrix, creates a new one as a copy of band matrix \c m
and returns a reference to the matrix changed. Operator throws \ref cvmexception
in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    srbmatrix m(3,1,0);
    srmatrix mc(1);
    m(2,1) = 1.;
    m(2,2) = 2.;
    std::cout << m << std::endl << mc << std::endl;
    mc << m;
    std::cout << mc;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
0 0 0
1 2 0
0 0 0

0

0 0 0
1 2 0
0 0 0
\endcode
@see operator =()
@param[in] m \ref srbmatrix to replace by.
@return Reference to changed calling matrix.
*/
    basic_srbmatrix& operator << (const basic_srbmatrix& m) {
        this->_check_ld();  // submatrix replacement is obviously not possible
#ifdef CVM_USE_POOL_MANAGER
        this->_b_replace(m);
#else
        this->_b_replace(this->mp, m);
#endif
        this->_massign(m);
        return *this;
    }

/**
@brief Addition operator

Creates an object of type \ref srbmatrix as a sum of a calling matrix and a matrix \c m.
Operator throws \ref cvmexception
in case of different dimensions of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(1);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
    double b[] = {10., 20., 30., 40., 50., 60., 70., 80.};
    srbmatrix m1(a,4,1,0);
    srbmatrix m2(b,4,1,0);
    std::cout << m1 + m2 << std::endl << m1 + m1;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1.1e+01 0.0e+00 0.0e+00 0.0e+00
2.2e+01 3.3e+01 0.0e+00 0.0e+00
0.0e+00 4.4e+01 5.5e+01 0.0e+00
0.0e+00 0.0e+00 6.6e+01 7.7e+01

2.0e+00 0.0e+00 0.0e+00 0.0e+00
4.0e+00 6.0e+00 0.0e+00 0.0e+00
0.0e+00 8.0e+00 1.0e+01 0.0e+00
0.0e+00 0.0e+00 1.2e+01 1.4e+01
\endcode
@see sum()
@param[in] m \ref srbmatrix to add to a calling one.
@return Sum of matrices.
*/
    basic_srbmatrix operator + (const basic_srbmatrix& m) const {
        this->_check_dimensions(m);
        basic_srbmatrix mSum(*this);
        mSum._mincr(m);
        return mSum;
    }

/**
@brief Subtraction operator

Creates an object of type \ref srbmatrix as a difference of
a calling band matrix and band matrix \c m.
It throws \ref cvmexception in case of different dimensions of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(1);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
    double b[] = {10., 20., 30., 40., 50., 60., 70., 80.};
    srbmatrix m1(a,4,1,0);
    srbmatrix m2(b,4,1,0);
    std::cout << m2 - m1 << std::endl << m1 - m1;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
9.0e+00 0.0e+00 0.0e+00 0.0e+00
1.8e+01 2.7e+01 0.0e+00 0.0e+00
0.0e+00 3.6e+01 4.5e+01 0.0e+00
0.0e+00 0.0e+00 5.4e+01 6.3e+01

0.0e+00 0.0e+00 0.0e+00 0.0e+00
0.0e+00 0.0e+00 0.0e+00 0.0e+00
0.0e+00 0.0e+00 0.0e+00 0.0e+00
0.0e+00 0.0e+00 0.0e+00 0.0e+00
\endcode
@see diff()
@param[in] m \ref srbmatrix to subtract from calling one.
@return Difference of matrices.
*/
    basic_srbmatrix operator - (const basic_srbmatrix& m) const {
        this->_check_dimensions(m);
        basic_srbmatrix mDiff(*this);
        mDiff._mdecr(m);
        return mDiff;
    }

/**
@brief Sum of matrices

Assigns sum of square band matrices \c m1 and \c m2 to a calling matrix
and returns a reference to the matrices changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const srbmatrix m1(a,3,1,0);
    srbmatrix m2(3,1,0);
    srbmatrix m(3,1,0);
    m2.set(1.);
    std::cout << m1 << std::endl << m2 << std::endl;
    std::cout << m.sum(m1, m2) << std::endl;
    std::cout << m.sum(m, m2);
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1 0 0
2 3 0
0 4 5

1 0 0
1 1 0
0 1 1

2 0 0
3 4 0
0 5 6

3 0 0
4 5 0
0 6 7
\endcode
@see operator +()
@param[in] m1 First \ref srbmatrix summand.
@param[in] m2 Second \ref srbmatrix summand.
@return Reference to changed calling matrix.
*/
    basic_srbmatrix& sum(const basic_srbmatrix& m1, const basic_srbmatrix& m2) {
        this->_check_dimensions(m1);
        this->_check_dimensions(m2);
        this->_msum(m1, m2);
        return *this;
    }

/**
@brief Difference of matrices

Assigns difference of square band matrices \c m1 and \c m2 to a calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6.};
    const srbmatrix m1(a,3,1,0);
    srbmatrix m2(3,1,0);
    srbmatrix m(3,1,0);
    m2.set(1.);
    std::cout << m1 << std::endl << m2 << std::endl;
    std::cout << m.diff(m1, m2) << std::endl;
    std::cout << m.diff(m, m2);
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1 0 0
2 3 0
0 4 5

1 0 0
1 1 0
0 1 1

0 0 0
1 2 0
0 3 4

-1 0 0
0 1 0
0 2 3
\endcode
@see operator -()
@param[in] m1 First \ref srbmatrix subtrahend.
@param[in] m2 Second \ref srbmatrix subtrahend.
@return Reference to changed calling matrix.
*/
    basic_srbmatrix& diff(const basic_srbmatrix& m1, const basic_srbmatrix& m2) {
        this->_check_dimensions(m1);
        this->_check_dimensions(m2);
        this->_mdiff(m1, m2);
        return *this;
    }

/**
@brief Increment operator

Adds \ref srbmatrix \c m to a calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    srbmatrix m1(4,0,1);
    srbmatrix m2(4,0,1);
    m1.set(1.);
    m2.set(2.);

    m1 += m2;
    std::cout << m1 << std::endl;

    // well, you can do this too, but temporary object would be created
    m2 += m2;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
3 3 0 0
0 3 3 0
0 0 3 3
0 0 0 3

4 4 0 0
0 4 4 0
0 0 4 4
0 0 0 4
\endcode
@see operator +()
@see sum()
@param[in] m \ref srbmatrix to increment by.
@return Reference to changed calling matrix.
*/
    basic_srbmatrix& operator += (const basic_srbmatrix& m) {
        this->_check_dimensions(m);
        this->_mincr(m);
        return *this;
    }

/**
@brief Decrement operator

Subtracts \ref srbmatrix \c m from calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    srbmatrix m1(4,0,1);
    srbmatrix m2(4,0,1);
    m1.set(1.);
    m2.set(4.);

    m2 -= m1;
    std::cout << m2 << std::endl;

    // well, you can do this too, but temporary object would be created
    m2 -= m2;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
3 3 0 0
0 3 3 0
0 0 3 3
0 0 0 3

0 0 0 0
0 0 0 0
0 0 0 0
0 0 0 0
\endcode
@see operator -()
@see diff()
@param[in] m \ref srbmatrix to decrement by.
@return Reference to changed calling matrix.
*/
    basic_srbmatrix& operator -= (const basic_srbmatrix& m) {
        this->_check_dimensions(m);
        this->_mdecr(m);
        return *this;
    }

/**
@brief Unary minus operator

Creates an object of type \ref srbmatrix as
a calling matrix multiplied by \c -1.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific |
                std::ios::left |
                std::ios::showpos);
std::cout.precision(1);
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
srbmatrix m(a,4,1,0);
std::cout << -m;
\endcode
prints
\code
-1.0e+00 +0.0e+00 +0.0e+00 +0.0e+00
-2.0e+00 -3.0e+00 +0.0e+00 +0.0e+00
+0.0e+00 -4.0e+00 -5.0e+00 +0.0e+00
+0.0e+00 +0.0e+00 -6.0e+00 -7.0e+00
\endcode
@return Result object.
*/
    basic_srbmatrix operator - () const {
        const TR mone(-1.);
        basic_srbmatrix mRes(*this);
        mRes._scalr(mone);
        return mRes;
    }

/**
@brief Plus identity, prefix

Adds identity matrix to a calling square band matrix and 
returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
srbmatrix m(a,4,1,0);
std::cout << m << std::endl; 
std::cout << ++m << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
1 0 0 0 
2 3 0 0 
0 4 5 0 
0 0 6 7 

2 0 0 0 
2 4 0 0 
0 4 6 0 
0 0 6 8 

2 0 0 0 
2 4 0 0 
0 4 6 0 
0 0 6 8 
\endcode
@return Reference to changed calling matrix.
*/
    basic_srbmatrix& operator ++ () {
        this->_plus_plus();
        return *this;
    }

/**
@brief Plus identity, postfix

Adds identity matrix to a calling square band matrix and returns 
a copy of the original matrix. 
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
srbmatrix m(a,4,1,0);
std::cout << m << std::endl; 
std::cout << m++ << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
1 0 0 0 
2 3 0 0 
0 4 5 0 
0 0 6 7 

1 0 0 0 
2 3 0 0 
0 4 5 0 
0 0 6 7 

2 0 0 0 
2 4 0 0 
0 4 6 0 
0 0 6 8 
\endcode
@return Copy of the original calling matrix.
*/
    basic_srbmatrix operator ++ (int) {
        basic_srbmatrix mRes(*this);
        this->_plus_plus();
        return mRes;
    }

/**
@brief Minus identity, prefix

Subtracts identity matrix from calling square band matrix and returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
srbmatrix m(a,4,1,0);
std::cout << m << std::endl; 
std::cout << --m << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
1 0 0 0 
2 3 0 0 
0 4 5 0 
0 0 6 7 

0 0 0 0 
2 2 0 0 
0 4 4 0 
0 0 6 6 

0 0 0 0 
2 2 0 0 
0 4 4 0 
0 0 6 6 
\endcode
@return Reference to changed calling matrix.
*/
    basic_srbmatrix& operator -- () {
        this->_minus_minus();
        return *this;
    }

/**
@brief Minus identity, postfix

Subtracts identity matrix from calling square band matrix and 
returns a copy of the original matrix. 
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
srbmatrix m(a,4,1,0);
std::cout << m << std::endl; 
std::cout << m-- << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
1 0 0 0 
2 3 0 0 
0 4 5 0 
0 0 6 7 

1 0 0 0 
2 3 0 0 
0 4 5 0 
0 0 6 7 

0 0 0 0 
2 2 0 0 
0 4 4 0 
0 0 6 6 
\endcode
@return Copy of the original calling matrix.
*/
    basic_srbmatrix operator -- (int) {
        basic_srbmatrix mRes(*this);
        this->_minus_minus();
        return mRes;
    }

    // TODO dox
    basic_srbmatrix operator * (TR dMult) const {
        basic_srbmatrix mRes(*this);
        mRes._scalr(dMult);
        return mRes;
    }

    basic_srbmatrix operator / (TR dDiv) const {
        basic_srbmatrix mRes(*this);
        mRes._div(dDiv);
        return mRes;
    }

    basic_srbmatrix& operator *= (TR dMult) {
        this->_scalr(dMult);
        return *this;
    }

    basic_srbmatrix& operator /= (TR dDiv) {
        this->_div(dDiv);
        return *this;
    }

    basic_srbmatrix& normalize() {
        this->_normalize();
        return *this;
    }

    // transposed Matrix
    basic_srbmatrix operator ~ () const {
        basic_srbmatrix mRes(*this);
        return mRes.transpose();
    }

/**
@brief Matrix transposition

Sets calling square band matrix to be equal to square band matrix \c m transposed.
Function throws \ref cvmexception in case of not appropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
srbmatrix m(a,4,1,0);
srbmatrix mt(4,0,1);
std::cout << ~m << std::endl ;
mt.transpose(m);
std::cout << mt << std::endl;
mt.transpose();
std::cout << mt;
\endcode
prints
\code
1 2 0 0
0 3 4 0
0 0 5 6
0 0 0 7

1 2 0 0
0 3 4 0
0 0 5 6
0 0 0 7

1 0 0 0
2 3 0 0
0 4 5 0
0 0 6 7
\endcode
@param[in] m \ref srbmatrix to transpose.
@return Reference to changed calling matrix.
*/
    basic_srbmatrix& transpose(const basic_srbmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->lsize(), m.usize());
        _check_ne(CVM_SIZESMISMATCH, this->usize(), m.lsize());
        *this << ~m;
        return *this;
    }

    // TODO dox
    basic_srbmatrix& transpose() {
        this->_transp();
        return *this;
    }

    RVector operator * (const RVector& v) const {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), v.size());
        RVector vRes(this->msize());
        this->_multiply(vRes, v, false);
        return vRes;
    }

    // special exclusion since matrix product is not commutative
    BaseRMatrix operator * (const BaseRMatrix& m) const {
        _bake_SM();
        return mSM * m;
    }

/**
@brief Matrix-matrix product

Creates an object of type \ref srmatrix as a product of a calling square band matrix and square matrix \c m.
Operator throws \ref cvmexception if number of columns of a calling matrix
differs from number of rows of the matrix \c m.
Use \ref mult() to avoid new object creation.
\par Example:
\code
using namespace cvm;
try {
    srbmatrix mb(4,1,0);
    srmatrix ms(4);
    mb.set(1.);
    ms.set(1.);
    std::cout << mb * ms;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
1 1 1 1
2 2 2 2
2 2 2 2
2 2 2 2
\endcode
@param[in] m \ref srmatrix to compute product with.
@return Result object.
*/
    BaseSRMatrix operator * (const BaseSRMatrix& m) const {
        _bake_SM();
        return mSM * m;
    }

/**
@brief Matrix-matrix product

Creates an object of type \ref srbmatrix as a product of a calling square band matrix and square band matrix \c m.
Operator throws \ref cvmexception if number of columns of a calling matrix
differs from number of rows of the matrix \c m.
Use \ref mult() to avoid new object creation.
\par Example:
\code
using namespace cvm;
try {
    srbmatrix m1(7,1,0);
    srbmatrix m2(7,1,1);
    m1.set(1.);
    m2.set(1.);
    std::cout << m1 * m2;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1 1 0 0 0 0 0
2 2 1 0 0 0 0
1 2 2 1 0 0 0
0 1 2 2 1 0 0
0 0 1 2 2 1 0
0 0 0 1 2 2 1
0 0 0 0 1 2 2
\endcode
@param[in] m \ref srbmatrix to compute product with.
@return Result object.
*/
    basic_srbmatrix operator * (const basic_srbmatrix& m) const {
        _bake_SM();
        m._bake_SM();
        return basic_srbmatrix(mSM * m.mSM,
                               _cvm_min<tint>(this->msize() - 1, this->lsize() + m.lsize()),
                               _cvm_min<tint>(this->msize() - 1, this->usize() + m.usize()));
    }

    // TODO dox
    // 6.1: reversed vector operator % returns solution of A*X=B equation
    // overridden to mask out operator / (TR)
    RVector operator / (const RVector& v) const {
        return v % (*this);
    }

/**
@brief Low-up (LU) factorization

Compute LU factorization of square band matrix \f$A\f$ as
\f[
A=PLU
\f]
where \f$P\f$ is permutation matrix, \f$L\f$ is lower
triangular matrix with unit diagonal
elements and \f$U\f$ is upper triangular matrix.
Function stores result as the matrix \f$L\f$ without
main diagonal combined with \f$U\f$. Function
returns pivot indices as  array of integers
(it should support at least \ref msize() elements)
pointed to by \c nPivots so \f$i\f$-th row
was interchanged with \c nPivots[\f$i\f$]-th row.
This version sets calling matrix to be equal to matrix
\c m's LU factorization.
This version also changes number of
super-diagonals to be equal to \f$k_l+k_u\f$ in order to keep the result of factorization.
Function throws \ref cvmexception in case of inappropriate
sizes of the operands or when the matrix to be factorized is close to
singular. It is recommended to use \ref iarray for pivot values.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(4);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
    srbmatrix ma(a,4,1,0);
    srbmatrix mLU(4,1,0);
    rmatrix  mb1(4,2); rvector vb1(4);
    rmatrix  mb2(4,2); rvector vb2(4);
    rmatrix  mx1(4,2); rvector vx1(4);
    rmatrix  mx2(4,2); rvector vx2(4);
    iarray   nPivots(4);
    double   dErr = 0.;
    mb1.randomize(-1.,3.); vb1.randomize(-2.,4.);
    mb2.randomize(-2.,5.); vb2.randomize(-3.,1.);

    mLU.low_up(ma, nPivots);
    mx1 = ma.solve_lu(mLU, nPivots, mb1, dErr);
    std::cout << mx1 << dErr << std::endl << std::endl;
    mx2 = ma.solve_lu(mLU, nPivots, mb2);
    std::cout << mx2 << std::endl;;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;

    vx1 = ma.solve_lu(mLU, nPivots, vb1, dErr);
    std::cout << vx1 << dErr << std::endl;
    vx2 = ma.solve_lu(mLU, nPivots, vb2);
    std::cout << vx2 << std::endl;;
    std::cout << ma * vx1 - vb1 << std::endl << ma * vx2 - vb2;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
7.6327e-02 -4.7386e-01
-2.9523e-01 9.7577e-01
1.7288e-01 -3.5093e-01
1.0595e-01 4.7363e-01
1.1832e-15

3.1963e+00 4.8622e+00
-4.9904e-01 -2.6575e+00
8.2183e-01 2.3294e+00
-6.1693e-01 -1.8015e+00

0.0000e+00 0.0000e+00
0.0000e+00 -2.2204e-16
0.0000e+00 -4.4409e-16
0.0000e+00 0.0000e+00

0.0000e+00 0.0000e+00
8.8818e-16 0.0000e+00
0.0000e+00 -4.4409e-16
-4.4409e-16 4.4409e-16
7.8933e-01 7.0543e-01 -1.6338e-02 -2.6206e-01
1.4832e-15
-1.5505e+00 5.8987e-01 -8.4977e-01 7.3059e-01

0.0000e+00 0.0000e+00 0.0000e+00 0.0000e+00

-2.2204e-16 0.0000e+00 0.0000e+00 4.4409e-16
\endcode
@param[in] m \ref srbmatrix to compute LU factorization for.
@param[out] nPivots %Array of pivot indices.
@return Reference to changed calling matrix.
*/
    basic_srbmatrix& low_up(const basic_srbmatrix& m, tint* nPivots) {
        (*this) = m;
        this->_low_up(nPivots);
        return *this;
    }

    // TODO dox
    basic_srbmatrix low_up(tint* nPivots) const {
        basic_srbmatrix mRes(*this);
        mRes._low_up(nPivots);
        return mRes;
    }

    basic_srbmatrix& identity() {
        this->_vanish();
        this->_plus_plus();
        return *this;
    }

    basic_srbmatrix& vanish() {
        this->_vanish();
        return *this;
    }

    basic_srbmatrix& randomize(TR dFrom, TR dTo) {
        this->_b_randomize(true, dFrom, dTo);
        return *this;
    }

    // Euclid norm - band matrices require special care because of tails
    TR norm() const override {
        TR dNorm = TR(0.), d;
        tint i;

        for (i = 0; i <= this->lsize(); ++i) {
            // non-const version shares mamory, it's faster
            d = const_cast<basic_srbmatrix*>(this)->diag(-i).norm();
            dNorm += d * d;
        }
        for (i = 1; i <= this->usize(); ++i) {
            // non-const version shares mamory, it's faster
            d = const_cast<basic_srbmatrix*>(this)->diag(i).norm();
            dNorm += d * d;
        }

        return std::sqrt(dNorm);
    }

    TR norm1() const override {
        return this->_bnorm1();
    }

    TR norminf() const override {
        return this->_bnorminf();
    }

    // TODO dox
    // ATTENTION!!! This is not a good idea to use the following function. It's provided for
    // overriding of basic_rmatrix<TR>::mult only
    // this = m1 * m2
    basic_srbmatrix& mult(const BaseRMatrix& m1, const BaseRMatrix& m2) {
        this->_mult(m1, m2);
        return *this;
    }

//! @cond INTERNAL
    // redefinition of basic_array's function
    TR* _pd() override {
#ifdef CVM_DEBUG
        // it's abnormal to call this function, this is pointer to copy, not to an object.
        // only const version is allowed
        assert(false);
#endif
        _bake_SM();
        return mSM._pd();
    }

    // redefinition of basic_array's function
    const TR* _pd() const override {
        _bake_SM();
        return mSM._pd();
    }

    // singular values in decreasing order
    void _svd(RVector& vRes, BaseSRMatrix* pmU,
              BaseSRMatrix* pmVH) const override {
        if (pmU != nullptr && pmVH != nullptr) {
            _check_ne(CVM_SIZESMISMATCH, this->msize(), pmU->msize());
            _check_ne(CVM_SIZESMISMATCH, this->nsize(), pmVH->msize());
        }
        __svd<TR,basic_srbmatrix,
            BaseSRMatrix>(vRes, vRes.size(), vRes.incr(), *this, pmU, pmVH);
    }

    void _pinv(BaseRMatrix& mX, TR threshold) const override {
        __pinv<TR,basic_srbmatrix, BaseRMatrix>(mX, *this, threshold);
    }

    void _eig(CVector& vEig, basic_scmatrix<TR,TC>* mEigVect,
              bool bRightVect) const override {
        _bake_SM();
        mSM._eig(vEig, mEigVect, bRightVect);
    }

    void _solve(const RVector& vB, RVector& vX,
                TR& dErr, const TR* pLU, const tint* pPivots,
                int transp_mode) const override {
        vX = vB;
        RVector vB1;
        RVector vX1;
        if (vB.incr() > 1) vB1 << vB;  // to make sure incr = 1
        if (vX.incr() > 1) vX1 << vX;
        __solve<TR,TR, basic_srbmatrix>(*this, 1, vB.incr() > 1 ? vB1 : vB, vB.size(),
                                        vX.incr() > 1 ? vX1 : vX, vX.size(),
                                        dErr, pLU, pPivots, transp_mode);
        if (vX.incr() > 1) vX = vX1;
    }

    void _solve(const BaseRMatrix& mB, BaseRMatrix& mX, TR& dErr,
                const TR* pLU, const tint* pPivots,
                int transp_mode) const override {
        mX = mB;
        __solve<TR,TR, basic_srbmatrix>(*this, mB.nsize(), mB, mB.ld(),
                                        mX, mX.ld(), dErr, pLU, pPivots, transp_mode);
    }

    // ?gbmv routines perform a matrix-vector operation defined as
    // vRes = alpha*m*v + beta * vRes or vRes = alpha*v'*m + beta * vRes
    // not virtual since __gbmv calls all virtual methods inside
    void _gbmv(bool bLeft, TR dAlpha, const RVector& v, TR dBeta, RVector& vRes) const {
        RVector vTmp;
        basic_srbmatrix mTmp;
        const TR* pDv = v;
        if (vRes.get() == pDv) vTmp << v;
        if (vRes.get() == this->get()) mTmp << *this;
        __gbmv<TR,basic_srbmatrix,
            RVector>(bLeft,
                     vRes.get() == this->get() ? mTmp : *this, dAlpha,
                     vRes.get() == pDv ? vTmp : v, dBeta, vRes);
    }

    void _check_submatrix() const override {
        throw cvmexception(CVM_SUBMATRIXNOTAVAILABLE, "srbmatrix");
    }

    const TR* _pb() const override {
        return this->get();
    }

    TR* _pb() override {
        return this->get();
    }

protected:
    void _bake_SM() const {
        mSM.resize(this->msize());
        mSM.vanish();
        _copy_b_matrix<TR,TR, BaseSRMatrix, basic_srbmatrix>(mSM, *const_cast<basic_srbmatrix*>(this), false);
    }

    tint _size() const override {
        return this->size();
    }

    tint _msize() const override {
        return this->msize();
    }

    tint _nsize() const override {
        return this->nsize();
    }

    tint _ld() const override {
        return this->ld();
    }

    bool _is_empty_b() const override {
        return this->_is_empty();
    }

    void _set_p(TR* pf) override {
#ifdef CVM_USE_POOL_MANAGER
        this->mpd = pf;
#else
        this->mpf = pf;
#endif
    }

    void _set(TR* pf, tint nSize, tint nM, tint nN, tint nIncr, tint nLD) override {
#ifdef CVM_USE_POOL_MANAGER
        this->mpd = pf;
#else
        this->mpf = pf;
#endif
        this->msz = nSize;
        this->mm = nM;
        this->mn = nN;
        this->mincr = nIncr;
        this->mld = nLD;
    }

    // for _msum _mdiff etc.
    const TR* _pp(const BaseMatrix& m) const override {
        return m.get();
    }

    tint _ldm() const override {
        return this->mm;
    }

    const tint* _pldm() const override {
        return &this->mm;
    }

    // 0-based, returns an l-value sharing memory
    RVector _row(tint m) override {
        RVector vRet(this->msize());
        this->_get_row(m, vRet, vRet.incr());
        return vRet;
    }

    // 0-based, returns not an l-value (copy)
    // looks like cut-n-paste, but it's not
    RVector _row(tint m) const override {
        RVector vRet(this->msize());
        this->_get_row(m, vRet, vRet.incr());
        return vRet;
    }

    // 0-based, returns an l-value sharing memory
    RVector _col(tint n) override {
        RVector vRet(this->msize());
        this->_get_col(n, vRet, vRet.incr());
        return vRet;
    }

    // 0-based, returns not an l-value (copy)
    // looks like cut-n-paste, but it's not
    RVector _col(tint n) const override {
        RVector vRet(this->msize());
        this->_get_col(n, vRet, vRet.incr());
        return vRet;
    }

    RVector _diag(tint nDiag) override {
        const tint nD = std::abs(nDiag);
        if (nDiag < 0) {
            _check_gt(CVM_INDEX_GT, nD, this->lsize());
        }
        else {
            _check_gt(CVM_INDEX_GT, nDiag, this->usize());
        }
        const tint nLU = this->lsize() + this->usize();
        return RVector(this->get() + this->usize() + (nDiag < 0 ? nD : nD * nLU), this->msize() - nD, nLU + 1);
    }

    RVector _diag(tint nDiag) const override {
        const tint nD = std::abs(nDiag);
        if (nDiag < 0) {
            _check_gt(CVM_INDEX_GT, nD, this->lsize());
        }
        else {
            _check_gt(CVM_INDEX_GT, nDiag, this->usize());
        }
        const tint nLU = this->lsize() + this->usize();
        return RVector(this->get() + this->usize() + (nDiag < 0 ? nD : nD * nLU), this->msize() - nD, nLU + 1);
    }

    void _swap_rows(tint, tint) override { throw cvmexception(CVM_METHODNOTAVAILABLE, "swap_rows", "srbmatrix");}
    void _swap_cols(tint, tint) override { throw cvmexception(CVM_METHODNOTAVAILABLE, "swap_cols", "srbmatrix");}
    void _check_ger()           override { throw cvmexception(CVM_METHODNOTAVAILABLE, "ger", "srbmatrix");}
    void _check_rank1update()   override { throw cvmexception(CVM_METHODNOTAVAILABLE, "rank1update", "srbmatrix");}
    void _check_gemm()          override { throw cvmexception(CVM_METHODNOTAVAILABLE, "gemm", "srbmatrix");}
    void _check_symm()          override { throw cvmexception(CVM_METHODNOTAVAILABLE, "symm", "srbmatrix");}
    void _check_cholesky()      override { throw cvmexception(CVM_METHODNOTAVAILABLE, "cholesky", "srbmatrix");}
    void _check_bunch_kaufman() override { throw cvmexception(CVM_METHODNOTAVAILABLE, "bunch_kaufman", "srbmatrix");}

    void _resize2(tint nNewM, tint) override {
#ifdef CVM_USE_POOL_MANAGER
        this->_bresize(nNewM);
#else
        this->_bresize(this->mp, nNewM);
#endif
    }

    bool _continuous() const override {
        return this->_bcontinuous();
    }

    void _massign(const BaseMatrix& m) override {
        this->_mbassign(m);
    }

    void _set(TR d) override {
        this->_bset(d);
    }

    void _vanish() override {
        this->_bvanish();
    }

    type_proxy<TR,TR> _ij_proxy_val(tint i, tint j) override {
        return this->_b_ij_proxy_val(i, j);
    }

    TR _ij_val(tint i, tint j) const override {
        return this->_b_ij_val(i, j);
    }

    void _transp() override {
#ifdef CVM_USE_POOL_MANAGER
        this->_btransp();
#else
        this->_btransp(this->mp);
#endif
    }

    void _plus_plus() override {
        this->_b_plus_plus();
    }

    void _minus_minus() override {
        this->_b_minus_minus();
    }

    tint _indofmax() const override {
        this->_check_ld();
        _bake_SM();
        return mSM.indofmax();
    }

    tint _indofmin() const override {
        this->_check_ld();
        _bake_SM();
        return mSM.indofmin();
    }

    // returns main diagonal of low_up factorization
    RVector _low_up_diag(basic_array<tint,tint>& naPivots) const override {
        // let temp matrix be const to get a copy of its main diagonal
        const basic_srbmatrix lu = this->low_up(naPivots);
        return lu.diag(0);
    }

    void _scalr(TR d) override {
        __scal<TR,TR>(this->get(), this->size(), this->incr(), d);  // zero tails are supposed here
    }

    void _mult(const BaseRMatrix& m1, const BaseRMatrix& m2) override {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m2.nsize());
        _check_ne(CVM_SIZESMISMATCH, m1.nsize(), m2.msize());
        BaseSRMatrix mR(this->msize());
        mR.mult(m1, m2);
#ifdef CVM_USE_POOL_MANAGER
        this->_resize_lu(this->msize() - 1, this->msize() - 1);
#else
        this->_resize_lu(this->mp, this->msize() - 1, this->msize() - 1);
#endif
        _copy_b_matrix<TR,TR, BaseSRMatrix, basic_srbmatrix>(const_cast<BaseSRMatrix&>(mR), *this, true);
    }

    void _multiply(RVector& vRes, const RVector& v, bool bLeft) const override {
        const TR zero(0.);
        const TR one(1.);
        this->_gbmv(bLeft, one, v, zero, vRes);
    }

    void _randomize(TR dFrom, TR dTo) override {
        __randomize<TR>(this->get(), this->size(), this->incr(), dFrom, dTo);
    }

    void _low_up(tint* nPivots) override {
        __low_up<basic_srbmatrix>(*this, nPivots);
    }

    tint _ld_for_replace() const override {
        return this->mm;
    }

    tint _size_for_replace() const override {
        return this->mm * this->mn;
    }
//! @endcond
};


/**
@brief End-user class encapsulating band square matrix of complex numbers

\c TR type stands for \ref treal. Please use predefined \ref scbmatrix class in your applications.
Band storage can be described as follows (cited from MKL manual): an \f$m\f$ by \f$n\f$ band matrix
with \f$k_l\f$ sub-diagonals and \f$k_u\f$ super-diagonals is stored
compactly in a two-dimensional array with \f$k_l+k_u+1\f$ rows and \f$n\f$ columns. Columns of the
matrix are stored in the corresponding columns of the array, and diagonals of the matrix are
stored in rows of the array}. This way of storage can be illustrated as follows
(referenced elements are shown as \f$*\f$, not referenced as \f$-\f$, zeros are not stored):
\f[\begin{aligned}
m=n=3, k_l=0, k_u=0&:\ \begin{bmatrix} * & 0 & 0 \\
0 & * & 0 \\
0 & 0 & * \end{bmatrix}\\
m=n=4, k_l=1, k_u=0&:\ \begin{bmatrix} * & 0 & 0 & 0 \\ * & * & 0 & 0 \\
0 & * & * & 0 \\
0 & 0 & * & * \\
&   &   & - \end{bmatrix}\\
m=n=6, k_l=1, k_u=2&:\ \begin{bmatrix} - &   &   &   &   &  \\ - & - &   &   &   &  \\ * & * & * & 0 & 0 & 0 \\ * & * & * & * & 0 & 0 \\
0 & * & * & * & * & 0 \\
0 & 0 & * & * & * & * \\
0 & 0 & 0 & * & * & * \\
0 & 0 & 0 & 0 & * & * \\
&   &   &   &   & - \end{bmatrix}
\end{aligned}\f]
CVM library implements square band matrices only, therefore \f$m=n\f$ is satisfied for them.
@see BandMatrix
*/
template<typename TR, typename TC>
class basic_scbmatrix : public basic_scmatrix<TR,TC>, public BandMatrix<TR,TC>
{
    using CVector = basic_cvector<TR,TC>;  //!< \ref cvector
    using BaseArray = basic_array<TR,TC>;  //!< Base basic_array class
    using BaseMatrix = Matrix<TR,TC>;  //!< Base Matrix class
    using BaseCMatrix = basic_cmatrix<TR,TC>;  //!< Base \ref cmatrix class
    using BaseSCMatrix = basic_scmatrix<TR,TC>;  //!< Base \ref scmatrix class
    using BaseBandMatrix = BandMatrix<TR,TC>;  //!< Base BandMatrix class

protected:
    mutable BaseSCMatrix mSM;  //!< Temporary storage for square matrix enclosing band one (if needed)

public:
/**
@brief Default constructor

Creates empty square band matrix. No memory gets allocated.
\par Example:
\code
using namespace cvm;
scbmatrix m;
std::cout << m.msize() << " " << m.nsize() << " " << m.size() ;
std::cout << " " << m.lsize() << " " << m.usize() << std::endl;
m.resize(3).resize_lu(1,0).set(std::complex<double>(1.,2.));
std::cout << m;
\endcode
prints
\code
0 0 0 0 0
(1,2) (0,0) (0,0)
(1,2) (1,2) (0,0)
(0,0) (1,2) (1,2)
\endcode
*/
    basic_scbmatrix()
      : mSM()
    {}

/**
@brief Diagonal band matrix constructor

Creates \f$n\times n\f$ \ref scbmatrix object where dimension \f$n\f$ is passed in
\c nDim parameter. The matrix created is diagonal, i.e. \f$k_l=k_u=0\f$.
Constructor throws \ref cvmexception in case of non-positive size passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
scbmatrix m(4);
std::cout << m.msize() << " " << m.nsize() << " " << m.size() ;
std::cout << " " << m.lsize() << " " << m.usize() << std::endl;
m.set(std::complex<double>(1.,2.));
std::cout << m;
\endcode
prints
\code
4 4 4 0 0
(1,2) (0,0) (0,0) (0,0)
(0,0) (1,2) (0,0) (0,0)
(0,0) (0,0) (1,2) (0,0)
(0,0) (0,0) (0,0) (1,2)
\endcode
@param[in] nDim Number of rows and columns.
*/
    explicit basic_scbmatrix(tint nDim)
      : BaseSCMatrix(nDim, 1, true),
        BaseBandMatrix(0, 0)
    {}

/**
@brief Band matrix constructor

Creates \ref scbmatrix object of dimension passed in \c nDim parameter. The matrix created has \c nKL
sub-diagonals and \c nKU super-diagonals. Constructor throws \ref cvmexception
in case of non-positive size or negative number of sub-diagonals or super-diagonals
passed or in case of memory allocation failure.
Example:
\code
using namespace cvm;
scbmatrix m(4,1,1);
m.set(std::complex<double>(1.,2.));
std::cout << m << std::endl
          << m.msize() << " " << m.nsize() << " " << m.size()
          << " " << m.lsize() << " " << m.usize() << std::endl;
\endcode
prints
\code
(1,2) (1,2) (0,0) (0,0)
(1,2) (1,2) (1,2) (0,0)
(0,0) (1,2) (1,2) (1,2)
(0,0) (0,0) (1,2) (1,2)

4 4 12 1 1
\endcode
@param[in] nDim Number of rows and columns.
@param[in] nKL Number of lower sub-diagonals.
@param[in] nKU Number of upper super-diagonals.
*/
    basic_scbmatrix(tint nDim, tint nKL, tint nKU)
      : BaseSCMatrix(nDim, 1 + nKL + nKU, true),
        BaseBandMatrix(nKL, nKU), mSM() {
        this->_check_dimensions();
    }

/**
@brief Constructor

Creates \f$n\times n\f$ \ref scbmatrix object where \f$n\f$ is passed in \c nDim parameter.
The matrix created has \c nKL
sub-diagonals and \c nKU super-diagonals. Constructor throws \ref cvmexception
in case of non-positive size or negative number of sub-diagonals or super-diagonals
passed or in case of memory allocation failure.
Unlike others, this constructor <b>does not allocate memory</b>.
It just shares memory with an array pointed to by \c pd (for matrices \c nIncr=1 is always satisfied).
\par Example:
\code
using namespace cvm;
double a[] = {1., 1., 1., 1., 1., 1., 1., 1.,
              1., 1., 1., 1., 1., 1., 1., 1.};
scbmatrix ml((std::complex<double>*)a,4,1,0);
scbmatrix mu((std::complex<double>*)a,4,0,1);
ml(2,1) = std::complex<double>(5.,5.);
std::cout << ml << std::endl << mu << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << " "
          << a[3] << " " << a[4] << " " << a[5] << " " << std::endl;
\endcode
prints
\code
(1,1) (0,0) (0,0) (0,0)
(5,5) (1,1) (0,0) (0,0)
(0,0) (1,1) (1,1) (0,0)
(0,0) (0,0) (1,1) (1,1)

(5,5) (1,1) (0,0) (0,0)
(0,0) (1,1) (1,1) (0,0)
(0,0) (0,0) (1,1) (1,1)
(0,0) (0,0) (0,0) (1,1)

1 1 5 5 1 1
\endcode
@see http://cvmlib.com/faq.htm
@see basic_cmatrix::basic_cmatrix(TC*,tint,tint)
@param[in] pd Pointer to an array to share memory with.
@param[in] nDim Number of rows and columns.
@param[in] nKL Number of lower sub-diagonals.
@param[in] nKU Number of upper super-diagonals.
*/
    basic_scbmatrix(TC* pd, tint nDim, tint nKL, tint nKU)
      : BaseSCMatrix(pd, nDim, 1 + nKL + nKU, nDim * (1 + nKL + nKU)),
        BaseBandMatrix(nKL, nKU), mSM() {
        this->_check_dimensions();
    }

/**
@brief Constructor

Creates \f$n\times n\f$ \ref scbmatrix object where \f$n\f$ is passed in \c nDim parameter.
The matrix created has \c nKL
sub-diagonals and \c nKU super-diagonals. Constructor throws \ref cvmexception
in case of non-positive size or negative number of sub-diagonals or super-diagonals
passed or in case of memory allocation failure.
Then constructor copies \f$(k_l + k_u + 1)*n\f$ elements of an array  \c pd to the
matrix according to band storage.
\par Example:
\code
using namespace cvm;
const double a[] = {1., 1., 1., 1., 1., 1., 1., 1.,
                    1., 1., 1., 1., 1., 1., 1., 1.};
scbmatrix ml((const std::complex<double>*)a,4,1,0);
scbmatrix mu((const std::complex<double>*)a,4,0,1);
ml(2,1) = std::complex<double>(5.,5.);
std::cout << ml << std::endl << mu << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << " "
          << a[3] << " " << a[4] << " " << a[5] << " " << std::endl;
\endcode
prints
\code
(1,1) (0,0) (0,0) (0,0)
(5,5) (1,1) (0,0) (0,0)
(0,0) (1,1) (1,1) (0,0)
(0,0) (0,0) (1,1) (1,1)

(1,1) (1,1) (0,0) (0,0)
(0,0) (1,1) (1,1) (0,0)
(0,0) (0,0) (1,1) (1,1)
(0,0) (0,0) (0,0) (1,1)

1 1 1 1 1 1
\endcode
@see http://cvmlib.com/faq.htm
@see basic_cmatrix::basic_cmatrix(TC*,tint,tint)
@param[in] pd Pointer to an array to share memory with.
@param[in] nDim Number of rows and columns.
@param[in] nKL Number of lower sub-diagonals.
@param[in] nKU Number of upper super-diagonals.
*/
    basic_scbmatrix(const TC* pd, tint nDim, tint nKL, tint nKU)
      : BaseSCMatrix(pd, nDim, 1 + nKL + nKU, nDim * (1 + nKL + nKU)),
        BaseBandMatrix(nKL, nKU), mSM() {
        this->_check_dimensions();
    }

/**
@brief Copy constructor

Creates \ref scbmatrix object as a copy of band matrix \c m.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16.};
scbmatrix m((std::complex<double>*)a,4,1,0);
scbmatrix mc(m);
m(1,1) = 7.77;
std::cout << m << std::endl << mc;
\endcode
prints
\code
(7.77,0) (0,0) (0,0) (0,0)
(3,4) (5,6) (0,0) (0,0)
(0,0) (7,8) (9,10) (0,0)
(0,0) (0,0) (11,12) (13,14)

(1,2) (0,0) (0,0) (0,0)
(3,4) (5,6) (0,0) (0,0)
(0,0) (7,8) (9,10) (0,0)
(0,0) (0,0) (11,12) (13,14)
\endcode
@param[in] m \ref scbmatrix to copy from.
*/
    basic_scbmatrix(const basic_scbmatrix& m)
      : BaseSCMatrix(m.msize(), 1 + m.lsize() + m.usize(), false),
        BaseBandMatrix(m.lsize(), m.usize()), mSM() {
        this->_massign(m);
    }

/**
@brief Move constructor

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to newly created object.
It's usually executed implicitly in cases like this:
\code
rvector a(b + c);
\endcode
or this
\code
rvector a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to newly created object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_scbmatrix(basic_scbmatrix&& m) noexcept
      : BaseSCMatrix(m.size(), m.incr(), m.msize(), m.nsize(), m.ld()),
        BaseBandMatrix(m.lsize(), m.usize()), mSM() {
        this->_mmove(std::move(m));
    }

/**
@brief Constructor

Creates \ref scbmatrix object as a copy of \e sliced
matrix \c m, i.e. it copies main diagonal, \c nKL sub-diagonals and \c nKU super-diagonals of a matrix \c m.
It's assumed that \f$m\times n\f$ matrix \c m must have equal sizes, i.e. \f$m = n\f$ is satisfied.
Constructor throws \ref cvmexception if this is not true or in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16., 17., 18.};
scmatrix m((std::complex<double>*)a,3);
scbmatrix mb(m,1,0);
std::cout << m << std::endl << mb;
\endcode
prints
\code
(1,2) (7,8) (13,14)
(3,4) (9,10) (15,16)
(5,6) (11,12) (17,18)

(1,2) (0,0) (0,0)
(3,4) (9,10) (0,0)
(0,0) (11,12) (17,18)
\endcode
@param[in] m \ref cmatrix to copy diagonal and subdiagonals from.
@param[in] nKL Number of lower sub-diagonals.
@param[in] nKU Number of upper super-diagonals.
*/
    basic_scbmatrix(const BaseCMatrix& m, tint nKL, tint nKU)
      : BaseSCMatrix(m.msize(), 1 + nKL + nKU, false),
        BaseBandMatrix(nKL, nKU), mSM() {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), this->nsize());
        this->_check_dimensions();
        _copy_b_matrix<TR,TC, BaseCMatrix, basic_scbmatrix>(const_cast<BaseCMatrix&>(m), *this, true);
    }

/**
@brief Constructor

Creates \ref scbmatrix object of size \c v.size() by \c v.size()
and assigns vector \c v to its main diagonal.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6.};
cvector v((std::complex<double>*)a,3);
scbmatrix m(v);
std::cout << m;
\endcode
prints
\code
(1,2) (0,0) (0,0)
(0,0) (3,4) (0,0)
(0,0) (0,0) (5,6)
\endcode
@param[in] v \ref cvector to copy main diagonal from.
*/
    explicit basic_scbmatrix(const CVector& v)
      : BaseSCMatrix(v.size(), 1, false),
        BaseBandMatrix(0, 0) {
        __copy<TC>(this->msize(), v, v.incr(), this->get(), 1);
    }

/**
@brief Constructor

Creates \ref scbmatrix object with dimensions of passed real band matrix \c m
and copies matrix \c m to real part if \c bRealPart is \c true or to imaginary part otherwise.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
const srbmatrix m(a,4,1,0);
scbmatrix mr(m), mi(m, false);
std::cout << mr << std::endl << mi;
\endcode
prints
\code
(1,0) (0,0) (0,0) (0,0)
(2,0) (3,0) (0,0) (0,0)
(0,0) (4,0) (5,0) (0,0)
(0,0) (0,0) (6,0) (7,0)

(0,1) (0,0) (0,0) (0,0)
(0,2) (0,3) (0,0) (0,0)
(0,0) (0,4) (0,5) (0,0)
(0,0) (0,0) (0,6) (0,7)
\endcode
@param[in] m \ref srbmatrix to copy elements from.
@param[in] bRealPart \c true to copy \c m to real part, \c false to copy to imaginary part.
*/
    explicit basic_scbmatrix(const basic_srbmatrix<TR>& m, bool bRealPart = true)
      : BaseSCMatrix(m.msize(), m.ld(), true),
        BaseBandMatrix(m.lsize(), m.usize()),
        mSM() {
        if (bRealPart) {
            __copy2<TR,TC>(this->get(), this->size(), this->incr(), m.get(), nullptr);
        }
        else {
            __copy2<TR,TC>(this->get(), this->size(), this->incr(), nullptr, m.get());
        }
    }

/**
@brief Constructor

Creates \ref scbmatrix object with dimensions of passed real band matrices \c mRe
(if one of these dimensions differs from appropriate size of matrix
\c mIm then constructor throws \ref cvmexception)
and copies matrices \c mRe and \c mIm to real and imaginary part of the matrix created respectively.
Constructor also throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
srbmatrix mr(4,1,0), mi(4,1,0);
mr.set(1.);
mi.set(2.);
const scbmatrix m(mr,mi);
std::cout << m;
\endcode
prints
\code
(1,2) (0,0) (0,0) (0,0)
(1,2) (1,2) (0,0) (0,0)
(0,0) (1,2) (1,2) (0,0)
(0,0) (0,0) (1,2) (1,2)
\endcode
@param[in] mRe \ref srbmatrix to copy to real part.
@param[in] mIm \ref srbmatrix to copy to imaginary part.
*/
    basic_scbmatrix(const basic_srbmatrix<TR>& mRe, const basic_srbmatrix<TR>& mIm)
      : BaseSCMatrix(mRe.msize(), mRe.ld(), false),
        BaseBandMatrix(mRe.lsize(), mRe.usize()),
        mSM() {
        _check_ne(CVM_SIZESMISMATCH, mRe.msize(), mIm.msize());
        _check_ne(CVM_SIZESMISMATCH, mRe.nsize(), mIm.nsize());
        _check_ne(CVM_SIZESMISMATCH, mRe.lsize(), mIm.lsize());
        _check_ne(CVM_SIZESMISMATCH, mRe.usize(), mIm.usize());
        __copy2<TR,TC>(this->get(), this->size(), this->incr(), mRe, mIm, mRe.incr(), mIm.incr());
    }

    // TODO dox
    // real part
    basic_srbmatrix<TR> real() const {
        basic_srbmatrix<TR> mRet(this->msize(), this->lsize(), this->usize());
        __copy<TR>(this->size(), __get_real_p<TR>(this->get()), this->incr() * 2, mRet, mRet.incr());
        return mRet;
    }

    // imaginary part
    basic_srbmatrix<TR> imag() const {
        basic_srbmatrix<TR> mRet(this->msize(), this->lsize(), this->usize());
        __copy<TR>(this->size(), __get_imag_p<TR>(this->get()), this->incr() * 2, mRet, mRet.incr());
        return mRet;
    }

/**
@brief Assignment operator

Sets every element of a calling \ref scbmatrix to be equal to
appropriate element of a matrix \c m and returns a reference to
the matrix changed.
Operator throws \ref cvmexception in case of different matrix dimensions.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12.};
    scbmatrix m1((std::complex<double>*)a,3,1,0);
    scbmatrix m2(3,1,0);
    m2 = m1;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(1.00e+00,2.00e+00) (0.00e+00,0.00e+00) (0.00e+00,0.00e+00)
(3.00e+00,4.00e+00) (5.00e+00,6.00e+00) (0.00e+00,0.00e+00)
(0.00e+00,0.00e+00) (7.00e+00,8.00e+00) (9.00e+00,1.00e+01)
\endcode
@param[in] m \ref scbmatrix to assign from.
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& operator = (const basic_scbmatrix& m) {
        this->_check_dimensions(m);
        this->_massign(m);
        return *this;
    }

/**
@brief Move assignment operator

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to a calling object.
It's usually executed implicitly in cases like this:
\code
a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to a calling object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_scbmatrix& operator = (basic_scbmatrix&& m) noexcept {
        this->_check_dimensions(m);
        BaseSCMatrix::operator = (std::move(m));
        return *this;
    }

    // TODO dox
    // assigns vector
    basic_scbmatrix& assign(const CVector& v) {
        _check_gt(CVM_SIZESMISMATCH_GT, this->size(), v.size());
        this->_assign(v, v.incr());
        return *this;
    }

    // assigns a external array (nIncr = 1)
    basic_scbmatrix& assign(const TC* pd) {
        this->_assign(pd, 1);
        return *this;
    }

    basic_scbmatrix& set(TC c) {
        this->_set(c);
        return *this;
    }

/**
@brief Assignment to real parts

Sets real part of every element of a calling complex band matrix to a value of
appropriate element of \ref srbmatrix \c mRe and returns a reference to
the matrix changed. Function throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
srbmatrix m(3,0,1);
scbmatrix mc(3,0,1);
m.randomize(0., 1.);
mc.assign_real(m);
std::cout << mc;
\endcode
prints
\code
(5.44e-01,0.00e+00) (5.48e-02,0.00e+00) (0.00e+00,0.00e+00)
(0.00e+00,0.00e+00) (3.66e-01,0.00e+00) (3.49e-01,0.00e+00)
(0.00e+00,0.00e+00) (0.00e+00,0.00e+00) (8.00e-01,0.00e+00)
\endcode
@param[in] mRe \ref srbmatrix to assign to real part.
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& assign_real(const basic_srbmatrix<TR>& mRe) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mRe.msize());
        _check_ne(CVM_SIZESMISMATCH, this->lsize(), mRe.lsize());
        _check_ne(CVM_SIZESMISMATCH, this->usize(), mRe.usize());
        __copy_real<TR,TC>(this->get(), this->size(), this->incr(), mRe, mRe.incr());
        return *this;
    }

/**
@brief Assignment to imaginary parts

Sets imaginary part of every element of a calling complex band matrix to a value of
appropriate element of \ref srbmatrix \c mIm and returns a reference to
the matrix changed. Function throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
srbmatrix m(3,0,1);
scbmatrix mc(3,0,1);
m.randomize(0., 1.);
mc.assign_imag(m);
std::cout << mc;
\endcode
prints
\code
(0.00e+00,5.53e-01) (0.00e+00,2.16e-01) (0.00e+00,0.00e+00)
(0.00e+00,0.00e+00) (0.00e+00,1.57e-01) (0.00e+00,1.12e-01)
(0.00e+00,0.00e+00) (0.00e+00,0.00e+00) (0.00e+00,7.03e-01)
\endcode
@param[in] mIm \ref srbmatrix to assign to imaginary part.
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& assign_imag(const basic_srbmatrix<TR>& mIm) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mIm.msize());
        _check_ne(CVM_SIZESMISMATCH, this->lsize(), mIm.lsize());
        _check_ne(CVM_SIZESMISMATCH, this->usize(), mIm.usize());
        __copy_imag<TR,TC>(this->get(), this->size(), this->incr(), mIm, mIm.incr());
        return *this;
    }

    // TODO dox
    // fills real part
    basic_scbmatrix& set_real(TR d) {
        this->_set_real_number(d);
        return *this;
    }

    // fills imaginary part
    basic_scbmatrix& set_imag(TR d) {
        this->_set_imag_number(d);
        return *this;
    }

    basic_scbmatrix& resize(tint nNewDim) {
        this->_resize2(nNewDim, nNewDim);
        return *this;
    }

/**
@brief Changes number of sub- and super-diagonals

Changes number of sub- and super-diagonals of a calling complex band matrix to \c nNewKL and \c nNewKU respectively
and returns a reference to the matrix changed. In case of increasing of the numbers, calling matrix
is filled up with zeroes.
Function throws \ref cvmexception in case of negative number passed or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9., 10., 11., 12.};
    scbmatrix m((std::complex<double>*)a,3,1,0);
    std::cout << m << std::endl;
    m.resize_lu(0,1);
    m.diag(1).set(std::complex<double>(9.,9.));
    std::cout << m;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(1,2) (0,0) (0,0)
(3,4) (5,6) (0,0)
(0,0) (7,8) (9,10)

(1,2) (9,9) (0,0)
(0,0) (5,6) (9,9)
(0,0) (0,0) (9,10)
\endcode
@param[in] nNewKL New number of lower sub-diagonals.
@param[in] nNewKU New number of upper super-diagonals.
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& resize_lu(tint nNewKL, tint nNewKU) {
#ifdef CVM_USE_POOL_MANAGER
        this->_resize_lu(nNewKL, nNewKU);
#else
        this->_resize_lu(this->mp, nNewKL, nNewKU);
#endif
        return *this;
    }

/**
@brief Band matrix comparison

Operator compares calling band matrix with complex band matrix \c m
and returns \c true if they have same dimensions
and their appropriate elements differ by not more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
scbmatrix m1((std::complex<double>*)a,2,1,0);
scbmatrix m2(2,1,0);
std::cout << m1 << std::endl;
m2(1,1) = std::complex<double>(1.,2.);
m2(2,1) = std::complex<double>(3.,4.);
m2(2,2) = std::complex<double>(5.,6.);
std::cout << (m1 == m2) << std::endl;
\endcode
prints
\code
(1,2) (0,0)
(3,4) (5,6)

1
\endcode
@see operator !=()
@param[in] m \ref scbmatrix to compare to.
@return bool Result of comparison.
*/
    bool operator == (const basic_scbmatrix& m) const {
        return this->msize() == m.msize() && this->nsize() == m.nsize() &&
               this->lsize() == m.lsize() && this->usize() == m.usize() && this->_mequals(m);
    }

/**
@brief Band matrix comparison

Operator compares calling band matrix with complex band matrix \c m
and returns \c true if they have different dimensions
or at least one of their appropriate elements differs by more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
scbmatrix m1((std::complex<double>*)a,2,1,0);
scbmatrix m2(2,1,0);
std::cout << m1 << std::endl;
m2(1,1) = std::complex<double>(1.,2.);
m2(2,1) = std::complex<double>(3.,4.);
m2(2,2) = std::complex<double>(5.,6.00001);
std::cout << (m1 != m2) << std::endl;
\endcode
prints
\code
(1,2) (0,0)
(3,4) (5,6)

1
\endcode
@see operator ==()
@param[in] m \ref scbmatrix to compare to.
@return bool Result of comparison.
*/
    bool operator != (const basic_scbmatrix& m) const {
        return !(this->operator == (m));
    }

/**
@brief Matrix replacement

Destroys calling band matrix, creates a new one as a copy of band matrix \c m
and returns a reference to the matrix changed. Operator throws \ref cvmexception
in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    scbmatrix m(3,1,0);
    scbmatrix mc(1);
    m(2,1) = std::complex<double>(1.,2.);
    m(2,2) = std::complex<double>(3.,4.);
    std::cout << m << std::endl << mc << std::endl;

    mc << m;
    std::cout << mc;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(0,0) (0,0) (0,0)
(1,2) (3,4) (0,0)
(0,0) (0,0) (0,0)

(0,0)

(0,0) (0,0) (0,0)
(1,2) (3,4) (0,0)
(0,0) (0,0) (0,0)
\endcode
@see operator =()
@param[in] m \ref scbmatrix to replace by.
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& operator << (const basic_scbmatrix& m) {
        this->_check_ld();  // submatrix replacement is obviously not possible
#ifdef CVM_USE_POOL_MANAGER
        this->_b_replace(m);
#else
        this->_b_replace(this->mp, m);
#endif
        this->_massign(m);
        return *this;
    }

/**
@brief Addition operator

Creates an object of type \ref scbmatrix as a sum of a calling matrix and a matrix \c m.
Operator throws \ref cvmexception
in case of different dimensions of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8.,
                  9., 10., 11., 12.};
    double b[] = {10., 20., 30., 40., 50., 60.,
                  70., 80., 90., 100., 110., 120.};
    scbmatrix m1((std::complex<double>*)a,3,0,1);
    scbmatrix m2((std::complex<double>*)b,3,0,1);
    std::cout << m1 << std::endl << m2 << std::endl;
    std::cout << m1 + m2 << std::endl << m1 + m1;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(3,4) (5,6) (0,0)
(0,0) (7,8) (9,10)
(0,0) (0,0) (11,12)

(30,40) (50,60) (0,0)
(0,0) (70,80) (90,100)
(0,0) (0,0) (110,120)

(33,44) (55,66) (0,0)
(0,0) (77,88) (99,110)
(0,0) (0,0) (121,132)

(6,8) (10,12) (0,0)
(0,0) (14,16) (18,20)
(0,0) (0,0) (22,24)
\endcode
@see sum()
@param[in] m \ref scbmatrix to add to a calling one.
@return Sum of matrices.
*/
    basic_scbmatrix operator + (const basic_scbmatrix& m) const {
        this->_check_dimensions(m);
        basic_scbmatrix mSum(*this);
        mSum._mincr(m);
        return mSum;
    }

/**
@brief Subtraction operator

Creates an object of type \ref scbmatrix as a difference of
a calling band matrix and band matrix \c m.
It throws \ref cvmexception in case of different dimensions of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8.,
                  9., 10., 11., 12.};
    double b[] = {10., 20., 30., 40., 50., 60.,
                  70., 80., 90., 100., 110., 120.};
    scbmatrix m1((std::complex<double>*)a,3,0,1);
    scbmatrix m2((std::complex<double>*)b,3,0,1);
    std::cout << m1 << std::endl << m2 << std::endl;
    std::cout << m1 - m2 << std::endl << m1 - m1;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(3,4) (5,6) (0,0)
(0,0) (7,8) (9,10)
(0,0) (0,0) (11,12)

(30,40) (50,60) (0,0)
(0,0) (70,80) (90,100)
(0,0) (0,0) (110,120)

(-27,-36) (-45,-54) (0,0)
(0,0) (-63,-72) (-81,-90)
(0,0) (0,0) (-99,-108)

(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
@see diff()
@param[in] m \ref scbmatrix to subtract from calling one.
@return Difference of matrices.
*/
    basic_scbmatrix operator - (const basic_scbmatrix& m) const {
        this->_check_dimensions(m);
        basic_scbmatrix mDiff(*this);
        mDiff._mdecr(m);
        return mDiff;
    }

/**
@brief Sum of matrices

Assigns sum of complex square band matrices \c m1 and \c m2 to a calling matrix
and returns a reference to the matrices changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.,
              9., 10., 11., 12.};
const scbmatrix m1((std::complex<double>*)a,3,1,0);
scbmatrix m2(3,1,0);
scbmatrix m(3,1,0);
m2.set(std::complex<double>(1.,1.));
std::cout << m1 << std::endl << m2 << std::endl;
std::cout << m.sum(m1, m2) << std::endl;
std::cout << m.sum(m, m2);
\endcode
prints
\code
(1,2) (0,0) (0,0)
(3,4) (5,6) (0,0)
(0,0) (7,8) (9,10)

(1,1) (0,0) (0,0)
(1,1) (1,1) (0,0)
(0,0) (1,1) (1,1)

(2,3) (0,0) (0,0)
(4,5) (6,7) (0,0)
(0,0) (8,9) (10,11)

(3,4) (0,0) (0,0)
(5,6) (7,8) (0,0)
(0,0) (9,10) (11,12)
\endcode
@see operator +()
@param[in] m1 First \ref scbmatrix summand.
@param[in] m2 Second \ref scbmatrix summand.
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& sum(const basic_scbmatrix& m1, const basic_scbmatrix& m2) {
        this->_check_dimensions(m1);
        this->_check_dimensions(m2);
        this->_msum(m1, m2);
        return *this;
    }

/**
@brief Difference of matrices

Assigns difference of complex square band matrices \c m1 and \c m2 to a calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.,
              9., 10., 11., 12.};
const scbmatrix m1((std::complex<double>*)a,3,1,0);
scbmatrix m2(3,1,0);
scbmatrix m(3,1,0);
m2.set(std::complex<double>(1.,1.));
std::cout << m1 << std::endl << m2 << std::endl;
std::cout << m.diff(m1, m2) << std::endl;
std::cout << m.diff(m, m2);
\endcode
prints
\code
(1,2) (0,0) (0,0)
(3,4) (5,6) (0,0)
(0,0) (7,8) (9,10)

(1,1) (0,0) (0,0)
(1,1) (1,1) (0,0)
(0,0) (1,1) (1,1)

(0,1) (0,0) (0,0)
(2,3) (4,5) (0,0)
(0,0) (6,7) (8,9)

(-1,0) (0,0) (0,0)
(1,2) (3,4) (0,0)
(0,0) (5,6) (7,8)
\endcode
@see operator -()
@param[in] m1 First \ref scbmatrix subtrahend.
@param[in] m2 Second \ref scbmatrix subtrahend.
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& diff(const basic_scbmatrix& m1, const basic_scbmatrix& m2) {
        this->_check_dimensions(m1);
        this->_check_dimensions(m2);
        this->_mdiff(m1, m2);
        return *this;
    }

/**
@brief Increment operator

Adds \ref scbmatrix \c m to a calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    scbmatrix m1(4,0,1);
    scbmatrix m2(4,0,1);
    m1.set(std::complex<double>(1.,2.));
    m2.set(std::complex<double>(3.,4.));

    m1 += m2;
    std::cout << m1 << std::endl;

    // well, you can do this too, but temporary object would be created
    m2 += m2;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(4,6) (4,6) (0,0) (0,0)
(0,0) (4,6) (4,6) (0,0)
(0,0) (0,0) (4,6) (4,6)
(0,0) (0,0) (0,0) (4,6)

(6,8) (6,8) (0,0) (0,0)
(0,0) (6,8) (6,8) (0,0)
(0,0) (0,0) (6,8) (6,8)
(0,0) (0,0) (0,0) (6,8)
\endcode
@see operator +()
@see sum()
@param[in] m \ref scbmatrix to increment by.
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& operator += (const basic_scbmatrix& m) {
        this->_check_dimensions(m);
        this->_mincr(m);
        return *this;
    }

/**
@brief Decrement operator

Subtracts \ref scbmatrix \c m from calling matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
try {
    scbmatrix m1(4,0,1);
    scbmatrix m2(4,0,1);
    m1.set(std::complex<double>(1.,2.));
    m2.set(std::complex<double>(3.,4.));

    m1 -= m2;
    std::cout << m1 << std::endl;

    // well, you can do this too, but temporary object would be created
    m2 -= m2;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(-2,-2) (-2,-2) (0,0) (0,0)
(0,0) (-2,-2) (-2,-2) (0,0)
(0,0) (0,0) (-2,-2) (-2,-2)
(0,0) (0,0) (0,0) (-2,-2)

(0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0)
\endcode
@see operator -()
@see diff()
@param[in] m \ref scbmatrix to decrement by.
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& operator -= (const basic_scbmatrix& m) {
        this->_check_dimensions(m);
        this->_mdecr(m);
        return *this;
    }

/**
@brief Unary minus operator

Creates an object of type \ref scbmatrix as a calling matrix 
multiplied by \c -1. It throws \ref cvmexception in case of 
memory allocation failure. 
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.,
              9., 10., 11., 12.};
const scbmatrix m((std::complex<double>*)a, 3, 1, 0);
std::cout << m << std::endl << -m;
\endcode
prints
\code
(1,2) (0,0) (0,0) 
(3,4) (5,6) (0,0) 
(0,0) (7,8) (9,10) 

(-1,-2) (0,0) (0,0) 
(-3,-4) (-5,-6) (0,0) 
(0,0) (-7,-8) (-9,-10) 
\endcode
@return Result object.
*/
    basic_scbmatrix operator - () const {
        const TR mone(-1.);
        basic_scbmatrix mRes(*this);
        mRes._scalr(mone);
        return mRes;
    }

/**
@brief Plus identity, prefix

Adds identity matrix to a calling complex square band matrix and
returns a reference to the matrix changed. 
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.,
              9., 10., 11., 12.};
scbmatrix m((std::complex<double>*)a, 3, 1, 0);
std::cout << m << std::endl;
std::cout << ++m << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
(1,2) (0,0) (0,0) 
(3,4) (5,6) (0,0) 
(0,0) (7,8) (9,10) 

(2,2) (0,0) (0,0) 
(3,4) (6,6) (0,0) 
(0,0) (7,8) (10,10) 

(2,2) (0,0) (0,0) 
(3,4) (6,6) (0,0) 
(0,0) (7,8) (10,10) 
\endcode
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& operator ++ () {
        this->_plus_plus();
        return *this;
    }

/**
@brief Plus identity, postfix

Adds identity matrix to a calling complex square band matrix and returns 
a copy of the original matrix. 
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.,
              9., 10., 11., 12.};
scbmatrix m((std::complex<double>*)a, 3, 1, 0);
std::cout << m << std::endl;
std::cout << m++ << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
(1,2) (0,0) (0,0) 
(3,4) (5,6) (0,0) 
(0,0) (7,8) (9,10) 

(1,2) (0,0) (0,0) 
(3,4) (5,6) (0,0) 
(0,0) (7,8) (9,10) 

(2,2) (0,0) (0,0) 
(3,4) (6,6) (0,0) 
(0,0) (7,8) (10,10) 
\endcode
@return Copy of the original calling matrix.
*/
    basic_scbmatrix operator ++ (int) {
        basic_scbmatrix mRes(*this);
        this->_plus_plus();
        return mRes;
    }

/**
@brief Minus identity, prefix

Subtracts identity matrix from calling complex square band 
matrix and returns a reference to the matrix changed.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.,
              9., 10., 11., 12.};
scbmatrix m((std::complex<double>*)a, 3, 1, 0);
std::cout << m << std::endl;
std::cout << --m << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
(1,2) (0,0) (0,0) 
(3,4) (5,6) (0,0) 
(0,0) (7,8) (9,10) 

(0,2) (0,0) (0,0) 
(3,4) (4,6) (0,0) 
(0,0) (7,8) (8,10) 

(0,2) (0,0) (0,0) 
(3,4) (4,6) (0,0) 
(0,0) (7,8) (8,10) 
\endcode
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& operator -- () {
        this->_minus_minus();
        return *this;
    }

/**
@brief Minus identity, postfix

Subtracts identity matrix from calling complex square band matrix and 
returns a copy of the original matrix. 
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8.,
              9., 10., 11., 12.};
scbmatrix m((std::complex<double>*)a, 3, 1, 0);
std::cout << m << std::endl;
std::cout << m-- << std::endl; 
std::cout << m << std::endl;
\endcode
prints
\code
(1,2) (0,0) (0,0) 
(3,4) (5,6) (0,0) 
(0,0) (7,8) (9,10) 

(1,2) (0,0) (0,0) 
(3,4) (5,6) (0,0) 
(0,0) (7,8) (9,10) 

(0,2) (0,0) (0,0) 
(3,4) (4,6) (0,0) 
(0,0) (7,8) (8,10) 
\endcode
@return Copy of the original calling matrix.
*/
    basic_scbmatrix operator -- (int) {
        basic_scbmatrix mRes(*this);
        this->_minus_minus();
        return mRes;
    }

    // TODO dox
    basic_scbmatrix operator * (TR dMult) const {
        basic_scbmatrix mRes(*this);
        mRes._scalr(dMult);
        return mRes;
    }

    basic_scbmatrix operator / (TR dDiv) const {
        basic_scbmatrix mRes(*this);
        mRes._div(dDiv);
        return mRes;
    }

    basic_scbmatrix operator * (TC cMult) const {
        basic_scbmatrix mRes(*this);
        mRes._scalc(cMult);
        return mRes;
    }

    basic_scbmatrix operator / (TC cDiv) const {
        basic_scbmatrix mRes(*this);
        mRes._div(cDiv);
        return mRes;
    }

    basic_scbmatrix& operator *= (TR dMult) {
        this->_scalr(dMult);
        return *this;
    }

    basic_scbmatrix& operator /= (TR dDiv) {
        this->_div(dDiv);
        return *this;
    }

    basic_scbmatrix& operator *= (TC cMult) {
        this->_scalc(cMult);
        return *this;
    }

    basic_scbmatrix& operator /= (TC cDiv) {
        this->_div(cDiv);
        return *this;
    }

    basic_scbmatrix& normalize() {
        this->_normalize();
        return *this;
    }

    // 6.1: transposed (not conjugated) matrix
    basic_scbmatrix operator ! () const {
        basic_scbmatrix mRes(*this);
        return mRes.transpose();
    }

    // Hermitian conjugated matrix
    basic_scbmatrix operator ~ () const {
        basic_scbmatrix mRes(*this);
        return mRes.conj();
    }

// 6.1: transposed (not conjugated) matrix
/**
@brief Matrix transposition

Sets calling complex square band matrix to be equal to complex square band matrix \c m transposed.
Function throws \ref cvmexception in case of not appropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16.};
scbmatrix m((std::complex<double>*)a,4,1,0);
scbmatrix mc(4,0,1);
std::cout << m << std::endl << !m << std::endl ;
mc.transpose(m);
std::cout << mc << std::endl;
mc.transpose();
std::cout << mc;
\endcode
prints
\code
(1,2) (0,0) (0,0) (0,0)
(3,4) (5,6) (0,0) (0,0)
(0,0) (7,8) (9,10) (0,0)
(0,0) (0,0) (11,12) (13,14)

(1,2) (3,4) (0,0) (0,0)
(0,0) (5,6) (7,8) (0,0)
(0,0) (0,0) (9,10) (11,12)
(0,0) (0,0) (0,0) (13,14)

(1,2) (3,4) (0,0) (0,0)
(0,0) (5,6) (7,8) (0,0)
(0,0) (0,0) (9,10) (11,12)
(0,0) (0,0) (0,0) (13,14)

(1,2) (0,0) (0,0) (0,0)
(3,4) (5,6) (0,0) (0,0)
(0,0) (7,8) (9,10) (0,0)
(0,0) (0,0) (11,12) (13,14)
\endcode
@param[in] m \ref scbmatrix to transpose.
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& transpose(const basic_scbmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->lsize(), m.usize());
        _check_ne(CVM_SIZESMISMATCH, this->usize(), m.lsize());
        *this << !m;
        return *this;
    }

/**
@brief Matrix Hermitian conjugation

Sets calling complex square band matrix to be equal to complex square band matrix \c m conjugated.
Function throws \ref cvmexception in case of not appropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
              10., 11., 12., 13., 14., 15., 16.};
scbmatrix m((std::complex<double>*)a,4,1,0);
scbmatrix mc(4,0,1);
std::cout << m << std::endl << ~m << std::endl ;
mc.conj(m);
std::cout << mc << std::endl;
mc.conj();
std::cout << mc;
\endcode
prints
\code
(1,2) (0,0) (0,0) (0,0)
(3,4) (5,6) (0,0) (0,0)
(0,0) (7,8) (9,10) (0,0)
(0,0) (0,0) (11,12) (13,14)

(1,-2) (3,-4) (0,0) (0,0)
(0,0) (5,-6) (7,-8) (0,0)
(0,0) (0,0) (9,-10) (11,-12)
(0,0) (0,0) (0,0) (13,-14)

(1,-2) (3,-4) (0,0) (0,0)
(0,0) (5,-6) (7,-8) (0,0)
(0,0) (0,0) (9,-10) (11,-12)
(0,0) (0,0) (0,0) (13,-14)

(1,2) (0,0) (0,0) (0,0)
(3,4) (5,6) (0,0) (0,0)
(0,0) (7,8) (9,10) (0,0)
(0,0) (0,0) (11,12) (13,14)
\endcode
@param[in] m \ref scbmatrix to conjugate.
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& conj(const basic_scbmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        _check_ne(CVM_SIZESMISMATCH, this->lsize(), m.usize());
        _check_ne(CVM_SIZESMISMATCH, this->usize(), m.lsize());
        *this << ~m;
        return *this;
    }

    // TODO dox
    // 6.1: transposed (not conjugated) matrix
    basic_scbmatrix& transpose() {
        this->_transp();
        return *this;
    }

    basic_scbmatrix& conj() {
        this->_conj();
        return *this;
    }

    CVector operator * (const CVector& v) const {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), v.size());
        CVector vRes(this->msize());
        this->_multiply(vRes, v, false);
        return vRes;
    }

    // special exclusion since matrix product is not commutative
    BaseCMatrix operator * (const BaseCMatrix& m) const {
        _bake_SM();
        return mSM * m;
    }

/**
@brief Matrix-matrix product

Creates an object of type \ref scmatrix as a product of a calling complex square band matrix and square matrix \c m.
Operator throws \ref cvmexception if number of columns of a calling matrix
differs from number of rows of the matrix \c m.
Use \ref mult() to avoid new object creation.
\par Example:
\code
using namespace cvm;
try {
    scbmatrix mb(4,1,0);
    scmatrix m(4);
    mb.set(std::complex<double>(1.,1.));
    m.set(std::complex<double>(1.,1.));
    std::cout << mb * m;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(0,2) (0,2) (0,2) (0,2)
(0,4) (0,4) (0,4) (0,4)
(0,4) (0,4) (0,4) (0,4)
(0,4) (0,4) (0,4) (0,4)
\endcode
@param[in] m \ref scmatrix to compute product with.
@return Result object.
*/
    BaseSCMatrix operator * (const BaseSCMatrix& m) const {
        _bake_SM();
        return mSM * m;
    }

/**
@brief Matrix-matrix product

Creates an object of type \ref scbmatrix as a product of a calling complex square band matrix and complex square band matrix \c m.
Operator throws \ref cvmexception if number of columns of a calling matrix
differs from number of rows of the matrix \c m.
Use \ref mult() to avoid new object creation.
\par Example:
\code
using namespace cvm;
try {
    scbmatrix m1(5,1,0);
    scbmatrix m2(5,1,1);
    m1.set(std::complex<double>(1.,1.));
    m2.set(std::complex<double>(1.,1.));

    std::cout << m1 * m2;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(0,2) (0,2) (0,0) (0,0) (0,0)
(0,4) (0,4) (0,2) (0,0) (0,0)
(0,2) (0,4) (0,4) (0,2) (0,0)
(0,0) (0,2) (0,4) (0,4) (0,2)
(0,0) (0,0) (0,2) (0,4) (0,4)
\endcode
@param[in] m \ref scbmatrix to compute product with.
@return Result object.
*/
    basic_scbmatrix operator * (const basic_scbmatrix& m) const {
        _bake_SM();
        m._bake_SM();
        return basic_scbmatrix(mSM * m.mSM,
                               _cvm_min<tint>(this->msize() - 1, this->lsize() + m.lsize()),
                               _cvm_min<tint>(this->msize() - 1, this->usize() + m.usize()));
    }

    // TODO dox
    // 6.1: reversed vector operator % returns solution of A*X=B equation
    // overridden to mask out operator / (TC)
    CVector operator / (const CVector& v) const {
        return v % (*this);
    }

/**
@brief Low-up (LU) factorization

Computes LU factorization of complex square band matrix \f$A\f$
as 
\f[
A=PLU
\f]
where \f$P\f$ is permutation matrix, \f$L\f$ is lower
triangular matrix with unit diagonal
elements and \f$U\f$ is upper triangular matrix.
Function stores result as the matrix \f$L\f$ without
main diagonal combined with \f$U\f$. Function
returns pivot indices as an array of integers
(it should support at least \ref msize() elements)
pointed to by \c nPivots so \f$i\f$-th row
was interchanged with \c nPivots[\f$i\f$]-th row.
This version sets calling matrix to be equal to matrix
\c m's LU factorization.
This version also changes number of
super-diagonals to be equal to \f$k_l+k_u\f$ in order to keep the result of factorization.
Function throws \ref cvmexception in case of inappropriate
sizes of the operands or when the matrix to be factorized is close to
singular. It is recommended to use \ref iarray for pivot values.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
try {
    double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9.,
                  10., 11., 12.};
    scbmatrix ma((std::complex<double>*)a,3,1,0);
    scbmatrix mLU(3,1,0);
    cmatrix  mb1(3,2); cvector vb1(3);
    cmatrix  mb2(3,2); cvector vb2(3);
    cmatrix  mx1(3,2); cvector vx1(3);
    cmatrix  mx2(3,2); cvector vx2(3);
    iarray   nPivots(3);
    double   dErr = 0.;
    mb1.randomize_real(-1.,3.); mb1.randomize_imag(1.,5.);
    mb2.randomize_real(-2.,5.); mb2.randomize_imag(-3.,0.);
    vb1.randomize_real(-2.,4.); vb1.randomize_imag(-4.,1.);
    vb2.randomize_real(-3.,1.); vb2.randomize_imag(4.,5.);

    mLU.low_up(ma, nPivots);
    mx1 = ma.solve_lu(mLU, nPivots, mb1, dErr);
    std::cout << mx1 << dErr << std::endl << std::endl;
    mx2 = ma.solve_lu(mLU, nPivots, mb2);
    std::cout << mx2 << std::endl;;
    std::cout << ma * mx1 - mb1 << std::endl << ma * mx2 - mb2;

    vx1 = ma.solve_lu(mLU, nPivots, vb1, dErr);
    std::cout << vx1 << dErr << std::endl;
    vx2 = ma.solve_lu(mLU, nPivots, vb2);
    std::cout << vx2 << std::endl;;
    std::cout << ma * vx1 - vb1 << std::endl << ma * vx2 - vb2;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(1.20e+000,4.02e-002) (1.82e+000,1.23e+000)
(-6.55e-001,1.37e-001) (-6.41e-001,-8.72e-001)
(7.75e-001,4.70e-002) (5.35e-001,8.11e-001)
1.45e-015

(-4.52e-001,-2.68e-002) (-1.09e+000,2.01e-001)
(6.08e-001,-4.76e-001) (5.48e-001,-1.95e-001)
(-3.46e-001,1.57e-001) (-3.38e-001,-7.54e-002)

(0.00e+000,4.44e-016) (-2.22e-016,8.88e-016)
(-2.22e-016,2.22e-016) (0.00e+000,0.00e+000)
(-1.11e-016,0.00e+000) (-3.33e-016,-6.66e-016)

(0.00e+000,0.00e+000) (2.22e-016,2.22e-016)
(0.00e+000,0.00e+000) (4.44e-016,-2.22e-016)
(8.88e-016,5.55e-016) (0.00e+000,0.00e+000)
(-1.28e+000,-5.12e-001) (8.22e-001,1.59e-001) (-6.45e-001,-3.74e-001)
1.31e-015
(1.26e+000,1.50e+000) (-5.13e-001,-4.66e-001) (5.97e-001,7.01e-001)

(0.00e+000,8.88e-016) (-4.44e-016,4.44e-016) (-8.88e-016,0.00e+000)

(2.22e-016,-8.88e-016) (4.44e-016,-8.88e-016) (-2.22e-016,8.88e-016)
\endcode
@param[in] m \ref scbmatrix to compute LU factorization for.
@param[out] nPivots %Array of pivot indices.
@return Reference to changed calling matrix.
*/
    basic_scbmatrix& low_up(const basic_scbmatrix& m, tint* nPivots) {
        *this = m;
        this->_low_up(nPivots);
        return *this;
    }

    // TODO dox
    basic_scbmatrix low_up(tint* nPivots) const {
        basic_scbmatrix mRes(*this);
        mRes._low_up(nPivots);
        return mRes;
    }

    basic_scbmatrix& identity() {
        this->_vanish();
        this->_plus_plus();
        return *this;
    }

    basic_scbmatrix& vanish() {
        this->_vanish();
        return *this;
    }

    basic_scbmatrix& randomize_real(TR dFrom, TR dTo) {
        this->_b_randomize(true, dFrom, dTo);
        return *this;
    }

    basic_scbmatrix& randomize_imag(TR dFrom, TR dTo) {
        this->_b_randomize(false, dFrom, dTo);
        return *this;
    }

    // Euclid norm - band matrices require special care because of tails
    TR norm() const override {
        TR dNorm = TR(0.), d;
        tint i;
        for (i = 0; i <= this->lsize(); ++i) {
            // non-const version shares mamory, it's faster
            d = const_cast<basic_scbmatrix*>(this)->diag(-i).norm();
            dNorm += d * d;
        }
        for (i = 1; i <= this->usize(); ++i) {
            // non-const version shares mamory, it's faster
            d = const_cast<basic_scbmatrix*>(this)->diag(i).norm();
            dNorm += d * d;
        }
        return std::sqrt(dNorm);
    }

    TR norm1() const override {
        return this->_bnorm1();
    }

    TR norminf() const override {
        return this->_bnorminf();
    }

    // TODO dox
    // ATTENTION!!! This is not a good idea to use the following function. It's provided for
    // overriding of basic_rmatrix<TR>::mult only
    basic_scbmatrix& mult(const BaseCMatrix& m1, const BaseCMatrix& m2) {
        this->_mult(m1, m2);
        return *this;
    }

//! @cond INTERNAL
    // redefinition of basic_array's function
    TC* _pd() override {
#ifdef CVM_DEBUG
        // it's abnormal to call this function, this is pointer to copy, not to an object. only const version is allowed
        assert(false);
#endif
        _bake_SM();
        return mSM._pd();
    }

    // redefinition of basic_array's function
    const TC* _pd() const override {
        _bake_SM();
        return mSM._pd();
    }

    // singular values in decreasing order
    void _svd(basic_rvector<TR>& vRes, BaseSCMatrix* pmU,
              BaseSCMatrix* pmVH) const override {
        if (pmU != nullptr && pmVH != nullptr) {
            _check_ne(CVM_SIZESMISMATCH, this->msize(), pmU->msize());
            _check_ne(CVM_SIZESMISMATCH, this->nsize(), pmVH->msize());
        }
        __svd<TR,basic_scbmatrix,
            BaseSCMatrix>(vRes, vRes.size(), vRes.incr(), *this, pmU, pmVH);
    }

    void _pinv(BaseCMatrix& mX, TR threshold) const override {
        __pinv<TR,basic_scbmatrix, BaseCMatrix>(mX, *this, threshold);
    }

    void _eig(CVector& vEig, basic_scmatrix<TR,TC>* mEigVect,
              bool bRightVect) const override {
        _bake_SM();
        mSM._eig(vEig, mEigVect, bRightVect);
    }

    void _solve(const CVector& vB, CVector& vX,
                TR& dErr, const TC* pLU, const tint* pPivots,
                int transp_mode) const override {
        vX = vB;
        CVector vB1;
        CVector vX1;
        if (vB.incr() > 1) vB1 << vB;  // to make sure incr = 1
        if (vX.incr() > 1) vX1 << vX;
        __solve<TR,TC,
            basic_scbmatrix>(*this, 1,
                             vB.incr() > 1 ? vB1 : vB, vB.size(),
                             vX.incr() > 1 ? vX1 : vX, vX.size(),
                             dErr, pLU, pPivots, transp_mode);
        if (vX.incr() > 1) vX = vX1;
    }

    void _solve(const BaseCMatrix& mB, BaseCMatrix& mX,
                TR& dErr, const TC* pLU, const tint* pPivots,
                int transp_mode) const override {
        mX = mB;
        __solve<TR,TC,
            basic_scbmatrix>(*this, mB.nsize(), mB, mB.ld(),
                             mX, mX.ld(), dErr, pLU, pPivots, transp_mode);
    }

    // ?gbmv routines perform a matrix-vector operation defined as
    // vRes = alpha*m*v + beta * vRes or vRes = alpha*v'*m + beta * vRes
    // not virtual since __gbmv calls all virtual methods inside
    void _gbmv(bool bLeft, TC dAlpha, const CVector& v, TC dBeta, CVector& vRes) const {
        CVector vTmp;
        basic_scbmatrix mTmp;
        const TC* pDv = v;
        if (vRes.get() == pDv) vTmp << v;
        if (vRes.get() == this->get()) mTmp << *this;
        __gbmv<TC,basic_scbmatrix,
            CVector>(bLeft,
                     vRes.get() == this->get() ? mTmp : *this, dAlpha,
                     vRes.get() == pDv ? vTmp : v, dBeta, vRes);
    }

    void _check_submatrix() const override {
        throw cvmexception(CVM_SUBMATRIXNOTAVAILABLE, "scbmatrix");
    }

    const TC* _pb() const override {
        return this->get();
    }

    TC* _pb() override {
        return this->get();
    }

protected:
    void _bake_SM() const {
        mSM.resize(this->msize());
        mSM.vanish();
        _copy_b_matrix<TR,TC, BaseSCMatrix, basic_scbmatrix>(mSM, *const_cast<basic_scbmatrix*>(this), false);
    }

    tint _size() const override {
        return this->size();
    }

    tint _msize() const override {
        return this->msize();
    }

    tint _nsize() const override {
        return this->nsize();
    }

    tint _ld() const override {
        return this->ld();
    }

    bool _is_empty_b() const override {
        return this->_is_empty();
    }

    void _set_p(TC* pf) override {
#ifdef CVM_USE_POOL_MANAGER
        this->mpd = pf;
#else
        this->mpf = pf;
#endif
    }

    void _set(TC* pf, tint nSize, tint nM, tint nN, tint nIncr, tint nLD) override {
#ifdef CVM_USE_POOL_MANAGER
        this->mpd = pf;
#else
        this->mpf = pf;
#endif
        this->msz = nSize;
        this->mm = nM;
        this->mn = nN;
        this->mincr = nIncr;
        this->mld = nLD;
    }

    const TC* _pp(const BaseMatrix& m) const override {  // for _msum _mdiff etc.
        return m.get();
    }

    tint _ldm() const override {
        return this->mm;
    }

    const tint* _pldm() const override {
        return &this->mm;
    }

    // 0-based, returns an l-value sharing memory
    CVector _row(tint m) override {
        CVector vRet(this->msize());
        this->_get_row(m, vRet, vRet.incr());
        return vRet;
    }

    // 0-based, returns not an l-value (copy)
    // looks like cut-n-paste, but it's not
    CVector _row(tint m) const override {
        CVector vRet(this->msize());
        this->_get_row(m, vRet, vRet.incr());
        return vRet;
    }

    // 0-based, returns an l-value sharing memory
    CVector _col(tint n) override {
        CVector vRet(this->msize());
        this->_get_col(n, vRet, vRet.incr());
        return vRet;
    }

    // 0-based, returns not an l-value (copy)
    // looks like cut-n-paste, but it's not
    CVector _col(tint n) const override {
        CVector vRet(this->msize());
        this->_get_col(n, vRet, vRet.incr());
        return vRet;
    }

    CVector _diag(tint nDiag) override {
        const tint nD = std::abs(nDiag);
        if (nDiag < 0) {
            _check_gt(CVM_INDEX_GT, nD, this->lsize());
        }
        else {
            _check_gt(CVM_INDEX_GT, nDiag, this->usize());
        }
        const tint nLU = this->lsize() + this->usize();
        return CVector(this->get() + this->usize() + (nDiag < 0 ? nD : nD * nLU), this->msize() - nD, nLU + 1);
    }

    CVector _diag(tint nDiag) const override {
        const tint nD = std::abs(nDiag);
        if (nDiag < 0) {
            _check_gt(CVM_INDEX_GT, nD, this->lsize());
        }
        else {
            _check_gt(CVM_INDEX_GT, nDiag, this->usize());
        }
        const tint nLU = this->lsize() + this->usize();
        return CVector(this->get() + this->usize() + (nDiag < 0 ? nD : nD * nLU), this->msize() - nD, nLU + 1);
    }

    void _resize2(tint nNewM, tint) override {
#ifdef CVM_USE_POOL_MANAGER
        this->_bresize(nNewM);
#else
        this->_bresize(this->mp, nNewM);
#endif
    }

    bool _continuous() const override {
        return this->_bcontinuous();
    }

    void _massign(const BaseMatrix& m) override {
        this->_mbassign(m);
    }

    void _set(TC d) override {
        this->_bset(d);
    }

    void _vanish() override {
        this->_bvanish();
    }

    // zero based
    type_proxy<TC,TR> _ij_proxy_val(tint i, tint j) override {
        return this->_b_ij_proxy_val(i, j);
    }

    TC _ij_val(tint i, tint j) const override {
        return this->_b_ij_val(i, j);
    }

    void _transp() override {
#ifdef CVM_USE_POOL_MANAGER
        this->_btransp();
#else
        this->_btransp(this->mp);
#endif
    }

    void _plus_plus() override {
        this->_b_plus_plus();
    }

    void _minus_minus() override {
        this->_b_minus_minus();
    }

    tint _indofmax() const override {
        this->_check_ld();
        _bake_SM();
        return mSM.indofmax();
    }

    tint _indofmin() const override {
        this->_check_ld();
        _bake_SM();
        return mSM.indofmin();
    }

    CVector _low_up_diag(basic_array<tint,tint>& naPivots) const override {
        // let temp matrix be const to get a copy of its main diagonal
        const basic_scbmatrix lu = this->low_up(naPivots);
        return lu.diag(0);
    }

    void _scalr(TR d) override {
        // zero tails are
        __scal<TR,TC>(this->get(), this->size(), this->incr(), d);
    }

    void _scalc(TC d) override {
        // zero tails are
        __scal<TC,TC>(this->get(), this->size(), this->incr(), d);
    }

    void _mult(const BaseCMatrix& m1, const BaseCMatrix& m2) override {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m2.nsize());
        _check_ne(CVM_SIZESMISMATCH, m1.nsize(), m2.msize());
        BaseSCMatrix mR(this->msize());
        mR.mult(m1, m2);
#ifdef CVM_USE_POOL_MANAGER
        this->_resize_lu(this->msize() - 1, this->msize() - 1);
#else
        this->_resize_lu(this->mp, this->msize() - 1, this->msize() - 1);
#endif
        _copy_b_matrix<TR,TC, BaseSCMatrix, basic_scbmatrix>(const_cast<BaseSCMatrix&>(mR), *this, true);
    }

    void _multiply(CVector& vRes, const CVector& v, bool bLeft) const override {
        const TC zero(0., 0.);
        const TC one(1., 0.);
        this->_gbmv(bLeft, one, v, zero, vRes);
    }

    void _low_up(tint* nPivots) override {
        __low_up<basic_scbmatrix>(*this, nPivots);
    }

    tint _ld_for_replace() const override {
        return this->mm;
    }

    tint _size_for_replace() const override {
        return this->mm * this->mn;
    }

    void _swap_rows(tint, tint) override { throw cvmexception(CVM_METHODNOTAVAILABLE, "swap_rows", "scbmatrix");}
    void _swap_cols(tint, tint) override { throw cvmexception(CVM_METHODNOTAVAILABLE, "swap_cols", "scbmatrix");}
    void _check_geru()          override { throw cvmexception(CVM_METHODNOTAVAILABLE, "geru", "scbmatrix");}
    void _check_gerc()          override { throw cvmexception(CVM_METHODNOTAVAILABLE, "gerc", "scbmatrix");}
    void _check_rank1update_u() override { throw cvmexception(CVM_METHODNOTAVAILABLE, "rank1update_u", "scbmatrix");}
    void _check_rank1update_c() override { throw cvmexception(CVM_METHODNOTAVAILABLE, "rank1update_c", "scbmatrix");}
    void _check_gemm()          override { throw cvmexception(CVM_METHODNOTAVAILABLE, "gemm", "scbmatrix");}
    void _check_hemm()          override { throw cvmexception(CVM_METHODNOTAVAILABLE, "hemm", "scbmatrix");}
    void _check_cholesky()      override { throw cvmexception(CVM_METHODNOTAVAILABLE, "cholesky", "scbmatrix");}
    void _check_bunch_kaufman() override { throw cvmexception(CVM_METHODNOTAVAILABLE, "bunch_kaufman", "scbmatrix");}
//! @endcond
};


/**
@brief End-user class encapsulating symmetric matrix of real numbers

\c TR type stands for \ref treal. Please use predefined \ref srsmatrix class in your applications.
@see Matrix
*/
template<typename TR>
class basic_srsmatrix : public basic_srmatrix<TR>
{
    using RVector = basic_rvector<TR>;  //!< \ref rvector
    using BaseArray = basic_array<TR,TR>;  //!< Base basic_array class
    using BaseMatrix = Matrix<TR,TR>;  //!< Base Martrix class
    using BaseSqMatrix = SqMatrix<TR,TR>;  //!< Base SqMatrix class
    using BaseRMatrix = basic_rmatrix<TR>;  //!< \ref rmatrix class
    using BaseSRMatrix = basic_srmatrix<TR>;  //!< \ref crmatrix class

public:
/**
@brief Default constructor

Creates empty symmetric matrix. No memory gets allocated.
\par Example:
\code
using namespace cvm;
srsmatrix m;
std::cout << m.msize() << " " << m.nsize() << " " << m.size()
          << std::endl << std::endl;
m.resize(3);
m.set(1.);
std::cout << m;
\endcode
prints
\code
0 0 0

1 1 1
1 1 1
1 1 1
\endcode
*/
    basic_srsmatrix() = default;

/**
@brief Constructor

Creates \f$n\times n\f$ \ref srsmatrix object where \f$n\f$ is passed in
\c nDim parameter. Constructor sets all elements to zero.
It throws \ref cvmexception in case of non-positive size passed or memory allocation failure.
Example:
\code
using namespace cvm;
srsmatrix m(4);
std::cout << m.msize() << " " << m.nsize() << " " << m.size()
          << std::endl << std::endl;
m.set(1.);
std::cout << m;
\endcode
prints
\code
4 4 16

1 1 1 1
1 1 1 1
1 1 1 1
1 1 1 1
\endcode
@param[in] nDim Number of rows and columns.
*/
    explicit basic_srsmatrix(tint nDim)
      : BaseSRMatrix(nDim)
    {}

/**
@brief Constructor

Creates \f$n\times n\f$ \ref srsmatrix object where \f$n\f$ is passed in \c nDim parameter.
It throws \ref cvmexception in case of non-positive size passed or if the matrix created doesn't appear to be symmetric.
Symmetry tolerance is set by parameter \c tol.
Unlike others, this constructor <b>does not allocate memory</b>.
It just shares memory with an array pointed to by \c pd (for matrices \c nIncr=1 is always satisfied).
If subsequent application flow would change the array passed so
it becomes not symmetric matrix anymore then results are not predictable.
\par Example:
\code
using namespace cvm;
double a[] = {1., 1., 1., 1., 1., 1., 1., 1., 1.};
srsmatrix m(a, 3);
m.set(2,1,5.);
std::cout << m << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << " "
          << a[3] << " " << a[4] << " " << a[5] << " " << std::endl;
\endcode
prints
\code
1 5 1
5 1 1
1 1 1

1 5 1 5 1 1
\endcode
@see http://cvmlib.com/faq.htm
@see basic_rmatrix::basic_rmatrix(TR*,tint,tint)
@param[in] pd Pointer to an array to share memory with.
@param[in] nDim Number of rows and columns.
@param[in] tol Symmetry tolerance.
*/
    basic_srsmatrix(TR* pd, tint nDim, TR tol = basic_cvmMachSp<TR>())
      : BaseSRMatrix(pd, nDim, nDim, nDim * nDim) {
        this->_check_symmetric(tol);
    }

/**
@brief Constructor

Creates \f$n\times n\f$ \ref srsmatrix object where \f$n\f$ is passed in \c nDim parameter.
Constructor throws \ref cvmexception in case of non-positive sizes passed or if the matrix created doesn't appear to be symmetric.
Symmetry tolerance is set by parameter \c tol.
This is const version,
it allocates memory and copies every element (deep copy) from external array pointed to by \c pd parameter.
It copies \c nDim*nDim elements total.
Example:
\code
using namespace cvm;
const double a[] = {1., 1., 1., 1., 1., 1., 1., 1., 1.};
srmatrix m(a, 3);

m(1,1) = 5.;
std::cout << m << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << std::endl;
\endcode
prints
\code
5 1 1
1 1 1
1 1 1

1 1 1
\endcode
@see http://cvmlib.com/faq.htm
@see basic_rmatrix::basic_rmatrix(const TR*,tint,tint)
@param[in] pd Const pointer to external array.
@param[in] nDim Number of rows and columns.
@param[in] tol Symmetry tolerance.
*/
    basic_srsmatrix(const TR* pd, tint nDim, TR tol = basic_cvmMachSp<TR>())
      : BaseSRMatrix(pd, nDim, nDim, nDim * nDim) {
        this->_check_symmetric(tol);
    }

/**
@brief Copy constructor

Creates \ref srsmatrix object as a copy of symmetric matrix \c m.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
srsmatrix m(a, 3);
srmatrix mc(m);
m.set(2,3,7.77);
std::cout << m << std::endl << mc;
\endcode
prints
\code
1 2 3
2 5 7.77
3 7.77 9

1 2 3
2 5 6
3 6 9
\endcode
@param[in] m \ref srsmatrix to copy from.
*/
    basic_srsmatrix(const basic_srsmatrix& m)
      : BaseSRMatrix(m.msize(), m.msize(), false) {
        this->_massign(m);
    }

/**
@brief Move constructor

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to newly created object.
It's usually executed implicitly in cases like this:
\code
rvector a(b + c);
\endcode
or this
\code
rvector a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to newly created object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_srsmatrix(basic_srsmatrix&& m) noexcept
       : BaseSRMatrix(std::move(m))
    {}

/**
@brief Constructor

Creates \ref srsmatrix object as a copy of a matrix \c m.
It's assumed that \f$m\times n\f$ matrix \c m must have equal
sizes, i.e. \f$m = n\f$ is satisfied, and must be symmetric.
Symmetry tolerance is set by parameter \c tol.
Constructor throws \ref cvmexception if this is not true or in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
rmatrix m(a, 3, 3);
srsmatrix ms(m);
std::cout << ms;
\endcode
prints
\code
1 2 3
2 5 6
3 6 9
\endcode
@param[in] m \ref rmatrix to copy from.
@param[in] tol Symmetry tolerance.
*/
    explicit basic_srsmatrix(const BaseRMatrix& m, TR tol = basic_cvmMachSp<TR>())
      : BaseSRMatrix(m.msize(), m.nsize(), false) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), this->nsize());
        this->_massign(m);
        this->_check_symmetric(tol);
    }

/**
@brief Constructor

Creates \ref srsmatrix object of size \c v.size() by \c v.size()
and assigns vector \c v to its main diagonal.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5.};
const rvector v(a, 5);
srsmatrix m(v);
std::cout << m;
\endcode
prints
\code
1 0 0 0 0
0 2 0 0 0
0 0 3 0 0
0 0 0 4 0
0 0 0 0 5
\endcode
@param[in] v \ref rvector to copy main diagonal from.
*/
    explicit basic_srsmatrix(const RVector& v)
      : BaseSRMatrix(v)
    {}

/**
@brief Submatrix constructor

Creates \ref srsmatrix object as submatrix of symmetric matrix \c m.
It means that the object created shares memory with some part
of \c m. This part is defined by its upper left corner and its dimension (parameter \c nDim).
\par Example:
\code
using namespace cvm;
srsmatrix m(5);
srsmatrix subm(m, 2, 2);
subm.set(1.);
std::cout << m;
\endcode
prints
\code
0 0 0 0 0
0 1 1 0 0
0 1 1 0 0
0 0 0 0 0
\endcode
@param[in] m Parent \ref srsmatrix to attach to.
@param[in] nRowCol Row and column to start from.
@param[in] nDim Dimension of square submatrix.
*/
    basic_srsmatrix(basic_srsmatrix& m, tint nRowCol, tint nDim)
      : BaseSRMatrix(m._sub_pointer(nRowCol, nRowCol, nDim, nDim), nDim, m.ld(), nDim * nDim)
    {}

    //! @copydoc basic_rmatrix::operator()(tint,tint)const
    // Masking non-const overload inherited from basic_rmatrix
    TR operator () (tint nRow, tint nCol) const {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, nRow, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, nCol, tint(), this->nsize());
        return this->_ij_val(nRow, nCol);
    }

    //! @copydoc basic_rmatrix::operator()(tint)const
    // Masking non-const overload inherited from basic_rmatrix
    // returns column which is NOT l-value
    RVector operator () (tint nCol) const {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nCol, tint(), this->nsize());
        return this->_col(nCol);
    }

    //! @copydoc basic_rmatrix::operator[](tint)const
    // Masking non-const overload inherited from basic_rmatrix
    // returns row which is NOT l-value
    RVector operator [] (tint nRow) const {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nRow, tint(), this->msize());
        return this->_row(nRow);
    }

    //! @copydoc basic_rmatrix::diag(tint)const
    // Masking non-const overload inherited from basic_rmatrix
    // returns diagonal which is NOT l-value (since it could break symmetricity)
    // 0 - main, negative - low, positive - up
    RVector diag(tint nDiag) const {
        return this->_diag(nDiag);
    }

/**
@brief Assignment operator

Sets every element of a calling \ref srsmatrix to be equal to
appropriate element of symmetric matrix \c m and returns a reference to
the matrix changed.
Operator throws \ref cvmexception in case of different matrix dimensions.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
const srsmatrix m1(a, 3);
srsmatrix m2(3);
m2 = m1;
std::cout << m2;
\endcode
prints
\code
1 2 3
2 5 6
3 6 9
\endcode
@param[in] m \ref srsmatrix to assign from.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& operator = (const basic_srsmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        this->_massign(m);
        return *this;
    }

/**
@brief Move assignment operator

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to a calling object.
It's usually executed implicitly in cases like this:
\code
a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to a calling object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_srsmatrix& operator = (basic_srsmatrix&& m)  noexcept {
        // size check is in BaseSRMatrix
        BaseSRMatrix::operator = (std::move(m));
        return *this;
    }

/**
@brief Vector (as array) assignment

Sets every element of a calling symmetric matrix to be equal to appropriate element of \ref rvector \c v as an array.
Assignment is performed according to a matrix storage (by columns). It's assumed that vector passed is long
enough to fill calling matrix. Function throws \ref cvmexception otherwise.
Function also throws \ref cvmexception if the matrix changed doesn't appear to be symmetric.
Symmetry tolerance is set by parameter \c tol.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
rvector v(a,9);
srsmatrix m(3);
m.assign(v);
std::cout << m;
\endcode
prints
\code
1 2 3
2 5 6
3 6 9
\endcode
@param[in] v \ref rvector to assign.
@param[in] tol Symmetry tolerance.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& assign(const RVector& v, TR tol = basic_cvmMachSp<TR>()) {
        _check_gt(CVM_SIZESMISMATCH_GT, this->size(), v.size());
        this->_assign(v, v.incr());
        this->_check_symmetric(tol);
        return *this;
    }

/**
@brief External array assignment

Sets every element of a calling symmetric matrix to be equal to
appropriate element of an array pointed to by parameter \c pd
and returns a reference to the matrix changed.
Assignment is performed according to a matrix storage (by columns).
It's assumed that array passed is long
enough to fill calling matrix.
Function throws \ref cvmexception if the matrix changed doesn't appear to be symmetric.
Symmetry tolerance is set by parameter \c tol.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
srsmatrix m(3);
m.assign(a);
std::cout << m;
\endcode
prints
\code
1 2 3
2 5 6
3 6 9
\endcode
@param[in] pd Const pointer to external array.
@param[in] tol Symmetry tolerance.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& assign(const TR* pd, TR tol = basic_cvmMachSp<TR>()) {
        this->_assign(pd, 1);
        this->_check_symmetric(tol);
        return *this;
    }

/**
@brief Assignment to submatrix

Sets main submatrix of a calling symmetric matrix beginning with row and column
\c nRowCol to symmetric matrix \c m and
returns a reference to the matrix changed. Function throws
\ref cvmexception if \c nRowCol is not positive or matrix \c m doesn't fit.
\par Example:
\code
using namespace cvm;
srsmatrix m1(5);
srsmatrix m2(2);
m1.set(1.);
m2.set(2.);
m1.assign(2,m2);
std::cout << m1;
\endcode
prints
\code
1 1 1 1 1
1 2 2 1 1
1 2 2 1 1
1 1 1 1 1
1 1 1 1 1
\endcode
@param[in] nRowCol Row and column index.
@param[in] m Reference to symmetric matrix to assign.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& assign(tint nRowCol, const basic_srsmatrix& m) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nRowCol, tint(), this->msize());
        _check_gt(CVM_SIZESMISMATCH_GT, m.msize() + nRowCol, this->msize());
        this->_assign_shifted(this->_sub_pointer_nocheck(nRowCol, nRowCol),
                              m._pd(), m.msize(), m.nsize(), m.ld());
        return *this;
    }

    // TODO dox
    basic_srsmatrix& set(TR d) {
        this->_set(d);
        return *this;
    }

/**
@brief Sets both elements to keep matrix symmetric

Sets main submatrix of a calling symmetric matrix beginning with row and column
\c nRowCol to symmetric matrix \c m and
returns a reference to the matrix changed. Function throws
\ref cvmexception if \c nRowCol is out of boundaries.
\par Example:
\code
using namespace cvm;
srsmatrix m(3);
m.set(3.);
m.set(1,3,7.);
std::cout << m;
\endcode
prints
\code
3 3 7
3 3 3
7 3 3
\endcode
@param[in] nRow Row (and column) index to set.
@param[in] nCol Column (and row) index to set.
@param[in] d Element value to set to.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& set(tint nRow, tint nCol, TR d) {
        this->_set_at(nRow, nCol, d);
        return *this;
    }

/**
@brief Sets diagonal(s)

Assigns vector \c vDiag to \f$i\f$-th diagonal of a calling matrix (\f$i\f$ is passed in \c nDiag parameter),
where \f$i=0\f$ for main diagonal, \f$i<0\f$ for lower diagonals and \f$i>0\f$ for upper ones.
If \f$i\not=0\f$, then function assigns the vector to both \f$i\f$-th and \f$-i\f$-th diagonals
(thus calling matrix remains symmetric).
Function returns a reference to the matrix changed.
Function throws \ref cvmexception if parameter \c nDiag is out of boundaries or if
vector \c vDiag passed has size not equal to <c>msize()-abs(nDiag)</c>.
\par Example:
\code
using namespace cvm;
srsmatrix m(3);
rvector v(2);
m.set(3.);
v.set(1.);
m.set_diag(1,v);
std::cout << m;
\endcode
prints
\code
3 1 3
1 3 1
3 1 3
\endcode
@param[in] nDiag Diagonal index to set.
@param[in] vDiag \ref rvector to set diagonal(s) to.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& set_diag(tint nDiag, const RVector& vDiag) {
        this->_diag(nDiag) = vDiag;
        if (nDiag != 0) {
            this->_diag(-nDiag) = vDiag;
        }
        return *this;
    }

    // TODO dox
    basic_srsmatrix& resize(tint nNewDim) {
        this->_resize2(nNewDim, nNewDim);
        return *this;
    }

/**
@brief Matrix comparison

Operator compares calling symmetric matrix with symmetric matrix \c m
and returns \c true if they have same dimensions
and their appropriate elements differ by not more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 2., 3.};
srsmatrix m1(a, 2);
srsmatrix m2(2);
m2.set(1,1,1.);
m2.set(1,2,2.);
m2.set(2,2,3.);
std::cout << (m1 == m2) << std::endl;
\endcode
prints
\code
1
\endcode
@see operator !=()
@param[in] m \ref srsmatrix to compare to.
@return bool Result of comparison.
*/
    bool operator == (const basic_srsmatrix& m) const {
        return this->msize() == m.msize() && this->nsize() == m.nsize() && this->_mequals(m);
    }

/**
@brief Matrix comparison

Operator compares calling symmetric matrix with symmetric matrix \c m
and returns \c true if they have different sizes
or at least one of their appropriate elements differs by more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 2., 3.};
srsmatrix m1(a, 2);
srsmatrix m2(2);
m2.set(1,1,1.0001);
m2.set(1,2,2.);
m2.set(2,2,3.);
std::cout << (m1 != m2) << std::endl;
\endcode
prints
\code
1
\endcode
@see operator ==()
@param[in] m \ref srsmatrix to compare to.
@return bool Result of comparison.
*/
    bool operator != (const basic_srsmatrix& m) const {
        return !(this->operator == (m));
    }

/**
@brief Matrix replacement

Destroys calling symmetric matrix, creates a new one as a copy of \c m
and returns a reference to the matrix changed. Operator throws \ref cvmexception
in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
srsmatrix m(a, 3);
srsmatrix mc(1);
std::cout << m << std::endl << mc << std::endl;
mc << m;
std::cout << mc;
\endcode
prints
\code
1 2 3
2 5 6
3 6 9

0

1 2 3
2 5 6
3 6 9
\endcode
@see operator =()
@param[in] m \ref srsmatrix to replace by.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& operator << (const basic_srsmatrix& m) {
        this->_replace(m);
        this->_massign(m);
        return *this;
    }

/**
@brief Addition operator

Creates an object of type \ref srsmatrix as a sum of
a calling symmetric matrix and symmetric matrix \c m.
Operator throws \ref cvmexception
in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
srsmatrix m1(a, 3);
srsmatrix m2(3);
m2.set(1.);
std::cout << m1 + m2 << std::endl << m1 + m1;
\endcode
prints
\code
2 3 4
3 6 7
4 7 10

2 4 6
4 10 12
6 12 18
\endcode
@see sum()
@param[in] m \ref srsmatrix to add to a calling one.
@return Sum of matrices.
*/
    basic_srsmatrix operator + (const basic_srsmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        basic_srsmatrix mSum(*this);
        mSum._mincr(m);
        return mSum;
    }

/**
@brief Subtraction operator

Creates an object of type \ref srsmatrix as a difference of
a calling symmetric matrix and symmetric matrix \c m.
It throws \ref cvmexception in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
srsmatrix m1(a, 3);
srsmatrix m2(3);
m2.set(1.);
std::cout << m1 - m2 << std::endl << m1 - m1;
\endcode
prints
\code
0 1 2
1 4 5
2 5 8

0 0 0
0 0 0
0 0 0
\endcode
@see diff()
@param[in] m \ref srsmatrix to subtract from calling one.
@return Difference of matrices.
*/
    basic_srsmatrix operator - (const basic_srsmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        basic_srsmatrix mDiff(*this);
        mDiff._mdecr(m);
        return mDiff;
    }

/**
@brief Sum of matrices

Assigns sum of symmetric matrices \c m1 and \c m2 to a calling symmetric matrix
and returns a reference to the matrices changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
const srsmatrix m1(a, 3);
srsmatrix m2(3);
srsmatrix m(3);
m2.set(1.);
std::cout << m.sum(m1, m2) << std::endl;
std::cout << m.sum(m, m2);
\endcode
prints
\code
2 3 4
3 6 7
4 7 10

3 4 5
4 7 8
5 8 11
\endcode
@see operator +()
@param[in] m1 First \ref srsmatrix summand.
@param[in] m2 Second \ref srsmatrix summand.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& sum(const basic_srsmatrix& m1, const basic_srsmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
        this->_msum(m1, m2);
        return *this;
    }

/**
@brief Difference of matrices

Assigns difference of symmetric matrices \c m1 and \c m2 to a calling symmetric matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
const srsmatrix m1(a, 3);
srsmatrix m2(3);
srsmatrix m(3);
m2.set(1.);
std::cout << m.diff(m1, m2) << std::endl;
std::cout << m.diff(m, m2);
\endcode
prints
\code
0 1 2
1 4 5
2 5 8

-1 0 1
0 3 4
1 4 7
\endcode
@see operator -()
@param[in] m1 First \ref srsmatrix subtrahend.
@param[in] m2 Second \ref srsmatrix subtrahend.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& diff(const basic_srsmatrix& m1, const basic_srsmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
        this->_mdiff(m1, m2);
        return *this;
    }

/**
@brief Increment operator

Adds \ref srsmatrix \c m to a calling symmetric matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
srsmatrix m1(3);
srsmatrix m2(3);
m1.set(1.);
m2.set(2.);

m1 += m2;
std::cout << m1 << std::endl;

// well, you can do this too, but temporary object would be created
m2 += m2;
std::cout << m2;
\endcode
prints
\code
3 3 3
3 3 3
3 3 3

4 4 4
4 4 4
4 4 4
\endcode
@see operator +()
@see sum()
@param[in] m \ref srsmatrix to increment by.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& operator += (const basic_srsmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        this->_mincr(m);
        return *this;
    }

/**
@brief Decrement operator

Subtracts \ref srsmatrix \c m from calling symmetric matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
srsmatrix m1(3);
srsmatrix m2(3);
m1.set(1.);
m2.set(2.);

m1 -= m2;
std::cout << m1 << std::endl;

// well, you can do this too, but temporary object would be created
m2 -= m2;
std::cout << m2;
\endcode
prints
\code
-1 -1 -1
-1 -1 -1
-1 -1 -1

0 0 0
0 0 0
0 0 0
\endcode
@see operator -()
@see diff()
@param[in] m \ref srsmatrix to decrement by.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& operator -= (const basic_srsmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        this->_mdecr(m);
        return *this;
    }

/**
@brief Unary minus operator

Creates an object of type \ref srsmatrix as
a calling symmetric matrix multiplied by \c -1.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
srsmatrix m(a, 3);
std::cout << -m;
\endcode
prints
\code
-1 -2 -3
-2 -5 -6
-3 -6 -9
\endcode
@return Result object.
*/
    basic_srsmatrix operator - () const {
        const TR mone(-1.);
        basic_srsmatrix mRes(*this);
        mRes._scalr(mone);
        return mRes;
    }

    // TODO dox
    // plus identity, prefix
    basic_srsmatrix& operator ++ () {
        this->_plus_plus();
        return *this;
    }

    // plus identity, postfix
    basic_srsmatrix operator ++ (int) {
        basic_srsmatrix mRes(*this);
        this->_plus_plus();
        return mRes;
    }

    // minus identity, prefix
    basic_srsmatrix& operator -- () {
        this->_minus_minus();
        return *this;
    }

    // minus identity, postfix
    basic_srsmatrix operator -- (int) {
        basic_srsmatrix mRes(*this);
        this->_minus_minus();
        return mRes;
    }

    basic_srsmatrix operator * (TR dMult) const {
        basic_srsmatrix mRes(*this);
        mRes._scalr(dMult);
        return mRes;
    }

    basic_srsmatrix operator / (TR dDiv) const {
        basic_srsmatrix mRes(*this);
        mRes._div(dDiv);
        return mRes;
    }

    basic_srsmatrix& operator *= (TR dMult) {
        this->_scalr(dMult);
        return *this;
    }

    basic_srsmatrix& operator /= (TR dDiv) {
        this->_div(dDiv);
        return *this;
    }

    basic_srsmatrix& normalize() {
        this->_normalize();
        return *this;
    }

/**
  @brief Does nothing and returns a copy of a calling symmetric
         matrix.
 */
    basic_srsmatrix operator ~ () const {
        return *this;
    }

/**
  @brief Assigns symmetric matrix \c m to a calling one and returns 
  a reference to the matrix changed.
*/
    basic_srsmatrix& transpose(const basic_srsmatrix& m) {
        (*this) = m;
        return *this;
    }

/** 
  @brief Does nothing and returns a reference to a calling
  symmetric matrix.
*/
    basic_srsmatrix& transpose() {
        return *this;
    }

    // TODO dox
    RVector operator * (const RVector& v) const {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), v.size());
        RVector vRes(this->msize());
        this->_multiply(vRes, v, false);
        return vRes;
    }

    // special exclusion since matrix product is not commutative
    BaseRMatrix operator * (const BaseRMatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.msize());
        const TR zero = TR(0.);
        const TR one = TR(1.);
        BaseRMatrix mRes(m.msize(), m.nsize());
        mRes._symm(true, *this, m, one, zero);
        return mRes;
    }

/**
@brief Matrix-matrix product

Creates an object of type \ref srmatrix as a product of a calling symmetric matrix and square matrix \c m.
Operator throws \ref cvmexception if dimension of a calling matrix
differs from dimension the matrix \c m.
Use \ref mult() to avoid new object creation.
\par Example:
\code
using namespace cvm;
try {
    srsmatrix ms(3);
    srmatrix m(3);
    ms.set(1.);
    m.set(2.);
    std::cout << ms * m << std::endl;
    double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
    const srsmatrix ms2(a, 3);
    std::cout << ms2 * ms;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
6 6 6
6 6 6
6 6 6

6 6 6
13 13 13
18 18 18
\endcode
@param[in] m \ref srmatrix to compute product with.
@return Result object.
*/
    BaseSRMatrix operator * (const BaseSRMatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.msize());
        const TR zero = TR(0.);
        const TR one = TR(1.);
        BaseSRMatrix mRes(this->msize());
        mRes._symm(true, *this, m, one, zero);
        return mRes;
    }

    // TODO dox
    // 6.1: reversed vector operator % returns solution of A*X=B equation
    // overridden to mask out operator / (TR)
    RVector operator / (const RVector& v) const {
        return v % (*this);
    }

    // this = alpha*v*v' + beta*this
/**
@brief Rank-1 update matrix-vector operation

Calls one of \c DSYRK routines of the \c BLAS library
performing rank-1 update matrix-vector operation defined as
\f[
A=\alpha\,\begin{pmatrix}
v_1 \\
v_2 \\
\vdots \\
v_n
\end{pmatrix}
\begin{pmatrix}
v_1 & v_2 & \cdots & x_n
\end{pmatrix} + \beta A,
\f]
where \f$\alpha\f$ and \f$\beta\f$ are real numbers (parameters \c alpha and \c beta),
\f$A\f$ is calling symmetric matrix and \f$v\f$ is real vector (parameter \c v).
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
const treal alpha = 2.12;
const treal beta = -3.07;
rvector v(3);
srsmatrix ms(3), ms2(3);
v.randomize(-3.,2.);
ms.randomize(-1.,2.);
ms2 = ms;
ms.syrk(alpha, v, beta);
ms2 = alpha * srsmatrix(v.rank1update(v)) + beta * ms2;
std::cout << ms - ms2;
\endcode
prints
\code
0 0 0
0 0 0
0 0 0
\endcode
@see http://www.netlib.org/blas
@param[in] alpha Multiplier \f$\alpha\f$.
@param[in] v \ref rvector \f$v\f$.
@param[in] beta Multiplier \f$\beta\f$.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& syrk(TR alpha, const RVector& v, TR beta) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), v.size());
        RVector vc(v);  // has to guarantee incr to be 1
        __syrk<TR,basic_srsmatrix>(false, alpha, 1, vc, vc.size(), beta, *this);
        this->_flip();
        return *this;
    }

// this = alpha*a*a' + beta*this or this = alpha*a'*a + beta*this
/**
@brief Rank-1 update matrix-matrix operation

Calls one of \c DSYRK routines of the \c BLAS library
performing rank-1 update matrix-vector operation defined as
\f[
A=\alpha MM^T + \beta A\quad\text{or}\quad A=\alpha M^TM + \beta A.
\f]
where \f$\alpha\f$ and \f$\beta\f$ are real numbers (parameters \c alpha and \c beta),
\f$A\f$ is calling symmetric matrix and \f$M\f$ is real matrix (parameter \c m).
First operation is performed if \c bTransp passed is \c false and second one otherwise.
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
\par Example 1:
\code
using namespace cvm;
const treal alpha = 2.12;
const treal beta = -3.07;
rmatrix m(3,3);
srsmatrix ms(3), ms2(3);
m.randomize(-1.,2.);
ms.randomize(-1.,2.);
ms2 = ms;
ms.syrk(false, alpha, m, beta);
ms2 = alpha * srsmatrix(m * ~m) + beta * ms2;
std::cout << ms - ms2;
\endcode
prints
\code
0 0 0
0 0 0
0 0 0
\endcode
\par Example 2:
\code
using namespace cvm;
const treal alpha = 2.12;
const treal beta = -3.07;
rmatrix m(3,3);
srsmatrix ms(3), ms2(3);
m.randomize(-1.,2.);
ms.randomize(-1.,2.);
ms2 = ms;
ms.syrk(true, alpha, m, beta);
ms2 = alpha * srsmatrix(~m * m) + beta * ms2;
std::cout << ms - ms2;
\endcode
prints
\code
0 0 0
0 0 0
0 0 0
\endcode
@see http://www.netlib.org/blas
@param[in] bTransp Use transposed operation.
@param[in] alpha Multiplier \f$\alpha\f$.
@param[in] m \ref rmatrix \f$M\f$.
@param[in] beta Multiplier \f$\beta\f$.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& syrk(bool bTransp, TR alpha,
                          const BaseRMatrix& m, TR beta) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), bTransp ? m.nsize() : m.msize());
        __syrk<TR,basic_srsmatrix>(bTransp, alpha, bTransp ? m.msize() : m.nsize(),
                                   m, m.ld(), beta, *this);
        this->_flip();
        return *this;
    }

// this = alpha*v1*v2' + alpha*v2*v1' + beta*this
/**
@brief Rank-1 update matrix-vector operation

Calls \c SSYR2K or \c DSYR2K routine of the \c BLAS library
performing rank-1 update matrix-vector operation defined as
\f[
A=\alpha v_1 v_2' + \alpha v_2 v_1' + \beta A,
\f]
where \f$\alpha\f$ and \f$\beta\f$ are real numbers (parameters \c alpha and \c beta),
\f$A\f$ is calling symmetric matrix and \f$v_1\f$ and \f$v_2\f$ are real vectors (parameters \c v1 and \c v2).
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
const treal alpha = 2.12;
const treal beta = -3.07;
rvector v1(4);
rvector v2(4);
srsmatrix ms(4), ms2(4);
v1.randomize(-1.,3.);
v2.randomize(-1.,3.);
ms.randomize(-1.,3.);
ms2 = ms;
ms.syr2k(alpha, v1, v2, beta);
ms2 = alpha * srsmatrix(v1.rank1update(v2) + v2.rank1update(v1)) + beta * ms2;
std::cout << ms - ms2;
\endcode
prints
\code
+0.00e+000 -1.33e-015 +0.00e+000 +0.00e+000
-1.33e-015 +0.00e+000 +4.44e-016 +0.00e+000
+0.00e+000 +4.44e-016 -5.55e-017 +0.00e+000
+0.00e+000 +0.00e+000 +0.00e+000 -8.88e-016
\endcode
@see http://www.netlib.org/blas
@param[in] alpha Multiplier \f$\alpha\f$.
@param[in] v1 \ref rvector \f$v_1\f$.
@param[in] v2 \ref rvector \f$v_2\f$.
@param[in] beta Multiplier \f$\beta\f$.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& syr2k(TR alpha, const RVector& v1,
                           const RVector& v2, TR beta) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), v1.size());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), v2.size());
        RVector v1c(v1);  // has to guarantee incr to be 1
        RVector v2c(v2);
        __syr2k<TR,basic_srsmatrix>(false, alpha, 1, v1c, v1c.size(), v2c, v2c.size(), beta, *this);
        this->_flip();
        return *this;
    }

// this = alpha*a*b' + alpha*b*a' + beta*this or this = alpha*a'*b + alpha*b'*a + beta*this
/**
@brief Rank-1 update matrix-matrix operation

Calls \c SSYR2K or \c DSYR2K routine of the \c BLAS library
performing rank-1 update matrix-matrix operation defined as
\f[
A=\alpha M_1 M_2^T + \alpha M_2 M_1^T + \beta A\quad
\text{or}\quad
A=\alpha M_1^T M_2 + \alpha M_2^T M_1 + \beta A.
\f]
where \f$\alpha\f$ and \f$\beta\f$ are real numbers (parameters \c alpha and \c beta),
\f$A\f$ is calling symmetric matrix and \f$M_1\f$ and \f$M_2\f$ are real matrices (parameters \c m1 and \c m2).
First operation is performed if \c bTransp passed is \c false and second one otherwise.
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
const treal alpha = 2.12;
const treal beta = -3.07;
rmatrix m1(3,3), m2(3,3);
srsmatrix ms(3), ms2(3);
m1.randomize(-2.,2.);
m2.randomize(-2.,2.);
ms.randomize(-1.,2.);
ms2 = ms;
ms.syr2k(false, alpha, m1, m2, beta);
ms2 = alpha * srsmatrix(m1 * ~m2 + m2 * ~m1) + beta * ms2;
std::cout << ms - ms2;
\endcode
prints
\code
+1.11e-015 +0.00e+000 +0.00e+000
+0.00e+000 +8.88e-016 +1.78e-015
+0.00e+000 +1.78e-015 -1.78e-015
\endcode
\par Example:
\code
using namespace cvm;
const treal alpha = 2.12;
const treal beta = -3.07;
rmatrix m1(3,3), m2(3,3);
srsmatrix ms(3), ms2(3);
m1.randomize(-2.,2.);
m2.randomize(-2.,2.);
ms.randomize(-1.,2.);
ms2 = ms;
ms.syr2k(true, alpha, m1, m2, beta);
ms2 = alpha * srsmatrix(~m1 * m2 + ~m2 * m1) + beta * ms2;
std::cout << ms - ms2;
\endcode
prints
\code
+0.00e+000 +1.78e-015 +0.00e+000
+1.78e-015 +0.00e+000 +1.33e-015
+0.00e+000 +1.33e-015 +0.00e+000
\endcode
@see http://www.netlib.org/blas
@param[in] bTransp Use transposed version of the operation.
@param[in] alpha Multiplier \f$\alpha\f$.
@param[in] m1 \ref rmatrix \f$M_1\f$.
@param[in] m2 \ref rmatrix \f$M_2\f$.
@param[in] beta Multiplier \f$\beta\f$.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& syr2k(bool bTransp, TR alpha, const BaseRMatrix& m1,
                           const BaseRMatrix& m2, TR beta) {
        if (bTransp) {
            _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.nsize());
            _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.nsize());
            _check_ne(CVM_SIZESMISMATCH, m1.msize(), m2.msize());
        } else {
            _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
            _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
            _check_ne(CVM_SIZESMISMATCH, m1.nsize(), m2.nsize());
        }
        __syr2k<TR,basic_srsmatrix>(bTransp, alpha, bTransp ? m1.msize() : m1.nsize(),
                                    m1, m1.ld(), m2, m2.ld(), beta, *this);
        this->_flip();
        return *this;
    }

/**
@brief Matrix inversion

This version sets calling matrix to be equal to symmetric matrix \c m inverted.
Function throws \ref cvmexception in case of inappropriate
sizes of the operands or when the matrix to be inverted is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(5);
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.05};
const srsmatrix m(a, 3);
srsmatrix mi(3);
mi.inv(m);
std::cout << mi << std::endl;
std::cout << mi * m - eye_real(3);
\endcode
prints
\code
1.85000e+002 -2.00000e+000 -6.00000e+001
-2.00000e+000 1.00000e+000 -0.00000e+000
-6.00000e+001 -0.00000e+000 2.00000e+001

0.00000e+000 0.00000e+000 0.00000e+000
0.00000e+000 0.00000e+000 0.00000e+000
0.00000e+000 0.00000e+000 0.00000e+000
\endcode
@param[in] m \ref srsmatrix to invert.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& inv(const basic_srsmatrix& m) {
        __inv<basic_srsmatrix>(*this, m);
        return *this;
    }

/**
@brief Matrix inversion

This version creates \ref srsmatrix object equal to a calling symmetric matrix inverted.
Function throws \ref cvmexception in case of memory allocation failure
or when the matrix to be inverted is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(5);
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.05};
const srsmatrix m(a, 3);
const srsmatrix mi = m.inv();
std::cout << mi << std::endl;
std::cout << mi * m - eye_real(3);
\endcode
prints
\code
1.85000e+002 -2.00000e+000 -6.00000e+001
-2.00000e+000 1.00000e+000 0.00000e+000
-6.00000e+001 0.00000e+000 2.00000e+001

0.00000e+000 0.00000e+000 0.00000e+000
0.00000e+000 0.00000e+000 0.00000e+000
0.00000e+000 0.00000e+000 0.00000e+000
\endcode
@return Result object.
*/
    basic_srsmatrix inv() const {
        basic_srsmatrix mRes(this->msize());
        __inv<basic_srsmatrix>(mRes, *this);
        return mRes;
    }

/**
@brief Matrix exponent

Computes exponent of symmetric matrix using Pade approximation defined as
\f[
R_{pq}(z)=D_{pq}(z)^{-1}N_{pq}(z)=1+z+\dots+z^p/p!\,,
\f]
where
\f[\begin{aligned}
N_{pq}(z)&=\sum_{k=0}^p\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}z^k,\\
D_{pq}(z)&=\sum_{k=0}^q\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}(-z)^k
\end{aligned}\f]
along with the matrix normalizing as described in
<em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 572.
Function uses \ref DMEXP (or \ref SMEXP for \c float version)
\c FORTRAN subroutine implementing the algorithm.
This version sets calling matrix to be equal to
exponent of symmetric matrix \c m and returns a reference to the matrix changed.
The algorithm uses parameter \c tol as \f$\varepsilon(p,q)\f$ in order to choose constants \f$p\f$ and \f$q\f$
so that
\f[
\varepsilon(p,q)\ge 2^{3-(p+q)}\frac{p!q!}{(p+q)!(p+q+1)!}.
\f]
This parameter is equal to the <em>largest relative spacing</em> (see cvmMachSp() ) by default.
Function throws \ref cvmexception in case of
inappropriate sizes of the operands or when LAPACK subroutine fails.
\par Example
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(15);
double a[] = {1., 2., 1., 2., 0., -1., 1., -1., 2.};
const srsmatrix m(a, 3);
srsmatrix me(3);
me.exp(m);
std::cout << me;
\endcode
prints
\code
9.198262499129191e+000 5.558586002658862e+000 3.852443363622595e+000
5.558586002658862e+000 5.345819135506598e+000 -1.706142639036265e+000
3.852443363622593e+000 -1.706142639036266e+000 1.090440513816545e+001
\endcode
Matlab output:
\code
  Columns 1 through 2

    9.198262499129212e+000    5.558586002658862e+000
    5.558586002658865e+000    5.345819135506588e+000
    3.852443363622600e+000   -1.706142639036258e+000

  Column 3

    3.852443363622601e+000
   -1.706142639036260e+000
    1.090440513816545e+001
\endcode
@param[in] m \ref srsmatrix to compute exponent for.
@param[in] tol Computation tolerance.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& exp(const basic_srsmatrix& m,
                         TR tol = basic_cvmMachSp<TR>()) {
        __exp_symm<basic_srsmatrix, TR>(*this, m, tol);
        return *this;
    }

/**
@brief Matrix exponent

Computes exponent of symmetric matrix using Pade approximation defined as
\f[
R_{pq}(z)=D_{pq}(z)^{-1}N_{pq}(z)=1+z+\dots+z^p/p!\,,
\f]
where
\f[\begin{aligned}
N_{pq}(z)&=\sum_{k=0}^p\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}z^k,\\
D_{pq}(z)&=\sum_{k=0}^q\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}(-z)^k
\end{aligned}\f]
along with the matrix normalizing as described in
<em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 572.
Function uses \ref DMEXP (or \ref SMEXP for \c float version)
\c FORTRAN subroutine implementing the algorithm.
This version creates an object of type \c srsmatrix as exponent of a calling symmetric matrix.
The algorithm uses parameter \c tol as \f$\varepsilon(p,q)\f$ in order to choose constants \f$p\f$ and \f$q\f$
so that
\f[
\varepsilon(p,q)\ge 2^{3-(p+q)}\frac{p!q!}{(p+q)!(p+q+1)!}.
\f]
This parameter is equal to the <em>largest relative spacing</em> (see cvmMachSp() ) by default.
Function throws \ref cvmexception in case of
inappropriate sizes of the operands or when LAPACK subroutine fails.
\par Example
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(15);
double a[] = {1., 2., 1., 2., 0., -1., 1., -1., 2.};
const srsmatrix m(a, 3);
std::cout << m.exp();
\endcode
prints
\code
9.198262499129184e+000 5.558586002658855e+000 3.852443363622591e+000
5.558586002658857e+000 5.345819135506593e+000 -1.706142639036265e+000
3.852443363622590e+000 -1.706142639036266e+000 1.090440513816545e+001
\endcode
Matlab output:
\code
  Columns 1 through 2

    9.198262499129212e+000    5.558586002658862e+000
    5.558586002658865e+000    5.345819135506588e+000
    3.852443363622600e+000   -1.706142639036258e+000

  Column 3

    3.852443363622601e+000
   -1.706142639036260e+000
    1.090440513816545e+001
\endcode
@param[in] tol Computation tolerance.
@return Result object.
*/
    basic_srsmatrix exp(TR tol = basic_cvmMachSp<TR>()) const {
        basic_srsmatrix msRes(this->msize());
        __exp_symm<basic_srsmatrix, TR>(msRes, *this, tol);
        return msRes;
    }

// this = v(1)*I + v(2)*m + v(3)*m^2 + ... + v(N)*m^(N-1)
/**
@brief Matrix polynomial

Computes symmetric matrix polynomial defined as
\f[
p(A)=b_0I+b_1A+\dots+b_qA^q
\f]
using the Horner's rule:
\f[
\newcommand{\floor}{\operatorname{floor}}p(A)=\sum_{k=0}^r B_k(A^s)^k,\quad s=\floor(\!\sqrt{q}\,),\ r=\floor(q/s)
\f]
where
\f[
B_k=\begin{cases}
\sum\limits_{i=0}^{s-1}b_{sk+i} A^i, & k=0,1,\dots,r-1\\
\sum\limits_{i=0}^{q-sr}b_{sr+i} A^i, & k=r.
\end{cases}
\f]
See also <em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 568.
The coefficients \f$b_0,b_1,\dots,b_q\f$ are passed in parameter \c v,
where \f$q\f$ is equal to \c v.size()-1, so the function
computes matrix polynomial equal to
\f[
\mathtt{v[1]*I + v[2]*m +\cdots + v[v.size()]*m^{v.size()-1}}
\f]
This version sets calling matrix to be equal to the polynomial of symmetric matrix \c m.
Function uses \ref DPOLY (or \ref SPOLY for \c float version) \c FORTRAN subroutine implementing the Horner's algorithm.
Function throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(7);
double a[] = {1., 2., 1., 2., 0., -1., 1., -1., 2.};
double av[] = {2.2, 1.3, 1.1, -0.9, 0.2,
              -0.45, 45, -30, 10, 3, 3.2};
const rvector v(av, 11);
const srsmatrix m(a, 3);
srsmatrix mp(3);
mp.polynom(m,v);
std::cout << mp;
\endcode
prints
\code
6.2127400e+004 2.3998000e+004 3.4100550e+004
2.3998000e+004 2.8026850e+004 1.0102550e+004
3.4100550e+004 1.0102550e+004 5.2024850e+004
\endcode
Matlab output:
\code
  Columns 1 through 2

    6.212740000000001e+004    2.399800000000000e+004
    2.399800000000000e+004    2.802685000000000e+004
    3.410055000000000e+004    1.010255000000000e+004

  Column 3

    3.410055000000000e+004
    1.010255000000000e+004
    5.202485000000000e+004
\endcode
@param[in] m \ref srsmatrix to compute polynomial for.
@param[in] v Vector of coefficients.
@return Reference to changed calling matrix.
*/
    basic_srsmatrix& polynom(const basic_srsmatrix& m,
                             const RVector& v) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        RVector v1;
        if (v.incr() > 1) v1 << v;  // to make sure incr = 1
        __polynom<TR,RVector>(this->get(), this->ld(), this->msize(),
                              m._pd(), m._ldm(), v.incr() > 1 ? v1 : v);
        return *this;
    }

// returns v(1)*I + v(2)*this + v(3)*this^2 + ... + v(N)*this^(N-1)
/**
@brief Matrix polynomial

Computes symmetric matrix polynomial defined as
\f[
p(A)=b_0I+b_1A+\dots+b_qA^q
\f]
using the Horner's rule:
\f[
\newcommand{\floor}{\operatorname{floor}}p(A)=\sum_{k=0}^r B_k(A^s)^k,\quad s=\floor(\!\sqrt{q}\,),\ r=\floor(q/s)
\f]
where
\f[
B_k=\begin{cases}
\sum\limits_{i=0}^{s-1}b_{sk+i} A^i, & k=0,1,\dots,r-1\\
\sum\limits_{i=0}^{q-sr}b_{sr+i} A^i, & k=r.
\end{cases}
\f]
See also <em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 568.
The coefficients \f$b_0,b_1,\dots,b_q\f$ are passed in parameter \c v,
where \f$q\f$ is equal to \c v.size()-1, so the function
computes matrix polynomial equal to
\f[
\mathtt{v[1]*I + v[2]*m +\cdots + v[v.size()]*m^{v.size()-1}}
\f]
This version creates an object of type \ref srsmatrix as the polynomial of a calling symmetric matrix.
Function uses \ref DPOLY (or \ref SPOLY for \c float version) \c FORTRAN subroutine implementing the Horner's algorithm.
Function throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(7);
double a[] = {1., 2., 1., 2., 0., -1., 1., -1., 2.};
double av[] = {2.2, 1.3, 1.1, -0.9, 0.2,
              -0.45, 45, -30, 10, 3, 3.2};
const rvector v(av, 11);
const srsmatrix m(a, 3);
std::cout << m.polynom(v);
\endcode
prints
\code
6.2127400e+004 2.3998000e+004 3.4100550e+004
2.3998000e+004 2.8026850e+004 1.0102550e+004
3.4100550e+004 1.0102550e+004 5.2024850e+004
\endcode
Matlab output:
\code
  Columns 1 through 2

    6.212740000000001e+004    2.399800000000000e+004
    2.399800000000000e+004    2.802685000000000e+004
    3.410055000000000e+004    1.010255000000000e+004

  Column 3

    3.410055000000000e+004
    1.010255000000000e+004
    5.202485000000000e+004
\endcode
@param[in] v Vector of coefficients.
@return Result object.
*/
    basic_srsmatrix polynom(const RVector& v) const {
        basic_srsmatrix msRes(this->msize());
        RVector v1;
        if (v.incr() > 1) v1 << v;  // to make sure incr = 1
        __polynom<TR,RVector>(msRes, msRes.ld(), this->msize(), this->get(),
                              this->ld(), v.incr() > 1 ? v1 : v);
        return msRes;
    }

/**
@brief Eigenvalues and eigenvectors

Solves symmetric eigenvalue problem and creates \ref rvector object equal to eigenvalues
of a calling matrix.
The symmetric eigenvalue problem is defined as follows: given symmetric
matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
Eigenvalues and eigenvectors of symmetric real matrix \f$A\f$ are real.
Function sets output parameter \c mEigVect to be equal to square matrix containing eigenvectors as columns.
Function throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(10);
double a[] = {1., 2., 1., 2., 0., -1., 1., -1., 2.};
const srsmatrix m(a, 3);
srmatrix me(3);
rvector v(3);
v = m.eig(me);
std::cout << v << std::endl;
std::cout << m * me(1) - me(1) * v(1);
std::cout << m * me(2) - me(2) * v(2);
std::cout << m * me(3) - me(3) * v(3);
\endcode
prints
\code
-2.0489173395e+000 2.3568958679e+000 2.6920214716e+000

4.4408920985e-016 0.0000000000e+000 5.5511151231e-016
-1.1102230246e-016 2.2204460493e-016 2.2204460493e-016
0.0000000000e+000 -1.1102230246e-016 -4.4408920985e-016
\endcode
@see rvector::eig()
@param[out] mEigVect Eigenvectors of a calling symmetric matrix.
@return Result object.
*/
    RVector eig(BaseSRMatrix& mEigVect) const {
        RVector vEig(this->msize());
        __eig<RVector, basic_srsmatrix, BaseSRMatrix>(vEig, *this, &mEigVect, true);
        return vEig;
    }

/**
@brief Eigenvalues

Solves symmetric eigenvalue problem and creates \ref rvector object equal to eigenvalues
of a calling symmetric matrix.
The eigenvalue problem is defined as follows: given symmetric
matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
Eigenvalues and eigenvectors of symmetric real matrix \f$A\f$ are real.
Function throws \ref cvmexception
in case of memory allocation failure or convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(10);
double a[] = {1., 2., 1., 2., 0., -1., 1., -1., 2.};
const srsmatrix m(a, 3);
std::cout << m.eig();
\endcode
prints
\code
-2.0489173395e+000 2.3568958679e+000 2.6920214716e+000
\endcode
@see rvector::eig()
@return Result object.
*/
    RVector eig() const {
        RVector vEig(this->msize());
        __eig<RVector, basic_srsmatrix, BaseSRMatrix>(vEig, *this, nullptr, true);
        return vEig;
    }

/**
@brief Cholesky factorization

Forms the Cholesky factorization of symmetric positive-definite calling matrix \f$A\f$ defined as
\f[
A=U^T U,
\f]
where \f$U\f$ is upper triangular matrix.
It utilizes one of \c DPOTRF routines of the
\c LAPACK library. Function creates \ref srmatrix object equal to the factorization.
Function throws \ref cvmexception in case of convergence error.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 2., 1., 2., 5., -1., 1., -1., 20.};
    const srsmatrix m(a, 3);
    srmatrix h = m.cholesky();
    std::cout << h << std::endl;
    std::cout << ~h * h - m;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
1 2 1
0 1 -3
0 0 3.16228

0 0 0
0 0 0
0 0 0
\endcode
@see http://www.netlib.org/lapack
@see basic_srmatrix::cholesky()
@return Result object.
*/
    BaseSRMatrix cholesky() const {
        BaseSRMatrix mRes(*this);
        tint nOutInfo = __cholesky<BaseSRMatrix>(mRes);
        _check_negative(CVM_WRONGMKLARG, nOutInfo);
        _check_positive(CVM_NOTPOSITIVEDEFINITE, nOutInfo);
        mRes._clean_low_triangle();
        return mRes;
    }

/**
@brief Bunch-Kaufman factorization

Forms the Bunch-Kaufman factorization of symmetric calling matrix (cited from the MKL library documentation):
\f[
A=PUDU^TP^T,
\f]
where \f$A\f$ is calling symmetric matrix,
\f$P\f$ is a permutation matrix, \f$U\f$ and \f$L\f$ are upper and lower triangular
matrices with unit diagonal, and \f$D\f$ is a symmetric
block-diagonal matrix with 1-by-1 and 2-by-2
diagonal blocks. \f$U\f$ and \f$L\f$ have 2-by-2 unit diagonal
blocks corresponding to the 2-by-2 blocks of \f$D\f$.
It utilizes one of \c DSYTRF routines of the \c LAPACK library.
Function creates \ref srmatrix object equal to the factorization
of symmetric calling matrix.
Function throws \ref cvmexception in case of convergence error.
Function is mostly designed to be used for subsequent calls
of \c DSYTRS, \c DSYCON and \c DSYTRI routines of the
\c LAPACK library.
Currently it's used internally in \ref det() flow
when argument is symmetric but not positive-definite.

@see http://www.netlib.org/lapack
@see basic_srmatrix::bunch_kaufman()
@param[out] nPivots Pivot indices array.
@return Result object.
*/
    BaseSRMatrix bunch_kaufman(tint* nPivots) const {
        BaseSRMatrix mRes(*this);
        __bunch_kaufman<BaseSRMatrix>(mRes, nPivots);
        return mRes;
    }

    // TODO dox
    basic_srsmatrix& identity() {
        this->_vanish();
        this->_plus_plus();
        return *this;
    }

    basic_srsmatrix& vanish() {
        this->_vanish();
        return *this;
    }

    basic_srsmatrix& randomize(TR dFrom, TR dTo) {
        this->_randomize(dFrom, dTo);
        return *this;
    }

    // infinity-norm - the same as 1-norm for symmetric matrices
    TR norminf() const override {
        return this->norm1();
    }

/**
@brief Is calling symmetric matrix positive definite?

@return \c true if calling symmetric matrix is positive definite.
*/
    [[nodiscard]] bool is_positive_definite() const {
        const TR zero = TR(0.);
        const TR* pd = this->_pv();
        const tint nSize = this->_size();
        const tint nNext = this->_msize() + 1;
        CVM_ASSERT(pd, nSize * sizeof(TR))
        for (tint i = 0; i < nSize; i += nNext) {
            if (pd[i] <= zero) {
                return false;
            }
        }
        return true;
    }

/**
@brief Matrix equilibration

Useful for further solve and solve_lu calling.

@return \c true if equilibration was needed and performed.
*/
    bool equilibrate(RVector& vScalings, RVector& vB) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vB.size());
        bool bRes = this->_equilibrate(vScalings);
        if (bRes) {
            for (tint i = 0; i < this->msize(); ++i) {
                vB[i] *= vScalings[i];
            }
        }
        return bRes;
    }

/**
@brief Matrix equilibration

Useful for further solve and solve_lu calling.

@return \c true if equilibration was needed and performed.
*/
    bool equilibrate(RVector& vScalings, BaseRMatrix& mB) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mB.msize());
        bool bRes = this->_equilibrate(vScalings);
        if (bRes) {
            for (tint j = 0; j < mB.nsize(); ++j) {
                for (tint i = 0; i < this->msize(); ++i) {
                    mB(i, j) *= vScalings[i];
                }
            }
        }
        return bRes;
    }

//! @cond INTERNAL
    // special care for symmetric matrices
    basic_srsmatrix& _factorize(const basic_srsmatrix& m, tint* nPivots,
                                bool& bPositiveDefinite) {
        (*this) = m;
        tint nOutInfo = __cholesky<BaseSRMatrix>(*this);
        _check_negative(CVM_WRONGMKLARG, nOutInfo);
        if (nOutInfo > 0) {
            (*this) = m;
            __bunch_kaufman<BaseSRMatrix>(*this, nPivots);
            bPositiveDefinite = false;
        } else {
            bPositiveDefinite = true;
        }
        return *this;
    }

    // makes lower triangle to be equal to upper one
    void _flip() {
        if (this->msize() > 1) {
            const tint nM1 = this->ld() + 1, nM1m = this->ld() - 1, nM2m = this->msize() - 1;
            tint i = 1, j = 1, m;
            for (;;) {
                m = this->msize() - i;
                __copy<TR>(m, this->get() + j + nM1m, this->ld(), this->get() + j, 1);
                if (i >= nM2m) {
                    break;
                }
                i++;
                j += nM1;
            }
        }
    }

    // redefinition of basic_array's function
    TR* _pd() override {
        return this->get();
    }

    // redefinition of basic_array's function
    const TR* _pd() const override {
        return this->get();
    }

    void _check_submatrix() const override {
        throw cvmexception(CVM_SUBMATRIXNOTAVAILABLE, "srsmatrix");
    }

protected:
    const TR* _pp(const BaseMatrix& m) const override {  // for _msum _mdiff etc.
        return m.get();
    }

    void _check_ger()           override { throw cvmexception(CVM_METHODNOTAVAILABLE, "ger", "srsmatrix");}
    void _check_rank1update()   override { throw cvmexception(CVM_METHODNOTAVAILABLE, "rank1update", "srsmatrix");}
    void _check_gemm()          override { throw cvmexception(CVM_METHODNOTAVAILABLE, "gemm", "srsmatrix");}
    void _swap_rows(tint, tint) override { throw cvmexception(CVM_METHODNOTAVAILABLE, "swap_rows", "srsmatrix");}
    void _swap_cols(tint, tint) override { throw cvmexception(CVM_METHODNOTAVAILABLE, "swap_cols", "srsmatrix");}

    // we do nothing here - it's symmetric
    void _transp() override {
    }

    // returns main diagonal of low_up factorization
    // this call is useless for symmetric matrices. this call would mean serious CVM internal error
    RVector _low_up_diag(basic_array<tint,tint>&) const override {
        throw cvmexception(CVM_NOTIMPLEMENTED, "_low_up_diag");
    }

    void _scalr(TR d) override {
        __scal<TR,TR>(this->get(), this->size(), this->incr(), d);  // zero tails are supposed here
    }

    void _multiply(RVector& vRes, const RVector& v, bool) const override {
        RVector vTmp;
        basic_srsmatrix mTmp;
        const TR zero = TR(0.);
        const TR one = TR(1.);
        const TR* pDm = this->get();
        const TR* pDv = v;
        if (vRes.get() == pDv) vTmp << v;
        if (vRes.get() == pDm) mTmp << *this;
        __symv<TR,basic_srsmatrix, RVector>(vRes.get() == pDm ? mTmp : *this, one,
                                             vRes.get() == pDv ? vTmp : v, zero, vRes);
    }

    void _randomize(TR dFrom, TR dTo) override {
        this->BaseSRMatrix::_randomize(dFrom, dTo);
        this->_flip();
    }

    void _solve(const RVector& vB, RVector& vX,
                TR& dErr, const TR* pLU, const tint* pPivots,
                int transp_mode) const override {
        // 6.1: fix for non-positive definite solutions
        if (!this->is_positive_definite()) {
            BaseSRMatrix::_solve(vB, vX, dErr, pLU, pPivots, transp_mode);
            return;
        }
        RVector vB1(vB);  // to make sure incr = 1 and equilibrate
        RVector vScalings(this->msize());
        basic_srsmatrix m(*this);
        const bool bEquilibrated = m.equilibrate(vScalings, vB1);
        RVector vX1(vB1);
        __solve<TR,TR,
            basic_srsmatrix>(m, 1, vB1, vB1.size(), vX1, vX1.size(),
                             dErr, pLU, pPivots, 0);  // no transpose
        if (bEquilibrated) {
            for (tint i = 1; i <= this->msize(); ++i) {
                vX[i] = vX1[i] * vScalings[i];
            }
        } else {
            vX = vX1;
        }
    }

    void _solve(const BaseRMatrix& mB, BaseRMatrix& mX,
                TR& dErr, const TR* pLU, const tint* pPivots,
                int transp_mode) const override {
        // 6.1: fix for non-positive definite solutions
        if (!this->is_positive_definite()) {
            BaseSRMatrix::_solve(mB, mX, dErr, pLU, pPivots, transp_mode);
            return;
        }
        BaseRMatrix mB1(mB);  // to equilibrate
        RVector vScalings(this->msize());
        basic_srsmatrix m(*this);
        const bool bEquilibrated = m.equilibrate(vScalings, mB1);
        mX = mB1;
        __solve<TR,TR,
            basic_srsmatrix>(m, mB.nsize(), mB, mB.ld(), mX, mX.ld(),
                             dErr, pLU, pPivots, 0);  // no transpose
        if (bEquilibrated) {
            for (tint j = 1; j <= mX.nsize(); ++j) {
                for (tint i = 1; i <= this->msize(); ++i) {
                    mX(i, j) *= vScalings[i];
                }
            }
        }
    }

    // matrix determinant
    TR _det() const override {
        TR dDet = TR(0.);
        switch (this->msize()) {
        case 0:
            break;
        case 1:
            dDet = this->_ij_val(0, 0);
            break;
        case 2:
            dDet = this->_ij_val(0, 0) * this->_ij_val(1, 1) -
               this->_ij_val(1, 0) * this->_ij_val(0, 1);
            break;
        default:
            try {
                const TR one(1.);
                bool bPositiveDefinite = false;
                basic_srsmatrix m(this->msize());
                basic_array<tint,tint> nPivots(this->msize());
                m._factorize(*this, nPivots, bPositiveDefinite);

                tint i;
                dDet = one;
                if (bPositiveDefinite) {
                    const RVector vUpDiag = m.diag(0);
                    for (i = 1; i <= this->msize(); ++i) {
                        dDet *= vUpDiag[i] * vUpDiag[i];  //here we use Cholesky factorization
                    }
                } else {
                    const RVector vEig = this->eig();
                    for (i = 1; i <= this->msize(); ++i) {
                        dDet *= vEig[i];  //here we use eigenvalues. probably there is a better way.
                    }
                }
            }
            catch (const cvmexception& e) {
                if (e.cause() != CVM_WRONGBUNCHKAUFMANFACTOR) throw e;
            }
            break;
        }
        return dDet;
    }

    // matrix equilibration helper
    bool _equilibrate(RVector& vScalings) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vScalings.size());
        bool bRes = false;
        TR dCond(0.);
        TR dMax  = TR();
        const TR sp = basic_cvmMachSp<TR>();
        const TR sp_inv = TR(1.) / sp;

        __poequ<TR,basic_srsmatrix, RVector>(*this, vScalings, dCond, dMax);

        if (dCond < TR(0.1) || std::abs(dMax) <= sp || std::abs(dMax) >= sp_inv) {
            bRes = true;
            for (tint i = 0; i < this->msize(); ++i) {
                for (tint j = i; j < this->msize(); ++j) {
                    this->get()[this->ld() * j + i] *= vScalings[i] * vScalings[j];
                }
            }
        }
        return bRes;
    }

    // sets both elements to keep matrix symmetric, checks ranges
    // zero based
    void _set_at(tint nRow, tint nCol, TR val) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, nRow, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, nCol, tint(), this->nsize());
        this->get()[this->ld() * nCol + nRow] = val;
        if (nRow != nCol) {
            this->get()[this->ld() * nRow + nCol] = val;
        }
    }

    void _check_symmetric(TR tol) const {
        for (tint j = 0; j < this->nsize(); ++j) {
            for (tint i = 0; i < this->msize(); ++i) {
                if (i != j && std::abs(this->get()[this->ld() * j + i] - this->get()[this->ld() * i + j]) > tol) {
                    throw cvmexception(CVM_MATRIXNOTSYMMETRIC);
                }
            }
        }
    }
//! @endcond
};


/**
@brief End-user class encapsulating Hermitian matrix of complex numbers

\c TR type stands for \ref treal, \c TC type stands for \ref tcomplex.
Please use predefined \ref schmatrix class in your applications.
@see Matrix
*/
template<typename TR, typename TC>
class basic_schmatrix : public basic_scmatrix<TR,TC>
{
    using RVector = basic_rvector<TR>;  //!< \ref rvector class
    using CVector = basic_cvector<TR,TC>;  //!< \ref cvector class
    using BaseMatrix = Matrix<TR,TC>;  //!< Base Matrix class
    using BaseCMatrix = basic_cmatrix<TR,TC>;  //!< \ref cmatrix class
    using BaseSCMatrix = basic_scmatrix<TR,TC>;  //!< \ref scmatrix class

public:
/**
@brief Default constructor

Creates empty Hermitian matrix. No memory gets allocated.
\par Example:
\code
using namespace cvm;
schmatrix m;
std::cout << m.msize() << " " << m.nsize() << " "
          << m.size() << std::endl;
m.resize(3);
std::cout << m;
\endcode
prints
\code
0 0 0
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
*/
    basic_schmatrix() = default;

/**
@brief Constructor

Creates \f$n\times n\f$ \ref schmatrix object where \f$n\f$ is passed in
\c nDim parameter. Constructor sets all elements to zero.
It throws \ref cvmexception in case of non-positive size passed or memory allocation failure.
Example:
\code
using namespace cvm;
schmatrix m(4);
std::cout << m.msize() << std::endl
          << m.nsize() << std::endl
          << m.size() << std::endl << m;
\endcode
prints
\code
4
4
16
(0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0)
\endcode
@param[in] nDim Number of rows and columns.
*/
    explicit basic_schmatrix(tint nDim)
      : BaseSCMatrix(nDim)
    {}

/**
@brief Constructor

Creates \f$n\times n\f$ \ref schmatrix object where \f$n\f$ is passed in \c nDim parameter.
It throws \ref cvmexception in case of non-positive size passed or
if the matrix created doesn't appear to be Hermitian.
Hermiticity tolerance is set by parameter \c tol.
Unlike others, this constructor <b>does not allocate memory</b>.
It just shares memory with an array pointed to by \c pd (for matrices \c nIncr=1 is always satisfied).
If subsequent application flow would change the array passed so
it becomes not Hermitian matrix anymore then results are not predictable.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a, 3);
m.set(2,1,std::complex<double>(8.,8.));
std::cout << m << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << " "
          << a[3] << " " << a[4] << " " << a[5] << " " << std::endl;
\endcode
prints
\code
(1,0) (8,-8) (-1,-2)
(8,8) (2,0) (0,-3)
(-1,2) (0,3) (3,0)

1 0 8 8 -1 2
\endcode
@see http://cvmlib.com/faq.htm
@see basic_cmatrix::basic_cmatrix(TC*,tint,tint)
@param[in] pd Pointer to an array to share memory with.
@param[in] nDim Number of rows and columns.
@param[in] tol Hermiticity tolerance.
*/
    basic_schmatrix(TC* pd, tint nDim, TR tol = basic_cvmMachSp<TR>())
      : BaseSCMatrix(pd, nDim, nDim, nDim * nDim) {
        this->_check_hermitian(tol);
    }

/**
@brief Constructor

Creates \f$n\times n\f$ \ref schmatrix object where \f$n\f$ is passed in \c nDim parameter.
Constructor throws \ref cvmexception in case of non-positive sizes passed or
if the matrix created doesn't appear to be Hermitian.
Hermiticity tolerance is set by parameter \c tol.
This is const version,
it allocates memory and copies every element (deep copy) from external array pointed to by \c pd parameter.
It copies \c nDim*nDim elements total.
\par Example:
\code
using namespace cvm;
const double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
                    0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((const std::complex<double>*)a, 3);
m.set(2,1,std::complex<double>(8.,8.));
std::cout << m << std::endl;
std::cout << a[0] << " " << a[1] << " " << a[2] << " "
          << a[3] << " " << a[4] << " " << a[5] << " " << std::endl;
\endcode
prints
\code
(1,0) (8,-8) (-1,-2)
(8,8) (2,0) (0,-3)
(-1,2) (0,3) (3,0)

1 0 2 1 -1 2
\endcode
@see http://cvmlib.com/faq.htm
@see basic_cmatrix::basic_cmatrix(const TC*,tint,tint)
@param[in] pd Const pointer to external array.
@param[in] nDim Number of rows and columns.
@param[in] tol Hermiticity tolerance.
*/
    basic_schmatrix(const TC* pd, tint nDim, TR tol = basic_cvmMachSp<TR>())
      : BaseSCMatrix(pd, nDim, nDim, nDim * nDim) {
        this->_check_hermitian(tol);
    }

/**
@brief Copy constructor

Creates \ref schmatrix object as a copy of Hermitian matrix \c m.
It throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left |
                std::ios::showpos);
std::cout.precision(1);
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a, 3);
scmatrix mc(m);
m.set(1,2, std::complex<double>(7.7,7.7));
std::cout << m << std::endl << mc;
\endcode
prints
\code
(+1.0e+000,+0.0e+000) (+7.7e+000,+7.7e+000) (-1.0e+000,-2.0e+000)
(+7.7e+000,-7.7e+000) (+2.0e+000,+0.0e+000) (+0.0e+000,-3.0e+000)
(-1.0e+000,+2.0e+000) (+0.0e+000,+3.0e+000) (+3.0e+000,+0.0e+000)

(+1.0e+000,+0.0e+000) (+2.0e+000,-1.0e+000) (-1.0e+000,-2.0e+000)
(+2.0e+000,+1.0e+000) (+2.0e+000,+0.0e+000) (+0.0e+000,-3.0e+000)
(-1.0e+000,+2.0e+000) (+0.0e+000,+3.0e+000) (+3.0e+000,+0.0e+000)
\endcode
@param[in] m \ref schmatrix to copy from.
*/
    basic_schmatrix(const basic_schmatrix& m)
      : BaseSCMatrix(m.msize(), m.msize(), false) {
        this->_massign(m);
    }

/**
@brief Move constructor

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to newly created object.
It's usually executed implicitly in cases like this:
\code
rvector a(b + c);
\endcode
or this
\code
rvector a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to newly created object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_schmatrix(basic_schmatrix&& m) noexcept
       : BaseSCMatrix(std::move(m))
    {}

/**
@brief Constructor

Creates \ref schmatrix object as a copy of complex matrix \c m.
It's assumed that \f$m\times n\f$ matrix \c m must have equal
sizes, i.e. \f$m = n\f$ is satisfied, and must be Hermitian.
Hermiticity tolerance is set by parameter \c tol.
Constructor throws \ref cvmexception if this is not true or in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
cmatrix m ((std::complex<double>*)a, 3, 3);
scmatrix mch(m);
std::cout << mch;
\endcode
prints
\code
(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)
\endcode
@param[in] m \ref cmatrix to copy from.
@param[in] tol Hermiticity tolerance.
*/
    explicit basic_schmatrix(const BaseCMatrix& m, TR tol = basic_cvmMachSp<TR>())
      : BaseSCMatrix(m.msize(), m.nsize(), false) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), this->nsize());
        this->_massign(m);
        this->_check_hermitian(tol);
    }

/**
@brief Constructor

Creates \ref schmatrix object of size \c v.size() by \c v.size()
and assigns real vector \c v to its main diagonal.
Constructor throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 4., 5.};
const rvector v (a, 5);
schmatrix m(v);
std::cout << m.msize() << " " << m.nsize() << " "
          << m.size() << std::endl << m;
\endcode
prints
\code
5 5 25
(1,0) (0,0) (0,0) (0,0) (0,0)
(0,0) (2,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (3,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (4,0) (0,0)
(0,0) (0,0) (0,0) (0,0) (5,0)
\endcode
@param[in] v \ref rvector to copy main diagonal from.
*/
    explicit basic_schmatrix(const RVector& v)
      : BaseSCMatrix(v.size(), v.size(), true) {
        __copy2<TR,TC>(this->get(), v.size(), this->ld() + 1, v._pd(), nullptr, v.incr());
    }

/**
@brief Constructor

Creates \ref schmatrix object having the same dimension as real symmetric matrix \c m
and copies matrix \c m to its real part.
\par Example:
\code
using namespace cvm;
double a[] = {1., 2., 3., 2., 5., 6., 3., 6., 9.};
srsmatrix m(a, 3);
schmatrix mch(m);
std::cout << mch;
\endcode
prints
\code
(1,0) (2,0) (3,0)
(2,0) (5,0) (6,0)
(3,0) (6,0) (9,0)
\endcode
@param[in] m \ref srsmatrix to copy from.
*/
    explicit basic_schmatrix(const basic_srsmatrix<TR>& m)
      : BaseSCMatrix(m.msize(), m.msize(), true) {
        __copy2<TR,TC>(this->get(), this->size(), this->incr(), m._pd(), nullptr);
    }

/**
@brief Constructor

Creates \c schmatrix object of dimension \c nDim and copies every
element of an arrays pointed to by \c pRe and \c pIm to real and imaginary part
of the matrix created respectively.
Use \c nullptr pointer to fill up appropriate part with zero values.
Contructor checks that the matrix is Hermitian and throws \ref cvmexception otherwise.
Hermiticity tolerance is set by parameter \c tol.
Constructor also throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double re[] = {1., 2., -1., 2., 2., 0., -1., 0., 3.};
double im[] = {0., 1., 2., -1., 0., 3., -2., -3., 0.};
schmatrix m(re, im, 3);
std::cout << m;
\endcode
prints
\code
(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)
\endcode
@param[in] pRe Const pointer to external \ref treal array to copy to real part.
@param[in] pIm Const pointer to external \ref treal array to copy to imaginary part.
@param[in] nDim Matrix dimension.
@param[in] tol Hermiticity tolerance.
*/
    basic_schmatrix(const TR* pRe, const TR* pIm, tint nDim, TR tol = basic_cvmMachSp<TR>())
      : BaseSCMatrix(pRe, pIm, nDim) {
        this->_check_hermitian(tol);
    }

/**
@brief Constructor

Creates \ref schmatrix object of dimension \c mRe.msize()
(if it differs from \c mIm.msize() then constructor throws \ref cvmexception)
and copies matrices \c mRe and \c mIm to real and imaginary part of the matrix created respectively.
Contructor checks that the matrix is Hermitian and throws \ref cvmexception otherwise.
Hermiticity tolerance is set by parameter \c tol.
Constructor also throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double re[] = {1., 2., -1., 2., 2., 0., -1., 0., 3.};
double im[] = {0., 1., 2., -1., 0., 3., -2., -3., 0.};
srmatrix mr(re, 3);
srmatrix mi(im, 3);
schmatrix m(mr, mi);
std::cout << m;
\endcode
prints
\code
(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)
\endcode
@param[in] mRe \ref srmatrix to copy to real part.
@param[in] mIm \ref srmatrix to copy to imaginary part.
@param[in] tol Hermiticity tolerance.
*/
    basic_schmatrix(const basic_srmatrix<TR>& mRe, const basic_srmatrix<TR>& mIm, TR tol = basic_cvmMachSp<TR>())
      : BaseSCMatrix(mRe, mIm) {
        this->_check_hermitian(tol);
    }

/**
@brief Submatrix constructor

Creates \ref schmatrix object as submatrix of Hermitian matrix \c m.
It means that the object created shares memory with some part
of \c m. This part is defined by its upper left corner and its dimension (parameter \c nDim).
\par Example:
\code
using namespace cvm;
srsmatrix m(5);
srsmatrix subm(m, 2, 2);
subm.set(1.);
std::cout << m;
\endcode
prints
\code
0 0 0 0 0
0 1 1 0 0
0 1 1 0 0
0 0 0 0 0
\endcode
@param[in] m Parent \ref schmatrix to attach to.
@param[in] nRowCol Row and column to start from.
@param[in] nDim Dimension of square submatrix.
*/
    basic_schmatrix(basic_schmatrix& m, tint nRowCol, tint nDim)
      : BaseSCMatrix(m._sub_pointer(nRowCol, nRowCol, nDim, nDim), nDim, m.ld(), nDim * nDim)
    {}

    //! @copydoc basic_cmatrix::operator()(tint,tint)const
    // Masking non-const overload inherited from basic_cmatrix
    TC operator () (tint nRow, tint nCol) const {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, nRow, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, nCol, tint(), this->nsize());
        return this->_ij_val(nRow, nCol);
    }

    //! @copydoc basic_cmatrix::operator()(tint)const
    // returns column which is NOT l-value
    // Masking non-const overload inherited from basic_cmatrix
    CVector operator () (tint nCol) const {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nCol, tint(), this->nsize());
        return this->_col(nCol);
    }

    //! @copydoc basic_cmatrix::operator[](tint)const
    // returns row which is NOT l-value
    // Masking non-const overload inherited from basic_cmatrix
    CVector operator [] (tint nRow) const {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nRow, tint(), this->msize());
        return this->_row(nRow);
    }

    //! @copydoc basic_cmatrix::diag(tint)const
    // returns diagonal which IS NOT l-value
    // 0 - main, negative - low, positive - up
    // Masking non-const overload inherited from basic_cmatrix
    CVector diag(tint nDiag) const {
        return this->_diag(nDiag);
    }

    // TODO dox
    // real part (symmetric)
    basic_srsmatrix<TR> real() const {
        basic_srsmatrix<TR> mRet(this->msize());
        __copy<TR>(this->size(), __get_real_p<TR>(this->get()),
                   this->incr() * 2, mRet, mRet.incr());
        return mRet;
    }

    // imaginary part (NOT symmetric)
    basic_srmatrix<TR> imag() const {
        basic_srmatrix<TR> mRet(this->msize());
        __copy<TR>(this->size(), __get_imag_p<TR>(this->get()),
                   this->incr() * 2, mRet, mRet.incr());
        return mRet;
    }

/**
@brief Assignment operator

Sets every element of a calling \ref schmatrix to be equal to
appropriate element of Hermitian matrix \c m and returns a reference to
the matrix changed.
Operator throws \ref cvmexception in case of different matrix dimensions.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
                  0., 3., -1., -2., 0., -3., 3., 0.};
    schmatrix m1((std::complex<double>*)a, 3);
    schmatrix m2(3);

    m2 = m1;
    std::cout << m2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what() << std::endl;
}
\endcode
prints
\code
(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)
\endcode
@param[in] m \ref schmatrix to assign from.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& operator = (const basic_schmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        this->_massign(m);
        return *this;
    }

/**
@brief Move assignment operator

Implements move semantics introduced in new C++ standard.
Moves data ownership from other matrix to a calling object.
It's usually executed implicitly in cases like this:
\code
a = b + c;
\endcode
Here temporary result of a calling <tt>b.operator+(c)</tt> will not be
destroyed but rather moved to a calling object <tt>a</tt>.
@param[in] m rvalue reference to other matrix.
*/
    basic_schmatrix& operator = (basic_schmatrix&& m) noexcept {
        // size check is in BaseSCMatrix
        BaseSCMatrix::operator = (std::move(m));
        return *this;
    }

/**
@brief Vector (as array) assignment

Sets every element of a calling Hermitian matrix to be equal to appropriate element of \ref rvector \c v as an array.
Assignment is performed according to a matrix storage (by columns). It's assumed that vector passed is long
enough to fill calling matrix. Function throws \ref cvmexception otherwise.
Function also throws \ref cvmexception if the matrix changed doesn't appear to be Hermitian.
Hermiticity tolerance is set by parameter \c tol.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
cvector v((std::complex<double>*)a, 9);
schmatrix m(3);
m.assign(v);
std::cout << m;
\endcode
prints
\code
(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)
\endcode
@param[in] v \ref cvector to assign.
@param[in] tol Hermiticity tolerance.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& assign(const CVector& v, TR tol = basic_cvmMachSp<TR>()) {
        _check_gt(CVM_SIZESMISMATCH_GT, this->size(), v.size());
        this->_assign(v, v.incr());
        this->_check_hermitian(tol);
        return *this;
    }

/**
@brief External array assignment

Sets every element of a calling Hermitian matrix to be equal to
appropriate element of an array pointed to by parameter \c pd
and returns a reference to the matrix changed.
Assignment is performed according to a matrix storage (by columns).
It's assumed that array passed is long
enough to fill calling matrix.
Function throws \ref cvmexception if the matrix changed doesn't appear to be Hermitian.
Hermiticity tolerance is set by parameter \c tol.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m(3);
m.assign((std::complex<double>*)a);
std::cout << m;
\endcode
prints
\code
(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)
\endcode
@param[in] pd Const pointer to external array.
@param[in] tol Hermiticity tolerance.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& assign(const TC* pd, TR tol = basic_cvmMachSp<TR>()) {
        this->_assign(pd, 1);
        this->_check_hermitian(tol);
        return *this;
    }

/**
@brief Assignment to submatrix

Sets main submatrix of a calling Hermitian matrix beginning with row and column
\c nRowCol to Hermitian matrix \c m and
returns a reference to the matrix changed. Function throws
\ref cvmexception if \c nRowCol is not positive or matrix \c m doesn't fit.
\par Example:
\code
using namespace cvm;
schmatrix m1(5);
schmatrix m2(2);
m2.set_main_diag(rvector(2,2.));
m2.set(1,2,std::complex<double>(2.,2.));
m1.assign(2,m2);
std::cout << m1;
\endcode
prints
\code
(0,0) (0,0) (0,0) (0,0) (0,0)
(0,0) (2,0) (2,2) (0,0) (0,0)
(0,0) (2,-2) (2,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0) (0,0)
(0,0) (0,0) (0,0) (0,0) (0,0)
\endcode
@param[in] nRowCol Row and column index.
@param[in] m Reference to Hermitian matrix to assign.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& assign(tint nRowCol, const basic_schmatrix& m) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE, nRowCol, tint(), this->msize());
        _check_gt(CVM_SIZESMISMATCH_GT, m.msize() + nRowCol, this->msize());
        this->_assign_shifted(this->_sub_pointer_nocheck(nRowCol, nRowCol), m._pd(), m.msize(), m.nsize(), m.ld());
        return *this;
    }

/**
@brief Sets both elements to keep matrix Hermitian

Sets main submatrix of a calling Hermitian matrix beginning with row and column
\c nRowCol to Hermitian matrix \c m and
returns a reference to the matrix changed. Function throws
\ref cvmexception if \c nRowCol is out of boundaries.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);

m.set(1,2,std::complex<double>(7.7,7.7));
m.set(3,3,11.11);
std::cout << m;
\endcode
prints
\code
(1,0) (7.7,7.7) (-1,-2)
(7.7,-7.7) (2,0) (0,-3)
(-1,2) (0,3) (11.11,0)
\endcode
@param[in] nRow Row (and column) index to set.
@param[in] nCol Column (and row) index to set.
@param[in] c Element value to set to.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& set(tint nRow, tint nCol, TC c) {
        this->_set_at(nRow, nCol, c);
        return *this;
    }

/**
@brief Sets lower and upper diagonals

Assigns complex vector \c vDiag to \f$i\f$-th diagonal of a calling Hermitian matrix
(\f$i\f$ is passed in \c nDiag parameter),
where \f$i<0\f$ for lower diagonals and \f$i>0\f$ for upper ones.
Function also assigns conjugated vector to \f$-i\f$-th diagonal
(thus calling matrix remains Hermitian).
Function returns a reference to the matrix changed.
Function throws \ref cvmexception if parameter \c nDiag is equal to zero
(use \ref set_main_diag() instead), is out of boundaries or if
vector \c vDiag passed has size not equal to <c>msize()-abs(nDiag)</c>.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
cvector v(2);
v.set(std::complex<double>(7.7,7.7));
m.set_diag(1, v);
std::cout << m;
\endcode
prints
\code
(1,0) (7.7,7.7) (-1,-2)
(7.7,-7.7) (2,0) (7.7,7.7)
(-1,2) (7.7,-7.7) (3,0)
\endcode
@param[in] nDiag Diagonal index to set.
@param[in] vDiag \ref cvector to set diagonal(s) to.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& set_diag(tint nDiag, const CVector& vDiag) {
        if (nDiag == 0) throw cvmexception(CVM_BREAKS_HERMITIANITY, "set_main_diag");
        const tint nD = std::abs(nDiag);
        const tint nSize = vDiag.size();
        _check_ne(CVM_SIZESMISMATCH, this->msize() - nD, nSize);
        const tint nShift = nDiag * this->ld();
        const tint nIncr = this->ld() + 1;
        TC* pD1 = this->get() + (nDiag > 0 ? nShift : nD);
        TC* pD2 = this->get() + (nDiag > 0 ? nD : nShift);
        __copy<TC>(nSize, vDiag, vDiag.incr(), pD1, nIncr);
        __copy<TC>(nSize, vDiag, vDiag.incr(), pD2, nIncr);
        __conj<TC>(pD2, nSize, nIncr);
        return *this;
    }

/**
@brief Sets main diagonal

Assigns real vector \c vDiag to main diagonal of a calling Hermitian matrix.
Function returns a reference to the matrix changed.
Function throws \ref cvmexception if vector \c vDiag passed
has size not equal to \ref msize().
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
rvector v(3);
v.set(7.7);
m.set_main_diag(v);
std::cout << m;
\endcode
prints
\code
(7.7,0) (2,-1) (-1,-2)
(2,1) (7.7,0) (0,-3)
(-1,2) (0,3) (7.7,0)
\endcode
@param[in] vDiag \ref rvector to set main diagonal to.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& set_main_diag(const RVector& vDiag) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vDiag.size());
        __copy_real<TR,TC>(this->get(), this->msize(), this->ld() + 1, vDiag, vDiag.incr());
        return *this;
    }

/**
@brief Assigns real symmetric matrix to real part

Sets real part of a calling Hermitian matrix to be equal to
real symmetric matrix \c mRe. Function returns a reference to
the matrix changed. It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
srsmatrix ms(3);
ms.set(7.);
m.assign_real(ms);
std::cout << m;
\endcode
prints
\code
(7,0) (7,-1) (7,-2)
(7,1) (7,0) (7,-3)
(7,2) (7,3) (7,0)
\endcode
@param[in] mRe \ref srsmatrix to assign to real part.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& assign_real(const basic_srsmatrix<TR>& mRe) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mRe.msize());
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), mRe.nsize());
        __copy_real<TR,TC>(this->get(), this->size(), this->incr(), mRe._pd(), mRe.incr());
        return *this;
    }

    // TODO dox
    // fills real part
    basic_schmatrix& set_real(TR d) {
        this->_set_real_number(d);
        return *this;
    }

    basic_schmatrix& resize(tint nNewDim) {
        this->_resize2(nNewDim, nNewDim);
        return *this;
    }

/**
@brief Matrix comparison

Operator compares calling Hermitian matrix with Hermitian matrix \c m
and returns \c true if they have same dimensions
and their appropriate elements differ by not more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m1((std::complex<double>*)a,3);
schmatrix m2(3);
m2.assign((std::complex<double>*)a);
std::cout << (m1 == m2) << std::endl;
\endcode
prints
\code
1
\endcode
@see operator !=()
@param[in] m Hermitian matrix to compare to.
@return bool Result of comparison.
*/
    bool operator == (const basic_schmatrix& m) const {
        return this->msize() == m.msize() && this->nsize() == m.nsize() && this->_mequals(m);
    }

/**
@brief Matrix comparison

Operator compares calling Hermitian matrix with Hermitian matrix \c m
and returns \c true if they have different sizes
or at least one of their appropriate elements differs by more than
\ref cvmMachMin() (the smallest normalized positive number).
Returns \c false otherwise.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m1((std::complex<double>*)a,3);
schmatrix m2(3);
m2.assign((std::complex<double>*)a);
m2.set(2,1,std::complex<double>(2.,1.000001));
std::cout << (m1 != m2) << std::endl;
\endcode
prints
\code
1
\endcode
@see operator ==()
@param[in] m \ref srsmatrix to compare to.
@return bool Result of comparison.
*/
    bool operator != (const basic_schmatrix& m) const {
        return !(this->operator == (m));
    }

/**
@brief Matrix replacement

Destroys calling Hermitian matrix, creates a new one as a copy of Hermitian matrix \c m
and returns a reference to the matrix changed. Operator throws \ref cvmexception
in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
schmatrix mc(1);
std::cout << m << std::endl;
std::cout << mc << std::endl;
mc << m;
std::cout << mc;
\endcode
prints
\code
(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)

(0,0)

(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)
\endcode
@see operator =()
@param[in] m \ref schmatrix to replace by.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& operator << (const basic_schmatrix& m) {
        this->_replace(m);
        this->_massign(m);
        return *this;
    }

/**
@brief Addition operator

Creates an object of type \ref schmatrix as a sum of
a calling Hermitian matrix and Hermitian matrix \c m.
Operator throws \ref cvmexception
in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
double b[] = {1., 0., 1., 1., 1., 1., 1., -1., 1., 0.,
              1., 1., 1., -1., 1., -1., 1., 0.};
schmatrix m1((std::complex<double>*)a,3);
schmatrix m2((std::complex<double>*)b,3);
std::cout << m1 + m2;
\endcode
prints
\code
(2,0) (3,-2) (0,-3)
(3,2) (3,0) (1,-4)
(0,3) (1,4) (4,0)
\endcode
@see sum()
@param[in] m \ref schmatrix to add to a calling one.
@return Sum of matrices.
*/
    basic_schmatrix operator + (const basic_schmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        basic_schmatrix mSum(*this);
        mSum._mincr(m);
        return mSum;
    }

/**
@brief Subtraction operator

Creates an object of type \ref schmatrix as a difference of
a calling Hermitian matrix and Hermitian matrix \c m.
It throws \ref cvmexception in case of different sizes of the operands
or memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
double b[] = {1., 0., 1., 1., 1., 1., 1., -1., 1., 0.,
              1., 1., 1., -1., 1., -1., 1., 0.};
schmatrix m1((std::complex<double>*)a,3);
schmatrix m2((std::complex<double>*)b,3);
std::cout << m1 - m2;
\endcode
prints
\code
(0,0) (1,0) (-2,-1)
(1,0) (1,0) (-1,-2)
(-2,1) (-1,2) (2,0)
\endcode
@see diff()
@param[in] m \ref schmatrix to subtract from calling one.
@return Difference of matrices.
*/
    basic_schmatrix operator - (const basic_schmatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        basic_schmatrix mDiff(*this);
        mDiff._mdecr(m);
        return mDiff;
    }

/**
@brief Sum of matrices

Assigns sum of Hermitian matrices \c m1 and \c m2 to a calling Hermitian matrix
and returns a reference to the matrices changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
double b[] = {1., 0., 1., 1., 1., 1., 1., -1., 1., 0.,
              1., 1., 1., -1., 1., -1., 1., 0.};
schmatrix m1((std::complex<double>*)a,3);
schmatrix m2((std::complex<double>*)b,3);
schmatrix m(3);
std::cout << m.sum(m1, m2);
\endcode
prints
\code
(2,0) (3,-2) (0,-3)
(3,2) (3,0) (1,-4)
(0,3) (1,4) (4,0)
\endcode
@see operator +()
@param[in] m1 First \ref schmatrix summand.
@param[in] m2 Second \ref schmatrix summand.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& sum(const basic_schmatrix& m1, const basic_schmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
        this->_msum(m1, m2);
        return *this;
    }

/**
@brief Difference of matrices

Assigns difference of Hermitian matrices \c m1 and \c m2 to a calling Hermitian matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
double b[] = {1., 0., 1., 1., 1., 1., 1., -1., 1., 0.,
              1., 1., 1., -1., 1., -1., 1., 0.};
schmatrix m1((std::complex<double>*)a,3);
schmatrix m2((std::complex<double>*)b,3);
schmatrix m(3);
std::cout << m.diff(m1, m2);
\endcode
prints
\code
(0,0) (1,0) (-2,-1)
(1,0) (1,0) (-1,-2)
(-2,1) (-1,2) (2,0)
\endcode
@see operator -()
@param[in] m1 First \ref schmatrix subtrahend.
@param[in] m2 Second \ref schmatrix subtrahend.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& diff(const basic_schmatrix& m1, const basic_schmatrix& m2) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
        this->_mdiff(m1, m2);
        return *this;
    }

/**
@brief Increment operator

Adds \ref schmatrix \c m to a calling Hermitian matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
double b[] = {1., 0., 1., 1., 1., 1., 1., -1., 1., 0.,
              1., 1., 1., -1., 1., -1., 1., 0.};
schmatrix m1((std::complex<double>*)a,3);
schmatrix m2((std::complex<double>*)b,3);
m1 += m2;
m2 += m2;
std::cout << m1 << std::endl;
std::cout << m2;
\endcode
prints
\code
(2,0) (3,-2) (0,-3)
(3,2) (3,0) (1,-4)
(0,3) (1,4) (4,0)

(2,0) (2,-2) (2,-2)
(2,2) (2,0) (2,-2)
(2,2) (2,2) (2,0)
\endcode
@see operator +()
@see sum()
@param[in] m \ref schmatrix to increment by.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& operator += (const basic_schmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        this->_mincr(m);
        return *this;
    }

/**
@brief Decrement operator

Subtracts \ref schmatrix \c m from calling Hermitian matrix
and returns a reference to the matrix changed.
It throws \ref cvmexception in case of different sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
double b[] = {1., 0., 1., 1., 1., 1., 1., -1., 1., 0.,
              1., 1., 1., -1., 1., -1., 1., 0.};
schmatrix m1((std::complex<double>*)a,3);
schmatrix m2((std::complex<double>*)b,3);
m1 -= m2;
m2 -= m2;
std::cout << m1 << std::endl;
std::cout << m2;
\endcode
prints
\code
(0,0) (1,0) (-2,-1)
(1,0) (1,0) (-1,-2)
(-2,1) (-1,2) (2,0)

(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
@see operator -()
@see diff()
@param[in] m \ref schmatrix to decrement by.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& operator -= (const basic_schmatrix& m) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        this->_mdecr(m);
        return *this;
    }

    // TODO dox
    basic_schmatrix operator - () const {
        const TR mone(-1.);
        basic_schmatrix mRes(*this);
        mRes._scalr(mone);
        return mRes;
    }

    // TODO dox
    // plus identity, prefix
    basic_schmatrix& operator ++ () {
        this->_plus_plus();
        return *this;
    }

    // plus identity, postfix
    basic_schmatrix operator ++ (int) {
        basic_schmatrix mRes(*this);
        this->_plus_plus();
        return mRes;
    }

    // minus identity, prefix
    basic_schmatrix& operator -- () {
        this->_minus_minus();
        return *this;
    }

    // minus identity, postfix
    basic_schmatrix operator -- (int) {
        basic_schmatrix mRes(*this);
        this->_minus_minus();
        return mRes;
    }

    basic_schmatrix operator * (TR dMult) const {
        basic_schmatrix mRes(*this);
        mRes._scalr(dMult);
        return mRes;
    }

    basic_schmatrix operator / (TR dDiv) const {
        basic_schmatrix mRes(*this);
        mRes._div(dDiv);
        return mRes;
    }

    BaseSCMatrix operator * (TC cMult) const {
        BaseSCMatrix mRes(*this);
        mRes._scalc(cMult);
        return mRes;
    }

    BaseSCMatrix operator / (TC cDiv) const {
        BaseSCMatrix mRes(*this);
        mRes._div(cDiv);
        return mRes;
    }

    basic_schmatrix& operator *= (TR dMult) {
        this->_scalr(dMult);
        return *this;
    }

    basic_schmatrix& operator /= (TR dDiv) {
        this->_div(dDiv);
        return *this;
    }

    // array normalizing
    basic_schmatrix& normalize() {
        this->_normalize();
        return *this;
    }

// 6.1: transposed (not conjugated) matrix
/**
@brief Matrix transposition

Creates an object of type \c schmatrix as transposed calling Hermitian matrix.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
schmatrix mt(3);
std::cout << m << std::endl << !m << std::endl ;
mt.transpose(m);
std::cout << mt << std::endl;
mt.transpose();
std::cout << mt;
\endcode
prints
\code
(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)

(1,0) (2,1) (-1,2)
(2,-1) (2,0) (0,3)
(-1,-2) (0,-3) (3,0)

(1,0) (2,1) (-1,2)
(2,-1) (2,0) (0,3)
(-1,-2) (0,-3) (3,0)

(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)
\endcode
@return Result object.
*/
    basic_schmatrix operator ! () const {
        basic_schmatrix mRes(*this);
        return mRes.transpose();
    }

/**
@brief Does nothing and returns copy of a calling Hermitian matrix.
*/
    basic_schmatrix operator ~ () const {
        return *this;
    }

/**
@brief Matrix transposition

Sets calling Hermitian matrix to be equal to Hermitian matrix \c m transposed.
Function throws \ref cvmexception in case of not appropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
schmatrix mt(3);
std::cout << m << std::endl << !m << std::endl ;
mt.transpose(m);
std::cout << mt << std::endl;
mt.transpose();
std::cout << mt;
\endcode
prints
\code
(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)

(1,0) (2,1) (-1,2)
(2,-1) (2,0) (0,3)
(-1,-2) (0,-3) (3,0)

(1,0) (2,1) (-1,2)
(2,-1) (2,0) (0,3)
(-1,-2) (0,-3) (3,0)

(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)
\endcode
@param[in] m \ref schmatrix to transpose.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& transpose(const basic_schmatrix& m) {
        (*this) = m;
        return this->transpose();
    }

/**
@brief Assigns Hermitian matrix \c m to a calling one and returns a reference to the matrix changed.
*/
    basic_schmatrix& conj(const basic_schmatrix& m) {
        (*this) = m;
        return *this;
    }

// 6.1: transposed (not conjugated) matrix
/**
@brief Matrix transposition (in-place)

Makes calling Hermitian matrix to be equal to transposed itself.
Function throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
schmatrix mt(3);
std::cout << m << std::endl << !m << std::endl ;
mt.transpose(m);
std::cout << mt << std::endl;
mt.transpose();
std::cout << mt;
\endcode
prints
\code
(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)

(1,0) (2,1) (-1,2)
(2,-1) (2,0) (0,3)
(-1,-2) (0,-3) (3,0)

(1,0) (2,1) (-1,2)
(2,-1) (2,0) (0,3)
(-1,-2) (0,-3) (3,0)

(1,0) (2,-1) (-1,-2)
(2,1) (2,0) (0,-3)
(-1,2) (0,3) (3,0)
\endcode
@return Reference to changed calling matrix.
*/
    basic_schmatrix& transpose() {
        this->_transp();
        return *this;
    }

/**
@brief Does nothing and returns a reference to a calling symmetric matrix.
*/
    basic_schmatrix& conj() {
        return *this;
    }

    // TODO dox
    CVector operator * (const CVector& v) const {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), v.size());
        CVector vRes(this->msize());
        this->_multiply(vRes, v, false);
        return vRes;
    }

    // special exclusion since matrix product is not commutative
    BaseCMatrix operator * (const BaseCMatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.msize());
        const TR zero = TR(0.);
        const TR one = TR(1.);
        BaseCMatrix mRes(m.msize(), m.nsize());
        mRes._hemm(true, *this, m, one, zero);
        return mRes;
    }

/**
@brief Matrix-matrix product

Creates an object of type \ref scmatrix as a product of a calling Hermitian matrix and square complex matrix \c m.
Operator throws \ref cvmexception if dimension of a calling matrix
differs from dimension the matrix \c m.
Use \ref mult() to avoid new object creation.
\par Example:
\code
using namespace cvm;
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
try {
    schmatrix ms((std::complex<double>*)a,3);
    scmatrix m(3);
    m.set(std::complex<double>(1.,1.));

    std::cout << ms * m;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(5,-1) (5,-1) (5,-1)
(6,2) (6,2) (6,2)
(-3,7) (-3,7) (-3,7)
\endcode
@param[in] m \ref scmatrix to compute product with.
@return Result object.
*/
    BaseSCMatrix operator * (const BaseSCMatrix& m) const {
        _check_ne(CVM_SIZESMISMATCH, this->nsize(), m.msize());
        const TR zero = TR(0.);
        const TR one = TR(1.);
        BaseSCMatrix mRes(this->msize());
        mRes._hemm(true, *this, m, one, zero);
        return mRes;
    }

    // TODO dox
    // 6.1: reversed vector operator % returns solution of A*X=B equation
    // overridden to mask out operator / (TC)
    CVector operator / (const CVector& v) const {
        return v % (*this);
    }

// this = alpha*v*v' + beta*this
/**
@brief Rank-1 update matrix-vector operation

Calls one of \c ZHERK routines of the \c BLAS library
performing rank-1 update matrix-vector operation defined as
\f[
A=\alpha\,\begin{pmatrix}
v_1 \\
v_2 \\
\vdots \\
v_n
\end{pmatrix}
\begin{pmatrix}
v_1^* & v_2^* & \cdots & v_n^*
\end{pmatrix} + \beta A,
\f]
where \f$\alpha\f$ and \f$\beta\f$ are real numbers (parameters \c alpha and \c beta),
\f$A\f$ is calling Hermitian matrix and \f$v\f$ is complex vector (parameter \c v).
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
const treal a[] = {1., -1., 2., 2., 3., -3.};
const cvector v((std::complex<double>*)a, 3);
const treal alpha = 2.12;
const treal beta = -3.07;
schmatrix mh(3), mh2(3);
mh.randomize_real(-1.,2.);
mh.randomize_imag(-2.,3.);
mh2 = mh;
mh.herk(alpha, v, beta);
mh2 = alpha * schmatrix(v.rank1update_c(v)) + beta * mh2;
std::cout << mh - mh2;
\endcode
prints
\code
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
@see http://www.netlib.org/blas
@param[in] alpha Multiplier \f$\alpha\f$.
@param[in] v \ref cvector \f$v\f$.
@param[in] beta Multiplier \f$\beta\f$.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& herk(TR alpha, const CVector& v, TR beta) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), v.size());
        CVector vc(v);  // has to guarantee incr to be 1
        __herk<TR,TC, basic_schmatrix>(false, alpha, 1, vc, vc.size(), beta, *this);
        this->_flip();
        return *this;
    }

// this = alpha*a*a' + beta*this or this = alpha*a'*a + beta*this
/**
@brief Rank-1 update matrix-matrix operation

Calls ZHERK routine of the \c BLAS library
performing rank-1 update matrix-vector operation defined as
\f[
A=\alpha MM^H + \beta A\quad\text{or}\quad A=\alpha M^HM + \beta A.
\f]
where \f$\alpha\f$ and \f$\beta\f$ are real numbers (parameters \c alpha and \c beta),
\f$A\f$ is calling Hermitian matrix and \f$M\f$ is complex matrix (parameter \c m).
First operation is performed if \c bTransp passed is \c false and second one otherwise.
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
\par Example 1:
\code
using namespace cvm;
cmatrix m(3,3);
const treal alpha = 2.12;
const treal beta = -3.07;
schmatrix mh(3), mh2(3);
m.randomize_real(-1.,2.);
m.randomize_imag(-2.,3.);
mh.randomize_real(-1.,2.);
mh.randomize_imag(-2.,3.);
mh2 = mh;
mh.herk(false, alpha, m, beta);
mh2 = alpha * schmatrix(m * ~m) + beta * mh2;
std::cout << mh - mh2;
\endcode
prints
\code
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
\par Example 2:
\code
using namespace cvm;
cmatrix m(3,3);
const treal alpha = 2.12;
const treal beta = -3.07;
schmatrix mh(3), mh2(3);
m.randomize_real(-1.,2.);
m.randomize_imag(-2.,3.);
mh.randomize_real(-1.,2.);
mh.randomize_imag(-2.,3.);
mh2 = mh;
mh.herk(true, alpha, m, beta);
mh2 = alpha * schmatrix(~m * m) + beta * mh2;
std::cout << mh - mh2;
\endcode
prints
\code
(3.55271e-015,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (1.77636e-015,0)
\endcode
@see http://www.netlib.org/blas
@param[in] bTransp Use transposed operation.
@param[in] alpha Multiplier \f$\alpha\f$.
@param[in] m \ref cmatrix \f$M\f$.
@param[in] beta Multiplier \f$\beta\f$.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& herk(bool bTransp, TR alpha, const BaseCMatrix& m, TR beta) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), bTransp ? m.nsize() : m.msize());
        __herk<TR,TC,
            basic_schmatrix>(bTransp, alpha, bTransp ? m.msize() : m.nsize(),
                             m, m.ld(), beta, *this);
        this->_flip();
        return *this;
    }

// this = alpha*v1*v2' + alpha*v2*v1' + beta*this
/**
@brief Rank-1 update matrix-vector operation

Calls \c ZHER2K routine of the \c BLAS library
performing rank-1 update matrix-vector operation defined as
\f[
A=\alpha v_1 v_2^* + \alpha^* v_2 v_1^* + \beta A,
\f]
where \f$\alpha\f$ is complex and \f$\beta\f$ is real number (parameters \c alpha and \c beta),
\f$A\f$ is calling Hermitian matrix and \f$v_1\f$ and \f$v_2\f$ are complex vectors (parameters \c v1 and \c v2).
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
const tcomplex alpha(2.12,-0.14);
const tcomplex alphac(2.12,0.14);
const treal beta = -3.07;
cvector v1(3), v2(3);
schmatrix mh(3), mh2(3);
v1.randomize_real(-1.,2.);
v1.randomize_imag(-2.,3.);
v2.randomize_real(-1.,2.);
v2.randomize_imag(-2.,3.);
mh.randomize_real(-1.,2.);
mh.randomize_imag(-2.,3.);
mh2 = mh;
mh.her2k(alpha, v1, v2, beta);
mh2 = schmatrix(alpha * v1.rank1update_c(v2) + alphac * v2.rank1update_c(v1)) + beta * mh2;
std::cout << mh - mh2;
\endcode
prints
\code
(+1.78e-015,+0.00e+000) (+0.00e+000,+0.00e+000) (+0.00e+000,+0.00e+000)
(+0.00e+000,+0.00e+000) (-1.78e-015,+0.00e+000) (+0.00e+000,+1.78e-015)
(+0.00e+000,+0.00e+000) (+0.00e+000,-1.78e-015) (+4.44e-016,+0.00e+000)
\endcode
@see http://www.netlib.org/blas
@param[in] alpha Complex multiplier \f$\alpha\f$.
@param[in] v1 \ref cvector \f$v_1\f$.
@param[in] v2 \ref cvector \f$v_2\f$.
@param[in] beta Real multiplier \f$\beta\f$.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& her2k(TC alpha, const CVector& v1, const CVector& v2, TR beta) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), v1.size());
        _check_ne(CVM_SIZESMISMATCH, this->msize(), v2.size());
        CVector v1c(v1);  // has to guarantee incr to be 1
        CVector v2c(v2);
        __her2k<TR,TC,
            basic_schmatrix>(false, alpha, 1, v1c, v1c.size(),
                             v2c, v2c.size(), beta, *this);
        this->_flip();
        return *this;
    }

// this = alpha*a*b' + alpha*b*a' + beta*this or this = alpha*a'*b + alpha*b'*a + beta*this
/**
@brief Rank-1 update matrix-matrix operation

Calls \c ZHE2K routine of the \c BLAS library
performing rank-1 update matrix-matrix operation defined as
\f[
A=\alpha M_1 M_2^H + \alpha^* M_2 M_1^H + \beta A\quad
\text{or}\quad
A=\alpha M_1^H M_2 + \alpha^* M_2^H M_1 + \beta A.
\f]
where \f$\alpha\f$ is complex and \f$\beta\f$ is real number (parameters \c alpha and \c beta),
\f$A\f$ is calling Hermitian matrix and \f$M_1\f$ and \f$M_2\f$ are complex matrices (parameters \c m1 and \c m2).
First operation is performed if \c bTransp passed is \c false and second one otherwise.
Function returns a reference to the matrix changed and throws \ref cvmexception
in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
const tcomplex alpha(2.12,-0.14);
const tcomplex alphac(2.12,0.14);
const treal beta = -3.07;
cmatrix m1(3,3), m2(3,3);
schmatrix mh(3), mh2(3);
m1.randomize_real(-1.,2.);
m1.randomize_imag(-2.,3.);
m2.randomize_real(-1.,2.);
m2.randomize_imag(-2.,3.);
mh.randomize_real(-1.,2.);
mh.randomize_imag(-2.,3.);
mh2 = mh;
mh.her2k(false, alpha, m1, m2, beta);
mh2 = schmatrix(alpha * m1 * ~m2 + alphac * m2 * ~m1, 1.e-14) + beta * mh2;
std::cout << mh - mh2;
\endcode
prints
\code
(+0.00e+000,+4.44e-016) (+0.00e+000,+0.00e+000) (+0.00e+000,+1.78e-015)
(+3.55e-015,+0.00e+000) (+4.44e-016,-8.88e-016) (+0.00e+000,+0.00e+000)
(+8.88e-016,+8.88e-016) (+0.00e+000,+0.00e+000) (+8.88e-016,+1.78e-015)
\endcode
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(2);
const tcomplex alpha(2.12,-0.14);
const tcomplex alphac(2.12,0.14);
const treal beta = -3.07;
cmatrix m1(3,3), m2(3,3);
schmatrix mh(3), mh2(3);
m1.randomize_real(-1.,2.);
m1.randomize_imag(-2.,3.);
m2.randomize_real(-1.,2.);
m2.randomize_imag(-2.,3.);
mh.randomize_real(-1.,2.);
mh.randomize_imag(-2.,3.);
mh2 = mh;
mh.her2k(true, alpha, m1, m2, beta);
mh2 = schmatrix(alpha * ~m1 * m2 + alphac * ~m2 * m1, 1.e-14) + beta * mh2;
std::cout << mh - mh2;
\endcode
prints
\code
(+3.55e-015,-8.88e-016) (+0.00e+000,+0.00e+000) (+0.00e+000,-1.78e-015)
(-8.88e-016,+1.78e-015) (+0.00e+000,-4.44e-016) (+8.88e-016,+0.00e+000)
(+0.00e+000,+3.55e-015) (-1.33e-015,-1.78e-015) (+0.00e+000,+0.00e+000)
\endcode
@see http://www.netlib.org/blas
@param[in] bTransp Use transposed version of the operation.
@param[in] alpha Complex multiplier \f$\alpha\f$.
@param[in] m1 \ref cmatrix \f$M_1\f$.
@param[in] m2 \ref cmatrix \f$M_2\f$.
@param[in] beta Real multiplier \f$\beta\f$.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& her2k(bool bTransp, TC alpha, const BaseCMatrix& m1,
                           const BaseCMatrix& m2, TR beta) {
        if (bTransp) {
            _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.nsize());
            _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.nsize());
            _check_ne(CVM_SIZESMISMATCH, m1.msize(), m2.msize());
        } else {
            _check_ne(CVM_SIZESMISMATCH, this->msize(), m1.msize());
            _check_ne(CVM_SIZESMISMATCH, this->msize(), m2.msize());
            _check_ne(CVM_SIZESMISMATCH, m1.nsize(), m2.nsize());
        }
        __her2k<TR,TC,
            basic_schmatrix>(bTransp, alpha, bTransp ? m1.msize() : m1.nsize(),
                             m1, m1.ld(), m2, m2.ld(), beta, *this);
        this->_flip();
        return *this;
    }

/**
@brief Matrix inversion

This version sets calling matrix to be equal to Hermitian matrix \c m inverted.
Function throws \ref cvmexception in case of inappropriate
sizes of the operands or when the matrix to be inverted is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
schmatrix mi(3);
mi.inv(m);
std::cout << mi << std::endl;
std::cout << mi * m - eye_complex(3);
\endcode
prints
\code
(-1.50e+000,0.00e+000) (-1.67e-016,8.33e-017) (-5.00e-001,-1.00e+000)
(-1.67e-016,-8.33e-017) (-1.00e+000,0.00e+000) (0.00e+000,-1.00e+000)
(-5.00e-001,1.00e+000) (0.00e+000,1.00e+000) (-1.50e+000,0.00e+000)

(2.22e-016,0.00e+000) (1.11e-016,0.00e+000) (2.78e-017,0.00e+000)
(2.78e-016,2.22e-016) (4.44e-016,0.00e+000) (0.00e+000,-4.44e-016)
(2.22e-016,-4.44e-016) (0.00e+000,-8.88e-016) (-2.22e-016,0.00e+000)
\endcode
@param[in] m \ref schmatrix to invert.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& inv(const basic_schmatrix& m) {
        __inv<basic_schmatrix>(*this, m);
        return *this;
    }

/**
@brief Matrix inversion

This version creates \ref schmatrix object equal to a calling Hermitian matrix inverted.
Function throws \ref cvmexception in case of memory allocation failure
or when the matrix to be inverted is close to singular.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
const schmatrix mi = m.inv();
std::cout << mi << std::endl;
std::cout << mi * m - eye_complex(3);
\endcode
prints
\code
(-1.50e+000,0.00e+000) (-1.67e-016,8.33e-017) (-5.00e-001,-1.00e+000)
(-1.67e-016,-8.33e-017) (-1.00e+000,0.00e+000) (0.00e+000,-1.00e+000)
(-5.00e-001,1.00e+000) (0.00e+000,1.00e+000) (-1.50e+000,0.00e+000)

(2.22e-016,0.00e+000) (1.11e-016,0.00e+000) (2.78e-017,0.00e+000)
(2.78e-016,2.22e-016) (4.44e-016,0.00e+000) (0.00e+000,-4.44e-016)
(2.22e-016,-4.44e-016) (0.00e+000,-8.88e-016) (-2.22e-016,0.00e+000)
\endcode
@return Result object.
*/
    basic_schmatrix inv() const {
        basic_schmatrix mRes(this->msize());
        __inv<basic_schmatrix>(mRes, *this);
        return mRes;
    }

/**
@brief Matrix exponent

Computes exponent of Hermitian matrix using Pade approximation defined as
\f[
R_{pq}(z)=D_{pq}(z)^{-1}N_{pq}(z)=1+z+\dots+z^p/p!\,,
\f]
where
\f[\begin{aligned}
N_{pq}(z)&=\sum_{k=0}^p\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}z^k,\\
D_{pq}(z)&=\sum_{k=0}^q\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}(-z)^k
\end{aligned}\f]
along with the matrix normalizing as described in
<em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 572.
Function uses \ref DMEXP (or \ref SMEXP for \c float version)
\c FORTRAN subroutine implementing the algorithm.
This version sets calling matrix to be equal to
exponent of Hermitian matrix \c m and returns a reference to the matrix changed.
The algorithm uses parameter \c tol as \f$\varepsilon(p,q)\f$ in order to choose constants \f$p\f$ and \f$q\f$
so that
\f[
\varepsilon(p,q)\ge 2^{3-(p+q)}\frac{p!q!}{(p+q)!(p+q+1)!}.
\f]
This parameter is equal to the <em>largest relative spacing</em> (see cvmMachSp() ) by default.
Function throws \ref cvmexception in case of
inappropriate sizes of the operands or when LAPACK subroutine fails.
\par Example
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::left |
                std::ios::showpos);
std::cout.precision(15);
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
schmatrix me(3);
me.exp(m);
std::cout << "Column 1" << std::endl
<< me(1,1) << std::endl << me(2,1) << std::endl << me(3,1) << std::endl
          << "Column 2" << std::endl
<< me(1,2) << std::endl << me(2,2) << std::endl << me(3,2) << std::endl
          << "Column 3" << std::endl
<< me(1,3) << std::endl << me(2,3) << std::endl << me(3,3) << std::endl;
\endcode
prints
\code
Column 1
(+2.673228708372002e+002,+1.091141066389412e-014)
(+3.071187567026803e+002,+1.535593783513402e+002)
(-1.749365628720766e+002,+3.498731257441531e+002)
Column 2
(+3.071187567026803e+002,-1.535593783513401e+002)
(+4.422594337092766e+002,+1.919736460939478e-015)
(-9.600094996571151e-015,+5.034325040954932e+002)
Column 3
(-1.749365628720765e+002,-3.498731257441531e+002)
(+6.184072406183948e-015,-5.034325040954932e+002)
(+5.744416275398805e+002,+1.540673883337074e-014)
\endcode
Matlab output:
\code
  Column 1

     2.673228708371998e+002 -7.105427357601002e-015i
     3.071187567026802e+002 +1.535593783513401e+002i
    -1.749365628720764e+002 +3.498731257441527e+002i

  Column 2

     3.071187567026802e+002 -1.535593783513401e+002i
     4.422594337092769e+002 -5.489286670342458e-016i
     3.549798266275454e-015 +5.034325040954932e+002i

  Column 3

    -1.749365628720763e+002 -3.498731257441526e+002i
    -1.776065298147746e-014 -5.034325040954931e+002i
     5.744416275398801e+002 -2.096383162906490e-014i
\endcode
@param[in] m \ref schmatrix to compute exponent for.
@param[in] tol Computation tolerance.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& exp(const basic_schmatrix& m,
                         TR tol = basic_cvmMachSp<TR>()) {
        __exp_symm<basic_schmatrix, TR>(*this, m, tol);
        return *this;
    }

/**
@brief Matrix exponent

Computes exponent of Hermitian matrix using Pade approximation defined as
\f[
R_{pq}(z)=D_{pq}(z)^{-1}N_{pq}(z)=1+z+\dots+z^p/p!\,,
\f]
where
\f[\begin{aligned}
N_{pq}(z)&=\sum_{k=0}^p\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}z^k,\\
D_{pq}(z)&=\sum_{k=0}^q\frac{(p+q-k)!p!}{(p+q)!k!(q-k)!}(-z)^k
\end{aligned}\f]
along with the matrix normalizing as described in
<em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 572.
Function uses \ref DMEXP (or \ref SMEXP for \c float version)
\c FORTRAN subroutine implementing the algorithm.
This version creates an object of type \c schmatrix as exponent of a calling Hermitian matrix.
The algorithm uses parameter \c tol as \f$\varepsilon(p,q)\f$ in order to choose constants \f$p\f$ and \f$q\f$
so that
\f[
\varepsilon(p,q)\ge 2^{3-(p+q)}\frac{p!q!}{(p+q)!(p+q+1)!}.
\f]
This parameter is equal to the <em>largest relative spacing</em> (see cvmMachSp() ) by default.
Function throws \ref cvmexception in case of
inappropriate sizes of the operands or when LAPACK subroutine fails.
\par Example
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::left |
                std::ios::showpos);
std::cout.precision(15);
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
schmatrix me = m.exp();
std::cout << "Column 1" << std::endl
<< me(1,1) << std::endl << me(2,1) << std::endl << me(3,1) << std::endl
          << "Column 2" << std::endl
<< me(1,2) << std::endl << me(2,2) << std::endl << me(3,2) << std::endl
          << "Column 3" << std::endl
<< me(1,3) << std::endl << me(2,3) << std::endl << me(3,3) << std::endl;
\endcode
prints
\code
Column 1
(+2.673228708372002e+002,+1.091141066389412e-014)
(+3.071187567026803e+002,+1.535593783513402e+002)
(-1.749365628720766e+002,+3.498731257441531e+002)
Column 2
(+3.071187567026803e+002,-1.535593783513401e+002)
(+4.422594337092766e+002,+1.919736460939478e-015)
(-9.600094996571151e-015,+5.034325040954932e+002)
Column 3
(-1.749365628720765e+002,-3.498731257441531e+002)
(+6.184072406183948e-015,-5.034325040954932e+002)
(+5.744416275398805e+002,+1.540673883337074e-014)
\endcode
Matlab output:
\code
  Column 1

     2.673228708371998e+002 -7.105427357601002e-015i
     3.071187567026802e+002 +1.535593783513401e+002i
    -1.749365628720764e+002 +3.498731257441527e+002i

  Column 2

     3.071187567026802e+002 -1.535593783513401e+002i
     4.422594337092769e+002 -5.489286670342458e-016i
     3.549798266275454e-015 +5.034325040954932e+002i

  Column 3

    -1.749365628720763e+002 -3.498731257441526e+002i
    -1.776065298147746e-014 -5.034325040954931e+002i
     5.744416275398801e+002 -2.096383162906490e-014i
\endcode
@param[in] tol Computation tolerance.
@return Result object.
*/
    basic_schmatrix exp(TR tol = basic_cvmMachSp<TR>()) const {
        basic_schmatrix msRes(this->msize());
        __exp_symm<basic_schmatrix, TR>(msRes, *this, tol);
        return msRes;
    }

// this = v(1)*I + v(2)*m + v(3)*m^2 + ... + v(N)*m^(N-1)
/**
@brief Matrix polynomial

Computes Hermitian matrix polynomial defined as
\f[
p(A)=b_0I+b_1A+\dots+b_qA^q
\f]
using the Horner's rule:
\f[
\newcommand{\floor}{\operatorname{floor}}p(A)=\sum_{k=0}^r B_k(A^s)^k,\quad s=\floor(\!\sqrt{q}\,),\ r=\floor(q/s)
\f]
where
\f[
B_k=\begin{cases}
\sum\limits_{i=0}^{s-1}b_{sk+i} A^i, & k=0,1,\dots,r-1\\
\sum\limits_{i=0}^{q-sr}b_{sr+i} A^i, & k=r.
\end{cases}
\f]
See also <em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 568.
Real coefficients \f$b_0,b_1,\dots,b_q\f$ are passed in parameter \c v,
where \f$q\f$ is equal to \c v.size()-1, so the function
computes matrix polynomial equal to
\f[
\mathtt{v[1]*I + v[2]*m +\cdots + v[v.size()]*m^{v.size()-1}}
\f]
This version sets calling matrix to be equal to the polynomial of Hermitian matrix \c m.
Function uses \ref ZPOLY (or \ref CPOLY for \c float version) \c FORTRAN subroutine implementing the Horner's algorithm.
Function throws \ref cvmexception in case of inappropriate sizes of the operands.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left |
                std::ios::showpos);
std::cout.precision(10);
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
            0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
double re[]={2.2,1.3,1.1,-0.9,0.2,-0.45,45.,-30.,10.,3.,1.13};
const rvector vr(re, 11);
schmatrix mp(3);

mp.polynom(m, vr);

std::cout << "Column 1" << std::endl
<< mp(1,1) << std::endl << mp(2,1) << std::endl << mp(3,1) << std::endl
          << "Column 2" << std::endl
<< mp(1,2) << std::endl << mp(2,2) << std::endl << mp(3,2) << std::endl
          << "Column 3" << std::endl
<< mp(1,3) << std::endl << mp(2,3) << std::endl << mp(3,3) << std::endl;
\endcode
prints
\code
Column 1
(+1.2319548758e+008,+0.0000000000e+000)
(+1.4179323916e+008,+7.0896619580e+007)
(-8.0802738460e+007,+1.6160547692e+008)
Column 2
(+1.4179323916e+008,-7.0896619580e+007)
(+2.0399822604e+008,+0.0000000000e+000)
(+0.0000000000e+000,+2.3250209650e+008)
Column 3
(-8.0802738460e+007,-1.6160547692e+008)
(+0.0000000000e+000,-2.3250209650e+008)
(+2.6498872674e+008,+0.0000000000e+000)
\endcode
Matlab output:
\code
  Column 1

     1.231954875800000e+008
     1.417932391600000e+008 +7.089661958000000e+007i
    -8.080273845999999e+007 +1.616054769200000e+008i

  Column 2

     1.417932391600000e+008 -7.089661958000000e+007i
     2.039982260400000e+008
                          0 +2.325020965000000e+008i

  Column 3

    -8.080273845999999e+007 -1.616054769200000e+008i
                          0 -2.325020965000000e+008i
     2.649887267400000e+008
\endcode
@param[in] m \ref schmatrix to compute polynomial for.
@param[in] v Real vector of coefficients.
@return Reference to changed calling matrix.
*/
    basic_schmatrix& polynom(const basic_schmatrix& m, const RVector& v) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), m.msize());
        CVector vc(v);
        __polynom<TC, CVector>(this->get(), this->ld(), this->msize(), m._pd(), m._ldm(), vc);
        return *this;
    }

// returns v(1)*I + v(2)*this + v(3)*this^2 + ... + v(N)*this^(N-1)
/**
@brief Matrix polynomial

Computes hemitian matrix polynomial defined as
\f[
p(A)=b_0I+b_1A+\dots+b_qA^q
\f]
using the Horner's rule:
\f[
\newcommand{\floor}{\operatorname{floor}}p(A)=\sum_{k=0}^r B_k(A^s)^k,\quad s=\floor(\!\sqrt{q}\,),\ r=\floor(q/s)
\f]
where
\f[
B_k=\begin{cases}
\sum\limits_{i=0}^{s-1}b_{sk+i} A^i, & k=0,1,\dots,r-1\\
\sum\limits_{i=0}^{q-sr}b_{sr+i} A^i, & k=r.
\end{cases}
\f]
See also <em>Gene H. Golub, Charles F. Van Loan. Matrix Computations, The Johns Hopkins University Press, 1996, 694~p., ISBN 0-8018-5413-X</em>, p. 568.
The coefficients \f$b_0,b_1,\dots,b_q\f$ are passed in parameter \c v,
where \f$q\f$ is equal to \c v.size()-1, so the function
computes matrix polynomial equal to
\f[
\mathtt{v[1]*I + v[2]*m +\cdots + v[v.size()]*m^{v.size()-1}}
\f]
This version creates an object of type \ref schmatrix as the polynomial of hemitian symmetric matrix.
Function uses \ref ZPOLY (or \ref CPOLY for \c float version) \c FORTRAN subroutine implementing the Horner's algorithm.
Function throws \ref cvmexception in case of memory allocation failure.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left |
                std::ios::showpos);
std::cout.precision(10);
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
            0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
double re[]={2.2,1.3,1.1,-0.9,0.2,-0.45,45.,-30.,10.,3.,1.13};
const rvector vr(re, 11);

schmatrix mp = m.polynom(vr);

std::cout << "Column 1" << std::endl
<< mp(1,1) << std::endl << mp(2,1) << std::endl << mp(3,1) << std::endl
          << "Column 2" << std::endl
<< mp(1,2) << std::endl << mp(2,2) << std::endl << mp(3,2) << std::endl
          << "Column 3" << std::endl
<< mp(1,3) << std::endl << mp(2,3) << std::endl << mp(3,3) << std::endl;
\endcode
prints
\code
Column 1
(+1.2319548758e+008,+0.0000000000e+000)
(+1.4179323916e+008,+7.0896619580e+007)
(-8.0802738460e+007,+1.6160547692e+008)
Column 2
(+1.4179323916e+008,-7.0896619580e+007)
(+2.0399822604e+008,+0.0000000000e+000)
(+0.0000000000e+000,+2.3250209650e+008)
Column 3
(-8.0802738460e+007,-1.6160547692e+008)
(+0.0000000000e+000,-2.3250209650e+008)
(+2.6498872674e+008,+0.0000000000e+000)
\endcode
Matlab output:
\code
  Column 1

     1.231954875800000e+008
     1.417932391600000e+008 +7.089661958000000e+007i
    -8.080273845999999e+007 +1.616054769200000e+008i

  Column 2

     1.417932391600000e+008 -7.089661958000000e+007i
     2.039982260400000e+008
                          0 +2.325020965000000e+008i

  Column 3

    -8.080273845999999e+007 -1.616054769200000e+008i
                          0 -2.325020965000000e+008i
     2.649887267400000e+008
\endcode
@param[in] v Real vector of coefficients.
@return Result object.
*/
    basic_schmatrix polynom(const RVector& v) const {
        basic_schmatrix msRes(this->msize());
        CVector vc(v);
        __polynom<TC, CVector>(msRes, msRes.ld(), this->msize(), this->get(), this->ld(), vc);
        return msRes;
    }

/**
@brief Eigenvalues and eigenvectors

Solves symmetric eigenvalue problem and creates \ref rvector object equal to eigenvalues
of a calling Hermitian matrix.
The symmetric eigenvalue problem is defined as follows: given symmetric (Hermitian)
matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
Eigenvalues of Hermitian complex matrix \f$A\f$ are real and eigenvectors are complex.
Function sets output parameter \c mEigVect to be equal to square matrix containing eigenvectors as columns.
Function throws \ref cvmexception
in case of inappropriate calling object sizes or in case of convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
scmatrix me(3);
rvector v(3);

v = m.eig(me);
std::cout << v << std::endl;
cvector vc(v);

std::cout << m * me(1) - me(1) * vc(1);
std::cout << m * me(2) - me(2) * vc(2);
std::cout << m * me(3) - me(3) * vc(3);
// orthogonality check:
std::cout << me(1) % me(2) << std::endl;
std::cout << me(2) % me(3) << std::endl;
std::cout << me(1) % me(3) << std::endl;
\endcode
prints
\code
-8.13e-001 -3.44e-001 7.16e+000

(1.39e-016,2.22e-016) (5.25e-017,-1.11e-016) (1.94e-016,1.67e-016)
(4.86e-016,4.44e-016) (7.63e-017,0.00e+000) (3.33e-016,2.22e-016)
(-2.22e-016,-8.88e-016) (-5.55e-017,-8.88e-016) (8.88e-016,-5.55e-017)
(-5.17e-017,-9.74e-017)
(-5.81e-017,-5.40e-017)
(2.37e-018,-3.56e-017)
\endcode
@see rvector::eig()
@param[out] mEigVect Eigenvectors of a calling symmetric matrix.
@return Result object.
*/
    RVector eig(BaseSCMatrix& mEigVect) const {
        RVector vEig(this->msize());
        // we don't use _eig here since this is the special case - Hermitian matrix
        __eig<RVector, basic_schmatrix, BaseSCMatrix>(vEig, *this, &mEigVect, true);
        return vEig;
    }

/**
@brief Eigenvalues

Solves symmetric eigenvalue problem and creates \ref rvector object equal to eigenvalues
of a calling Hermitian matrix.
The symmetric eigenvalue problem is defined as follows: given symmetric (Hermitian)
matrix \f$A\f$, find the eigenvalues \f$\lambda\f$ and the corresponding
eigenvectors \f$z\f$ that satisfy the equation
\f[
Az = \lambda z.
\f]
Eigenvalues of Hermitian complex matrix \f$A\f$ are real.
Function throws \ref cvmexception
in case of memory allocation failure or convergence error.
\par Example:
\code
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(2);
double a[] = {1., 0., 2., 1., -1., 2., 2., -1., 2., 0.,
              0., 3., -1., -2., 0., -3., 3., 0.};
schmatrix m((std::complex<double>*)a,3);
std::cout << m.eig();
\endcode
prints
\code
-8.13e-001 -3.44e-001 7.16e+000
\endcode
@see rvector::eig()
@return Result object.
*/
    RVector eig() const {
        RVector vEig(this->msize());
        // we don't use _eig here since this is the special case - Hermitian matrix
        __eig<RVector, basic_schmatrix, BaseSCMatrix>(vEig, *this, nullptr, true);
        return vEig;
    }

/**
@brief Cholesky factorization

Forms the Cholesky factorization of Hermitian positive-definite calling matrix \f$A\f$ defined as
\f[
A=U^H U,
\f]
where \f$U\f$ is upper triangular matrix.
It utilizes one of \c ZPOTRF routines of the
\c LAPACK library. Function creates \ref scmatrix object equal to the factorization.
Function throws \ref cvmexception in case of convergence error.
\par Example:
\code
using namespace cvm;
try {
    double a[] = {3., 0., 2., 1., -1., 2., 2., -1., 3., 0.,
                0., 3., -1., -2., 0., -3., 5., 0.};
    const schmatrix m((std::complex<double>*)a,3);
    scmatrix h = m.cholesky();
    std::cout << h << std::endl;
    std::cout << ~h * h - m;
}
catch (std::exception& e) {
    std::cout << "Exception: " << e.what() << std::endl;
}
\endcode
prints
\code
(1.73205,0) (1.1547,-0.57735) (-0.57735,-1.1547)
(0,0) (1.1547,0) (0,-1.1547)
(0,0) (0,0) (1.41421,0)

(-4.44089e-016,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
(0,0) (0,0) (0,0)
\endcode
@see http://www.netlib.org/lapack
@see basic_scmatrix::cholesky()
@return Result object.
*/
    BaseSCMatrix cholesky() const {
        BaseSCMatrix mRes(*this);
        tint nOutInfo = __cholesky<BaseSCMatrix>(mRes);
        _check_negative(CVM_WRONGMKLARG, nOutInfo);
        _check_positive(CVM_NOTPOSITIVEDEFINITE, nOutInfo);
        mRes._clean_low_triangle();
        return mRes;
    }

/**
@brief Bunch-Kaufman factorization

Forms the Bunch-Kaufman factorization of Hermitian calling matrix (cited from the MKL library documentation):
\f[
A=PUDU^HP^H,
\f]
where \f$A\f$ is calling Hermitian matrix,
\f$P\f$ is a permutation matrix, \f$U\f$ and \f$L\f$ are upper and lower triangular
matrices with unit diagonal, and \f$D\f$ is a Hermitian
block-diagonal matrix with 1-by-1 and 2-by-2
diagonal blocks. \f$U\f$ and \f$L\f$ have 2-by-2 unit diagonal
blocks corresponding to the 2-by-2 blocks of \f$D\f$.
It utilizes one of \c ZHETRF routines of the \c LAPACK library.
Function creates \ref scmatrix object equal to the factorization
of Hermitian calling matrix.
Function throws \ref cvmexception in case of convergence error.
Function is mostly designed to be used for subsequent calls
of \c ZHETRS, \c ZHECON and \c ZHETRI routines of the
\c LAPACK library.
Currently it's used internally in \ref det() flow
when argument is symmetric but not positive-definite.

@see http://www.netlib.org/lapack
@see basic_scmatrix::bunch_kaufman()
@param[out] nPivots Pivot indices array.
@return Result object.
*/
    BaseSCMatrix bunch_kaufman(tint* nPivots) const {
        BaseSCMatrix mRes(*this);
        __bunch_kaufman<BaseSCMatrix>(mRes, nPivots);
        return mRes;
    }

    // TODO dox
    basic_schmatrix& identity() {
        this->_vanish();
        this->_plus_plus();
        return *this;
    }

    basic_schmatrix& vanish() {
        this->_vanish();
        return *this;
    }

    basic_schmatrix& randomize_real(TR dFrom, TR dTo) {
        this->_randomize_real(dFrom, dTo);
        return *this;
    }

    basic_schmatrix& randomize_imag(TR dFrom, TR dTo) {
        this->_randomize_imag(dFrom, dTo);
        return *this;
    }

    // infinity-norm - the same as 1-norm for symmetric matrices
    TR norminf() const override {
        return this->norm1();
    }

/**
@brief Is calling Hermitian matrix positive definite?

@return \c true if calling Hermitian matrix is positive definite.
*/
    [[nodiscard]] bool is_positive_definite() const {
        const TR zero = TR(0.);
        const TC* pd = this->_pv();
        const tint nSize = this->_size();
        const tint nNext = this->_msize() + 1;
        CVM_ASSERT(pd, nSize * sizeof(TC))
        for (tint i = 0; i < nSize; i += nNext) {
            if (pd[i].real() <= zero) {  // real numbers on main diagonal
                return false;
            }
        }
        return true;
    }

/**
@brief Matrix equilibration

Useful for further solve and solve_lu calling.

@return \c true if equilibration was needed and performed.
*/
    bool equilibrate(basic_rvector<TR>& vScalings, CVector& vB) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vB.size());
        bool bRes = this->_equilibrate(vScalings);
        if (bRes) {
            for (tint i = 0; i < this->msize(); ++i) {
                vB[i] *= vScalings[i];
            }
        }
        return bRes;
    }

/**
@brief Matrix equilibration

Useful for further solve and solve_lu calling.

@return \c true if equilibration was needed and performed.
*/
    bool equilibrate(basic_rvector<TR>& vScalings, BaseCMatrix& mB) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), mB.msize());
        bool bRes = this->_equilibrate(vScalings);
        if (bRes) {
            for (tint j = 0; j <= mB.nsize(); ++j) {
                for (tint i = 0; i <= this->msize(); ++i) {
                    mB(i, j) *= vScalings[i];
                }
            }
        }
        return bRes;
    }

//! @cond INTERNAL
    // special care for symmetric matrices
    basic_schmatrix& _factorize(const basic_schmatrix& m, tint* nPivots, bool& bPositiveDefinite) {
        (*this) = m;
        tint nOutInfo = __cholesky<BaseSCMatrix>(*this);
        _check_negative(CVM_WRONGMKLARG, nOutInfo);
        if (nOutInfo > 0) {
            (*this) = m;
            __bunch_kaufman<BaseSCMatrix>(*this, nPivots);
            bPositiveDefinite = false;
        } else {
            bPositiveDefinite = true;
        }
        return *this;
    }

    // makes lower triangle to be equal to conjugated upper one
    void _flip() {
        if (this->msize() > 1) {
            const tint nM1 = this->ld() + 1, nM1m = this->ld() - 1, nM2m = this->msize() - 1;
            tint i = 1, j = 1, m;
            for (;;) {
                m = this->msize() - i;
                __copy<TC>(m, this->get() + j + nM1m, this->ld(), this->get() + j, 1);
                __conj<TC>(this->get() + j, m, 1);
                if (i >= nM2m) break;
                ++i;
                j += nM1;
            }
        }
    }

    // redefinition of basic_array's function
    TC* _pd() override {
        return this->get();
    }

    // redefinition of basic_array's function
    const TC* _pd() const override {
        return this->get();
    }

    void _check_submatrix() const override {
        throw cvmexception(CVM_SUBMATRIXNOTAVAILABLE, "schmatrix");
    }

protected:
    const TC* _pp(const BaseMatrix& m) const override {  // for _msum _mdiff etc.
        return m.get();
    }

    // not applicable - see below
    basic_schmatrix& set(TC z) {
        this->_set(z);
        return *this;
    }

    void _set(TC) override {
        throw cvmexception(CVM_BREAKS_HERMITIANITY, "set_real");
    }

    void _randomize_real(TR dFrom, TR dTo) override {
        this->BaseSCMatrix::_randomize_real(dFrom, dTo);
        this->_flip();
        this->_make_main_diag_real();
    }

    void _randomize_imag(TR dFrom, TR dTo) override {
        this->BaseSCMatrix::_randomize_imag(dFrom, dTo);
        this->_flip();
        this->_make_main_diag_real();
    }

    void _transp() override {
        this->_sq_transp();
    }

    //6.1: unlike transp, this one does nothing for Hermitian matrices
    void _conj() override {}

    // returns main diagonal of low_up factorization
    CVector _low_up_diag(basic_array<tint,tint>&) const override {
        // well, this stuff is useless for symmetric matrices. 
        // this call would mean serious CVM internal error
        throw cvmexception(CVM_NOTIMPLEMENTED, "_low_up_diag");
    }

    void _scalr(TR d) override {
        __scal<TR,TC>(this->get(), this->size(), this->incr(), d);
    }

    void _scalc(TC d) override {
        __scal<TC,TC>(this->get(), this->size(), this->incr(), d);
    }

    void _multiply(CVector& vRes, const CVector& v, bool bLeft) const override {
        // 6.1 fix for left-sided multiplication
        if (bLeft) {
            BaseCMatrix::_multiply(vRes, v, bLeft);
        } else {
            CVector vTmp;
            basic_schmatrix mTmp;
            const TR zero = TR(0.);
            const TR one = TR(1.);
            const TC* pDm = this->get();
            const TC* pDv = v;
            if (vRes.get() == pDv) vTmp << v;
            if (vRes.get() == pDm) mTmp << *this;
            __shmv<TC, basic_schmatrix, CVector>(vRes.get() == pDm ? mTmp : *this, one,
                                                 vRes.get() == pDv ? vTmp : v, zero, vRes);
        }
    }

    // sets both elements to keep matrix Hermitian, checks ranges
    void _set_at(tint nRow, tint nCol, TC val) {
        _check_lt_ge(CVM_OUTOFRANGE_LTGE1, nRow, tint(), this->msize());
        _check_lt_ge(CVM_OUTOFRANGE_LTGE2, nCol, tint(), this->nsize());
        // only reals on main diagonal
        if (nRow == nCol && std::abs(val.imag()) > basic_cvmMachMin<TR>()) {
            throw cvmexception(CVM_BREAKS_HERMITIANITY, "real number");
        }
        this->get()[this->ld() * nCol + nRow] = val;
        if (nRow != nCol) {
            this->get()[this->ld() * nRow + nCol] = std::conj(val);
        }
    }

    void _check_hermitian(TR tol) const {
        TR discr;
        TC c1, c2;
        for (tint j = 0; j < this->nsize(); ++j) {
            for (tint i = 0; i < this->msize(); ++i) {
                if (i == j) {
                    discr = std::abs(this->get()[this->ld() * j + i].imag());
                    if (discr > tol) {  // real numbers on main diagonal
                        throw cvmexception(CVM_MATRIXNOTHERMITIAN, discr, tol);
                    }
                    continue;
                }
                c1 = this->get()[this->ld() * j + i];
                c2 = this->get()[this->ld() * i + j];
                if (!_conjugated<TR>(c1, c2, tol)) {
                    throw cvmexception(CVM_NOT_CONJUGATED,
                                       c1.real(), c1.imag(),
                                       c2.real(), c2.imag(), tol);
                }
            }
        }
    }

    void _solve(const CVector& vB, CVector& vX, TR& dErr,
                const TC* pLU, const tint* pPivots,
                int transp_mode) const override {
        // 6.1: fix for non-positive definite solutions
        // (we also need to call base version for transposed mode)
        if (transp_mode == 1 || !this->is_positive_definite()) {
            BaseSCMatrix::_solve(vB, vX, dErr, pLU, pPivots, transp_mode);
            return;
        }
        CVector vB1(vB);  // to make sure incr = 1 and equilibrate
        basic_rvector<TR> vScalings(this->msize());
        basic_schmatrix m(*this);
        const bool bEquilibrated = m.equilibrate(vScalings, vB1);
        CVector vX1(vB1);  // to make sure incr = 1
        __solve<TR,TC,
            basic_schmatrix>(m, 1, vB1, vB1.size(), vX1, vX1.size(),
                             dErr, pLU, pPivots, 0);  // no transpose

        if (bEquilibrated) {
            for (tint i = 0; i <= this->msize() - 1; ++i) {
                vX[i] = vX1[i] * vScalings[i];
            }
        } else {
            vX = vX1;
        }
    }

    void _solve(const BaseCMatrix& mB, BaseCMatrix& mX, TR& dErr,
                const TC* pLU, const tint* pPivots,
                int transp_mode) const override {
        // 6.1: fix for non-positive definite solutions
        // (we also need to call base version for transposed mode)
        if (transp_mode == 1 || !this->is_positive_definite()) {
            BaseSCMatrix::_solve(mB, mX, dErr, pLU, pPivots, transp_mode);
            return;
        }
        BaseCMatrix mB1(mB);  // to equilibrate
        basic_rvector<TR> vScalings(this->msize());
        basic_schmatrix m(*this);
        const bool bEquilibrated = m.equilibrate(vScalings, mB1);
        mX = mB1;
        __solve<TR,TC,
            basic_schmatrix>(m, mB.nsize(), mB, mB.ld(), mX, mX.ld(),
                             dErr, pLU, pPivots, 0);  // no transpose
        if (bEquilibrated) {
            for (tint j = 0; j < mX.nsize(); ++j) {
                for (tint i = 0; i < this->msize(); ++i) {
                    mX(i, j) *= vScalings[i];
                }
            }
        }
    }

    // matrix determinant
    TC _det() const override {
        TC dDet = TC(0.);
        switch (this->msize()) {
        case 0:
            break;
        case 1:
            dDet = this->_ij_val(0, 0);
            break;
        case 2:
            dDet = this->_ij_val(0, 0) * this->_ij_val(1, 1) -
               this->_ij_val(1, 0) * this->_ij_val(0, 1);
            break;
        default:
            try {
                const TC one(1., 0.);
                bool bPositiveDefinite = false;
                basic_schmatrix m(this->msize());
                basic_array<tint,tint> nPivots(this->msize());
                m._factorize(*this, nPivots, bPositiveDefinite);

                tint i;
                dDet = one;
                if (bPositiveDefinite) {
                    const CVector vUpDiag = m.diag(0);
                    for (i = 0; i < this->msize(); ++i) {
                        dDet *= vUpDiag[i] * vUpDiag[i];  // here we use Cholesky factorization
                    }
                } else {
                    const basic_rvector<TR> vEig = this->eig();
                    for (i = 0; i < this->msize(); ++i) {
                        dDet *= vEig[i];  // here we use eigenvalues (might be better way)
                    }
                }
            }
            catch (const cvmexception& e) {
                if (e.cause() != CVM_WRONGBUNCHKAUFMANFACTOR) throw e;
            }
            break;
        }
        return dDet;
    }

    // matrix equilibration helper
    bool _equilibrate(basic_rvector<TR>& vScalings) {
        _check_ne(CVM_SIZESMISMATCH, this->msize(), vScalings.size());
        bool bRes = false;
        TR dCond = TR();
        TR dMax  = TR();
        const TR sp = basic_cvmMachSp<TR>();
        const TR sp_inv = TR(1.) / sp;

        __poequ<TR,basic_schmatrix, basic_rvector<TR>> (*this, vScalings, dCond, dMax);

        if (dCond < TR(0.1) || std::abs(dMax) <= sp || std::abs(dMax) >= sp_inv) {
            bRes = true;
            for (tint i = 0; i < this->msize(); ++i) {
                for (tint j = i; j < this->msize(); ++j) {
                    this->get()[this->ld() * j + i] *= vScalings[i] * vScalings[j];
                }
            }
        }
        return bRes;
    }

    void _make_main_diag_real() {
        const TR zero = TR(0.);
        __scal<TR,TR>(__get_imag_p<TR>(this->get()), this->msize(), (this->ld() + 1) * 2, zero);
    }

    void _check_gerc()          override { throw cvmexception(CVM_METHODNOTAVAILABLE, "gerc", "schmatrix");}
    void _check_geru()          override { throw cvmexception(CVM_METHODNOTAVAILABLE, "geru", "schmatrix");}
    void _check_rank1update_c() override { throw cvmexception(CVM_METHODNOTAVAILABLE, "rank1update_c", "schmatrix");}
    void _check_rank1update_u() override { throw cvmexception(CVM_METHODNOTAVAILABLE, "rank1update_u", "schmatrix");}
    void _check_gemm()          override { throw cvmexception(CVM_METHODNOTAVAILABLE, "gemm", "schmatrix");}
    void _swap_rows(tint, tint) override { throw cvmexception(CVM_METHODNOTAVAILABLE, "swap_rows", "schmatrix");}
    void _swap_cols(tint, tint) override { throw cvmexception(CVM_METHODNOTAVAILABLE, "swap_cols", "schmatrix");}
    void _set_imag_number(TR)   override { throw cvmexception(CVM_METHODNOTAVAILABLE, "set_imag", "schmatrix");}
//! @endcond
};


//! Left-sided scalar multiplication
template<typename TR>
inline basic_rvector<TR> operator * (TR d, const basic_rvector<TR>& v) {
    return v * d;
}
//! Left-sided scalar multiplication
template<typename TR>
inline basic_rmatrix<TR> operator * (TR d, const basic_rmatrix<TR>& m) {
    return m * d;
}
//! Left-sided scalar multiplication
template<typename TR>
inline basic_srmatrix<TR> operator * (TR d, const basic_srmatrix<TR>& m) {
    return m * d;
}
//! Left-sided scalar multiplication
template<typename TR>
inline basic_srbmatrix<TR> operator * (TR d, const basic_srbmatrix<TR>& m) {
    return m * d;
}
//! Left-sided scalar multiplication
template<typename TR>
inline basic_srsmatrix<TR> operator * (TR d, const basic_srsmatrix<TR>& m) {
    return m * d;
}

//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_cvector<TR,TC> operator * (TR d, const basic_cvector<TR,TC>& v) {
    return v * d;
}
//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_cmatrix<TR,TC> operator * (TR d, const basic_cmatrix<TR,TC>& m) {
    return m * d;
}
//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_scmatrix<TR,TC> operator * (TR d, const basic_scmatrix<TR,TC>& m) {
    return m * d;
}
//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_scbmatrix<TR,TC> operator * (TR d, const basic_scbmatrix<TR,TC>& m) {
    return m * d;
}
//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_schmatrix<TR,TC> operator * (TR d, const basic_schmatrix<TR,TC>& m) {
    return m * d;
}

//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_cvector<TR,TC> operator * (std::complex<TR> c, const basic_cvector<TR,TC>& v) {
    return v * c;
}
//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_cmatrix<TR,TC> operator * (std::complex<TR> c, const basic_cmatrix<TR,TC>& m) {
    return m * c;
}
//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_scmatrix<TR,TC> operator * (std::complex<TR> c, const basic_scmatrix<TR,TC>& m) {
    return m * c;
}
//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_scbmatrix<TR,TC> operator * (std::complex<TR> c, const basic_scbmatrix<TR,TC>& m) {
    return m * c;
}
//! Left-sided scalar multiplication (hermiticity gets lost here)
template<typename TR, typename TC>
inline basic_scmatrix<TR,TC> operator * (std::complex<TR> c, const basic_schmatrix<TR,TC>& m) {
    return m * c;
}

//! Left-sided scalar multiplication
template<typename TR>
inline basic_rvector<TR> operator * (CVM_LONGEST_INT d, const basic_rvector<TR>& v) {
    return v * static_cast<TR>(d);
}
//! Left-sided scalar multiplication
template<typename TR>
inline basic_rmatrix<TR> operator * (CVM_LONGEST_INT d, const basic_rmatrix<TR>& m) {
    return m * static_cast<TR>(d);
}
//! Left-sided scalar multiplication
template<typename TR>
inline basic_srmatrix<TR> operator * (CVM_LONGEST_INT d, const basic_srmatrix<TR>& m) {
    return m * static_cast<TR>(d);
}
//! Left-sided scalar multiplication
template<typename TR>
inline basic_srbmatrix<TR> operator * (CVM_LONGEST_INT d, const basic_srbmatrix<TR>& m) {
    return m * static_cast<TR>(d);
}
//! Left-sided scalar multiplication
template<typename TR>
inline basic_srsmatrix<TR> operator * (CVM_LONGEST_INT d, const basic_srsmatrix<TR>& m) {
    return m * static_cast<TR>(d);
}

//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_cvector<TR,TC> operator * (CVM_LONGEST_INT d, const basic_cvector<TR,TC>& v) {
    return v * static_cast<TR>(d);
}
//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_cmatrix<TR,TC> operator * (CVM_LONGEST_INT d, const basic_cmatrix<TR,TC>& m) {
    return m * static_cast<TR>(d);
}
//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_scmatrix<TR,TC> operator * (CVM_LONGEST_INT d, const basic_scmatrix<TR,TC>& m) {
    return m * static_cast<TR>(d);
}
//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_scbmatrix<TR,TC> operator * (CVM_LONGEST_INT d, const basic_scbmatrix<TR,TC>& m) {
    return m * static_cast<TR>(d);
}
//! Left-sided scalar multiplication
template<typename TR, typename TC>
inline basic_schmatrix<TR,TC> operator * (CVM_LONGEST_INT d, const basic_schmatrix<TR,TC>& m) {
    return m * static_cast<TR>(d);
}


#if defined(CVM_FLOAT)
using treal = float;  //!< Either \c double (default) of \c float (when \c CVM_FLOAT is defined)
#else
using treal = double;  //!< Either \c double (default) of \c float (when \c CVM_FLOAT is defined)
#endif

using tcomplex = std::complex<treal>;  //!< Complex number defined as \c std::complex<treal> (see also \ref treal)

using iarray = basic_array<tint,tint>;  //!< End-user class: array of integers, see \ref basic_array
using rvector = basic_rvector<treal>;  //!< End-user class: vector of \ref treal numbers, see \ref basic_rvector
using rmatrix = basic_rmatrix<treal>;  //!< End-user class: matrix of \ref treal numbers, see \ref basic_rmatrix
using srmatrix = basic_srmatrix<treal>;  //!< End-user class: square matrix of \ref treal numbers, see \ref basic_srmatrix
using cvector = basic_cvector<treal,tcomplex>;  //!< End-user class: vector of \ref treal complex numbers, see \ref basic_cvector
using cmatrix = basic_cmatrix<treal,tcomplex>;  //!< End-user class: matrix of \ref treal complex numbers, see \ref basic_cmatrix
using scmatrix = basic_scmatrix<treal,tcomplex>;  //!< End-user class: square matrix of \ref treal complex numbers, see \ref basic_scmatrix
using srbmatrix = basic_srbmatrix<treal>;  //!< End-user class: square band matrix of \ref treal numbers, see \ref basic_srbmatrix
using scbmatrix = basic_scbmatrix<treal,tcomplex>;  //!< End-user class: square band matrix of \ref treal complex numbers, see \ref basic_scbmatrix
using srsmatrix = basic_srsmatrix<treal>;  //!< End-user class: square symmetric matrix of \ref treal numbers, see \ref basic_srsmatrix
using schmatrix = basic_schmatrix<treal,tcomplex>;  //!< End-user class: square Hermitian matrix of \ref treal complex numbers, see \ref basic_schmatrix

using rvector32 = basic_rvector<float>;  //!< End-user class: vector of 32-bit float numbers, see \ref basic_rvector
using rmatrix32 = basic_rmatrix<float>;  //!< End-user class: matrix of 32-bit float numbers, see \ref basic_rmatrix
using srmatrix32 = basic_srmatrix<float>;  //!< End-user class: square matrix of 32-bit float numbers, see \ref basic_srmatrix
using cvector32 = basic_cvector<float,std::complex<float>>;  //!< End-user class: vector of 32-bit float complex numbers, see \ref basic_cvector
using cmatrix32 = basic_cmatrix<float,std::complex<float>>;  //!< End-user class: matrix of 32-bit float complex numbers, see \ref basic_cmatrix
using scmatrix32 = basic_scmatrix<float,std::complex<float>>;  //!< End-user class: square matrix of 32-bit float complex numbers, see \ref basic_scmatrix
using srbmatrix32 = basic_srbmatrix<float>;  //!< End-user class: square band matrix of 32-bit float numbers, see \ref basic_srbmatrix
using scbmatrix32 = basic_scbmatrix<float,std::complex<float>>;  //!< End-user class: square band matrix of 32-bit float complex numbers, see \ref basic_scbmatrix
using srsmatrix32 = basic_srsmatrix<float>;  //!< End-user class: square symmetric matrix of 32-bit float numbers, see \ref basic_srsmatrix
using schmatrix32 = basic_schmatrix<float,std::complex<float>>;  //!< End-user class: square Hermitian matrix of 32-bit float complex numbers, see \ref basic_schmatrix

using rvector64 = basic_rvector<double>;  //!< End-user class: vector of 64-bit double numbers, see \ref basic_rvector
using rmatrix64 = basic_rmatrix<double>;  //!< End-user class: matrix of 64-bit double numbers, see \ref basic_rmatrix
using srmatrix64 = basic_srmatrix<double>;  //!< End-user class: square matrix of 64-bit double numbers, see \ref basic_srmatrix
using cvector64 = basic_cvector<double,std::complex<double>>;  //!< End-user class: vector of 64-bit double complex numbers, see \ref basic_cvector
using cmatrix64 = basic_cmatrix<double,std::complex<double>>;  //!< End-user class: matrix of 64-bit double complex numbers, see \ref basic_cmatrix
using scmatrix64 = basic_scmatrix<double,std::complex<double>>;  //!< End-user class: square matrix of 64-bit double complex numbers, see \ref basic_scmatrix
using srbmatrix64 = basic_srbmatrix<double>;  //!< End-user class: square band matrix of 64-bit double numbers, see \ref basic_srbmatrix
using scbmatrix64 = basic_scbmatrix<double,std::complex<double>>;  //!< End-user class: square band matrix of 64-bit double complex numbers, see \ref basic_scbmatrix
using srsmatrix64 = basic_srsmatrix<double>;  //!< End-user class: square symmetric matrix of 64-bit double numbers, see \ref basic_srsmatrix
using schmatrix64 = basic_schmatrix<double,std::complex<double>>;  //!< End-user class: square Hermitian matrix of 64-bit double complex numbers, see \ref basic_schmatrix

//! Real identity matrix
template<typename TR>
inline const basic_srmatrix<TR> basic_eye_real(tint nM) {
    basic_srmatrix<TR> mI(nM);
    ++mI;
    return mI;
}
//! Complex identity matrix
template<typename TR, typename TC>
inline const basic_scmatrix<TR,TC> basic_eye_complex(tint nM) {
    basic_scmatrix<TR,TC> mI(nM);
    ++mI;
    return mI;
}

//! Real identity matrix
inline srmatrix eye_real(tint nM) {
    return basic_eye_real<treal>(nM);
}
//! Complex identity matrix
inline scmatrix eye_complex(tint nM) {
    return basic_eye_complex<treal, tcomplex>(nM);
}

//! Float 32-bit identity matrix
inline srmatrix32 eye_real32(tint nM) {
    return basic_eye_real<float>(nM);
}
//! Complex float 32-bit identity matrix
inline scmatrix32 eye_complex32(tint nM) {
    return basic_eye_complex<float, std::complex<float>>(nM);
}

//! Float 64-bit identity matrix
inline srmatrix64 eye_real64(tint nM) {
    return basic_eye_real<double>(nM);
}
//! Complex float 64-bit identity matrix
inline scmatrix64 eye_complex64(tint nM) {
    return basic_eye_complex<double, std::complex<double>>(nM);
}


/**
@brief The smallest normalized positive number

Returns the smallest normalized positive number, i.e. \c numeric_limits<treal>::min().
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(15);
std::cout << cvmMachMin() << std::endl;
\endcode
on Intel Pentium III machine prints
\code
+2.225073858507201e-308
\endcode
@see cvmMachSp()
@return treal The number
*/
inline treal cvmMachMin() {
    return basic_cvmMachMin<treal>();
}

//! The smallest normalized positive number for 32-bit float, see \ref cvmMachMin
inline float cvmMachMin32() {
    return basic_cvmMachMin<float>();
}

//! The smallest normalized positive number for 64-bit float, see \ref cvmMachMin
inline double cvmMachMin64() {
    return basic_cvmMachMin<double>();
}


/**
@brief The largest relative spacing

Returns the largest relative spacing, i.e. the difference between \c 1
and the least value greater than \c 1 that is representable,
i.e. \c numeric_limits<treal>::epsilon().
\par Example:
\code
using namespace cvm;

std::cout.setf(std::ios::scientific | std::ios::showpos);
std::cout.precision(15);
std::cout << cvmMachSp() << std::endl;
\endcode
on Intel Pentium III machine prints
\code
+2.220446049250313e-016
\endcode
@see cvmMachMin()
@return treal The number
*/
inline treal cvmMachSp() {
    return basic_cvmMachSp<treal>();
}

//! The largest relative spacing for 32-bit float, see \ref cvmMachSp
inline float cvmMachSp32() {
    return basic_cvmMachSp<float>();
}

//! The largest relative spacing for 64-bit float, see \ref cvmMachSp
inline double cvmMachSp64() {
    return basic_cvmMachSp<double>();
}
            

//! @cond INTERNAL
#if !defined(CVM_STD_MUTEX) || defined(CVM_USE_POOL_MANAGER)

class CriticalSection
{
#if defined(CVM_MT)
private:
    bool mbOK;

#if defined(WIN32) || defined(_WIN32)
#if defined(CVM_USE_CRITICAL_SECTION_NOT_MUTEX)
    ::CRITICAL_SECTION mCriticalSection;
#else
    HANDLE mMutex;
#endif
#else  // POSIX Threads library assumed
    pthread_mutex_t mMutex;
    pthread_mutexattr_t mMutexAttr;
#endif
#endif

public:
    CriticalSection();
    ~CriticalSection();

    void enter();
    void leave();
};

class Lock
{
    CriticalSection& mcs;
public:
    explicit Lock(CriticalSection& cs) : mcs(cs) {
        mcs.enter();
    }
    ~Lock() {
        mcs.leave();
    }
private:
    Lock& operator = (const Lock&) {
        return *this;
    }
};
#endif
//! @endcond


template<typename T, typename TR>
inline std::complex<TR> operator + (T re, const std::complex<TR>& c) {
    return { static_cast<TR>(re) + c.real(), c.imag() };
}

template<typename T, typename TR>
inline std::complex<TR> operator - (T re, const std::complex<TR>& c) {
    return { static_cast<TR>(re) - c.real(), - c.imag() };
}

template<typename T, typename TR>
inline std::complex<TR> operator + (const std::complex<TR>& c, const T& re) {
    return { c.real() + static_cast<TR>(re), c.imag() };
}

template<typename T, typename TR>
inline std::complex<TR> operator - (const std::complex<TR>& c, const T& re) {
    return { c.real() - static_cast<TR>(re), c.imag() };
}

CVM_NAMESPACE_END

namespace std {  // NOLINT

template<typename T, typename TR>
inline TR real(const CVM_NAMESPACE::type_proxy<T,TR>& p) {
    return real(p.val());
}

template<typename T, typename TR>
inline TR imag(const CVM_NAMESPACE::type_proxy<T,TR>& p) {
    return imag(p.val());
}

template<typename T, typename TR>
inline TR abs(const CVM_NAMESPACE::type_proxy<T,TR>& p) {
    return abs(p.val());
}

template<typename T, typename TR>
inline TR arg(const CVM_NAMESPACE::type_proxy<T,TR>& p) {
    return arg(p.val());
}

template<typename T, typename TR>
inline TR norm(const CVM_NAMESPACE::type_proxy<T,TR>& p) {
    return norm(p.val());
}

template<typename T, typename TR>
inline T pow(const CVM_NAMESPACE::type_proxy<T,TR>& x,
             const CVM_NAMESPACE::type_proxy<T,TR>& y) {
    return pow(x.val(), y.val());
}

template<typename T, typename TR>
inline T pow(const TR& x,
             const CVM_NAMESPACE::type_proxy<T,TR>& y) {
    return pow(x, y.val());
}

template<typename T, typename TR>
inline T pow(const CVM_NAMESPACE::type_proxy<T,TR>& x,
             const TR& y) {
    return pow(x.val(), y);
}

#define CVM_STD_COMPLEX_PROXY(f) \
    template<typename T, typename TR> \
    inline T f(const CVM_NAMESPACE::type_proxy<T,TR>& p) { \
        return f(p.val()); \
    }

CVM_STD_COMPLEX_PROXY(conj)
CVM_STD_COMPLEX_PROXY(proj)
CVM_STD_COMPLEX_PROXY(exp)
CVM_STD_COMPLEX_PROXY(log)
CVM_STD_COMPLEX_PROXY(log10)
CVM_STD_COMPLEX_PROXY(sqrt)
CVM_STD_COMPLEX_PROXY(sin)
CVM_STD_COMPLEX_PROXY(cos)
CVM_STD_COMPLEX_PROXY(tan)
CVM_STD_COMPLEX_PROXY(asin)
CVM_STD_COMPLEX_PROXY(acos)
CVM_STD_COMPLEX_PROXY(atan)
CVM_STD_COMPLEX_PROXY(sinh)
CVM_STD_COMPLEX_PROXY(cosh)
CVM_STD_COMPLEX_PROXY(tanh)
CVM_STD_COMPLEX_PROXY(asinh)
CVM_STD_COMPLEX_PROXY(acosh)
CVM_STD_COMPLEX_PROXY(atanh)

}  // namespace std


//! BLAS callback error handler, don't use
#if !defined(_MSC_VER)
#   define XERBLA xerbla_
#endif

extern "C"
{
    void __stdcall XERBLA(const char* szSubName,
#if defined(CVM_PASS_STRING_LENGTH_TO_FTN_SUBROUTINES)
                          const tint nLen,
#endif
                          const tint* pnParam);
}

#endif  // _CVM_H
