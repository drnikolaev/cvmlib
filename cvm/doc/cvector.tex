\bigskip
\noindent
\verb"template <typename TR, typename TC>"\\
\verb"class cvector : public Array<TR,TC> {"\\
\verb"public:"\\
\verb"    "\GOT{cvector}{cvector.cvector ()}\verb" ();"\\
\verb"    explicit "\GOT{cvector}{cvector.cvector (int)}\verb" (int nSize);"\\
\verb"    "\GOT{cvector}{cvector (std::initializerlist)}\verb" (std::initializer_list<TC> list);"\\
\verb"    "\GOT{cvector}{cvector.cvector (int, TC)}\verb" (int nSize, TC c);"\\
\verb"    "\GOT{cvector}{cvector.cvector (TC*,int,int)}\verb" (TC* pD, int nSize, int nIncr = 1);"\\
\verb"    "\GOT{cvector}{cvector.cvector (const TC*,int,int)}\verb" (const TC* pD, int nSize, int nIncr = 1);"\\
\verb"    "\GOT{cvector}{cvector.cvector (const cvector&)}\verb" (const cvector& v);"\\
\verb"    "\GOT{cvector}{cvector.cvector (TR*,TR*,int,int,int)}\verb" (const TR* pRe, const TR* pIm, int nSize,"\\
\verb"             tint nIncrRe = 1, tint nIncrIm = 1);"\\
\verb"    "\GOT{cvector}{cvector.cvector (const rvector&, const rvector&)}\verb" (const rvector& vRe, const rvector& vIm);"\\
\verb"    "\GOT{cvector}{cvector.cvector (const TR*,int,bool,int)}\verb" (const TR* pA, int nSize,"\\
\verb"             bool bRealPart = true, int nIncr = 1);"\\
\verb"    explicit "\GOT{cvector}{cvector.cvector (const rvector&,bool)}\verb" (const rvector& v, bool bRealPart = true);"\\
\verb"    rvector "\GOT{real}{cvector.real}\verb" ();"\\
\verb"    rvector "\GOT{imag}{cvector.imag}\verb" ();"\\
\verb"    cvector& "\GOT{operator =}{cvector.operator = (const cvector&)}\verb" (const cvector& v) throw (cvmexception);"\\
\verb"    cvector& "\GOT{assign}{cvector.assign (const TC*, int)}\verb" (const TC* p, int nIncr = 1);"\\
\verb"    cvector& "\GOT{assign}{cvector.assign (int, const TC*, int)}\verb" (int n, const TC* p, int nIncr = 1);"\\
\verb"    cvector& "\GOT{assign}{cvector.assign (int, const TC*, int, int)}\verb" (int n, const TC* p, int nSize, tint nIncr);"\\
\verb"    cvector& "\GOT{assign}{cvector.assign (int, const cvector&)}\verb" (int n, const cvector& v) throw (cvmexception);"\\
\verb"    cvector& "\GOT{set}{cvector.set (TC)}\verb" (TC x);"\\
\verb"    cvector& "\GOT{assign\_real}{cvector.assignreal}\verb" (const rvector& vRe) throw (cvmexception);"\\
\verb"    cvector& "\GOT{assign\_imag}{cvector.assignimag}\verb" (const rvector& vIm) throw (cvmexception);"\\
\verb"    cvector& "\GOT{set\_real}{cvector.setreal}\verb" (TR x);"\\
\verb"    cvector& "\GOT{set\_imag}{cvector.setimag}\verb" (TR x);"\\
\verb"    cvector& "\GOT{resize}{cvector.resize}\verb" (int nNewSize) throw (cvmexception);"\\
\verb"    bool "\GOT{operator ==}{cvector.operator ==}\verb" (const cvector& v) const;"\\
\verb"    bool "\GOT{operator !=}{cvector.operator !=}\verb" (const cvector& v) const;"\\
\verb"    cvector& "\GOT{operator <{}<}{cvector.operator <<}\verb" (const cvector& v) throw (cvmexception);"\\
\verb"    cvector "\GOT{operator +}{cvector.operator +}\verb" (const cvector& v) const throw (cvmexception);"\\
\verb"    cvector "\GOT{operator -}{cvector.operator -}\verb" (const cvector& v) const throw (cvmexception);"\\
\verb"    cvector& "\GOT{sum}{cvector.sum}\verb" (const cvector& v1,"\\
\verb"                  const cvector& v2) const throw (cvmexception);"\\
\verb"    cvector& "\GOT{diff}{cvector.diff}\verb" (const cvector& v1,"\\
\verb"                   const cvector& v2) const throw (cvmexception);"\\
\verb"    cvector& "\GOT{operator +=}{cvector.operator +=}\verb" (const cvector& v) throw (cvmexception);"\\
\verb"    cvector& "\GOT{operator -=}{cvector.operator -=}\verb" (const cvector& v) throw (cvmexception);"\\
\verb"    cvector "\GOT{operator -}{cvector.operator - ()}\verb" () const throw (cvmexception);"\\
\verb"    cvector "\GOT{operator *}{cvector.operator * (TR)}\verb" (TR d) const;"\\
\verb"    cvector "\GOT{operator /}{cvector.operator / (TR)}\verb" (TR d) const throw (cvmexception);"\\
\verb"    cvector "\GOT{operator *}{cvector.operator * (TC)}\verb" (TC c) const;"\\
\verb"    cvector "\GOT{operator /}{cvector.operator / (TC)}\verb" (TC c) const throw (cvmexception);"\\
\verb"    cvector& "\GOT{operator *=}{cvector.operator *= (TR)}\verb" (TR d);"\\
\verb"    cvector& "\GOT{operator /=}{cvector.operator /= (TR)}\verb" (TR d) throw (cvmexception);"\\
\verb"    cvector& "\GOT{operator *=}{cvector.operator *= (TC)}\verb" (TC c);"\\
\verb"    cvector& "\GOT{operator /=}{cvector.operator /= (TC)}\verb" (TC c) throw (cvmexception);"\\
\verb"    cvector& "\GOT{normalize}{cvector.normalize}\verb" ();"\\
% ul9 font first time to be used here
\verb"    cvector "\GOT{operator \TildaT}{cvector.conjugation}\verb"() const throw (cvmexception);"\\
\verb"    cvector& "\GOT{conj}{cvector.conjugation}\verb" (const cvector& v) throw (cvmexception);"\\
\verb"    cvector& "\GOT{conj}{cvector.conjugation}\verb" ();"\\
\verb"    TC "\GOT{operator *}{cvector.operator * (const cvector&)}\verb" (const cvector& v) const throw (cvmexception);"\\
\verb"    TC "\GOT{operator \%}{cvector.operator pcent}\verb" (const cvector& v) const throw (cvmexception);"\\
\verb"    cvector "\GOT{operator *}{cvector.operator * (const cmatrix&)}\verb" (const cvector& v) const throw (cvmexception);"\\
\verb"    cvector& "\GOT{mult}{cvector.mult (const cvector&, const cmatrix&)}\verb" (const cvector& v, const cmatrix& m)"\\
\verb"                   throw (cvmexception);"\\
\verb"    cvector& "\GOT{mult}{cvector.mult (const cmatrix&, const cvector&)}\verb" (const cmatrix& m, const cvector& v)"\\
\verb"                   throw (cvmexception);"\\
\verb"    cmatrix "\GOT{rank1update\_u}{cvector.rank1update_u}\verb" (const cvector& v) const;"\\
\verb"    cmatrix "\GOT{rank1update\_c}{cvector.rank1update_c}\verb" (const cvector& v) const;"\\
\verb"    cvector& "\GOT{solve}{cvector.solve}\verb" (const scmatrix& mA,"\\
\verb"                    const cvector& vB, TR& dErr) throw (cvmexception);"\\
\verb"    cvector& "\GOT{solve}{cvector.solve}\verb" (const scmatrix& mA,"\\
\verb"                    const cvector& vB) throw (cvmexception);"\\
\verb"    rvector& "\GOT{solve\_tran}{cvector.solvetran}\verb" (const scmatrix& mA,"\\
\verb"                         const cvector& vB, TR& dErr)"\\
\verb"                         throw (cvmexception);"\\
\verb"    rvector& "\GOT{solve\_tran}{cvector.solvetran}\verb" (const scmatrix& mA,"\\
\verb"                         const cvector& vB) throw (cvmexception);"\\
\verb"    rvector& "\GOT{solve\_conj}{cvector.solveconj}\verb" (const scmatrix& mA,"\\
\verb"                         const cvector& vB, TR& dErr)"\\
\verb"                         throw (cvmexception);"\\
\verb"    rvector& "\GOT{solve\_conj}{cvector.solveconj}\verb" (const scmatrix& mA,"\\
\verb"                         const cvector& vB) throw (cvmexception);"\\
\verb"    rvector "\GOT{operator /}{cvector.operator / (scmatrix)}\verb" (const scmatrix& mA) const throw (cvmexception);"\\
\verb"    rvector "\GOT{operator \%}{cvector.operator percent (scmatrix)}\verb" (const scmatrix& mA) const throw (cvmexception);"\\
\verb"    cvector& "\GOT{solve\_lu}{cvector.solvelu}\verb" (const scmatrix& mA, const scmatrix& mLU,"\\
\verb"                       const int* pPivots, const cvector& vB, TR& dErr)"\\
\verb"                       throw (cvmexception);"\\
\verb"    cvector& "\GOT{solve\_lu}{cvector.solvelu}\verb" (const scmatrix& mA, const scmatrix& mLU,"\\
\verb"                       const int* pPivots, const cvector& vB)"\\
\verb"                       throw (cvmexception);"\\
\verb"    cvector& "\GOT{gels}{cvector.gels}\verb" (bool conjugate, const cmatrix& mA, const cvector& mB,"\\
\verb"                   TC& cErr) throw (cvmexception);"\\
\verb"    cvector& "\GOT{gelsy}{cvector.gelsy}\verb" (const cmatrix& mA, const cvector& mB,"\\
\verb"                    int& rank, TR tol = cvmMachSp())"\\
\verb"                    throw (cvmexception);"\\
\verb"    rvector& "\GOT{gelss}{cvector.gelss}\verb" (const cmatrix& mA, const cvector& mB,"\\
\verb"                    rvector& sv, int& rank, TR tol = cvmMachSp())"\\
\verb"                    throw (cvmexception);"\\
\verb"    rvector& "\GOT{gelsd}{cvector.gelsd}\verb" (const cmatrix& mA, const cvector& mB,"\\
\verb"                    rvector& sv, int& rank, TR tol = cvmMachSp())"\\
\verb"                    throw (cvmexception);"\\
\verb"    cvector& "\GOT{eig}{cvector.eig}\verb" (const srmatrix& mArg) throw (cvmexception);"\\
\verb"    cvector& "\GOT{eig}{cvector.eig}\verb" (const scmatrix& mArg) throw (cvmexception);"\\
\verb"    cvector& "\GOT{eig}{cvector.eig}\verb" (const srmatrix& mArg, scmatrix& mEigVect,"\\
\verb"                  bool bRightVect = true) throw (cvmexception);"\\
\verb"    cvector& "\GOT{eig}{cvector.eig}\verb" (const scmatrix& mArg, scmatrix& mEigVect,"\\
\verb"                  bool bRightVect = true) throw (cvmexception);"\\
\verb"    cvector& "\GOT{geneig}{cvector.geneig}\verb"(const srmatrix& mA, const srmatrix& mB,"\\
\verb"                     rvector& vBeta) throw (cvmexception);"\\
\verb"    cvector& "\GOT{geneig}{cvector.geneig}\verb"(const srmatrix& mA, const srmatrix& mB,"\\
\verb"                     rvector& vBeta, scmatrix& mEigVectLeft,"\\
\verb"                     scmatrix& mEigVectRight) throw (cvmexception);"\\
\verb"    cvector& "\GOT{geneig}{cvector.geneig}\verb"(const srmatrix& mA, const srmatrix& mB,"\\
\verb"                     rvector& vBeta, scmatrix& mEigVect,"\\
\verb"                     bool bRightVect = true) throw (cvmexception);"\\
\verb"    cvector& "\GOT{geneig}{cvector.geneig}\verb"(const scmatrix& mA, const scmatrix& mB,"\\
\verb"                     cvector& vBeta) throw (cvmexception);"\\
\verb"    cvector& "\GOT{geneig}{cvector.geneig}\verb"(const scmatrix& mA, const scmatrix& mB,"\\
\verb"                     cvector& vBeta, scmatrix& mEigVectLeft,"\\
\verb"                     scmatrix& mEigVectRight) throw (cvmexception);"\\
\verb"    cvector& "\GOT{geneig}{cvector.geneig}\verb"(const scmatrix& mA, const scmatrix& mB,"\\
\verb"                     cvector& vBeta, scmatrix& mEigVect,"\\
\verb"                     bool bRightVect = true) throw (cvmexception);"\\
\verb"    cvector& "\GOT{gemv}{cvector.gemv}\verb" (bool bLeft, const cmatrix& m, TC cAlpha,"\\
\verb"                   const cvector& v, TC dBeta) throw (cvmexception);"\\
\verb"    cvector& "\GOT{gbmv}{cvector.gbmv}\verb" (bool bLeft, const scbmatrix& m, TC dAlpha,"\\
\verb"                   const cvector& v, TC dBeta) throw (cvmexception);"\\
\verb"    cvector& "\GOT{randomize\_real}{cvector.randomizereal}\verb" (TR dFrom, TR dTo);"\\
\verb"    cvector& "\GOT{randomize\_imag}{cvector.randomizeimag}\verb" (TR dFrom, TR dTo);"\\
\verb"};"
\newpage



\subsubsection{cvector ()}
Constructor%
\pdfdest name {cvector.cvector ()} fit
\begin{verbatim}
cvector::cvector ();
\end{verbatim}
creates  empty \verb"cvector" object.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

cvector v;
std::cout << v.size() << std::endl;

v.resize (3);
v(1) = std::complex<double>(1.5, -1.);
std::cout << v;
\end{Verbatim}
prints
\begin{Verbatim}
0
(1.50e+00,-1.00e+00) (0.00e+00,0.00e+00) (0.00e+00,0.00e+00)
\end{Verbatim}
\newpage


\subsubsection{cvector (int)}
Constructor%
\pdfdest name {cvector.cvector (int)} fit
\begin{verbatim}
explicit cvector::cvector (int nSize);
\end{verbatim}
creates \verb"cvector" object of size equal to \verb"nSize".
It throws  \GOT{cvmexception}{cvmexception}
in case of non-positive size passed or memory allocation failure.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

cvector v(3);
std::cout << v.size() << std::endl;
std::cout << v;
\end{Verbatim}
prints
\begin{Verbatim}
3
(0.00e+00,0.00e+00) (0.00e+00,0.00e+00) (0.00e+00,0.00e+00)
\end{Verbatim}
\newpage



\subsubsection{cvector (std::initializer\_list<TC>)}
Constructor%
\pdfdest name {cvector (std::initializerlist)} fit
\begin{verbatim}
cvector::cvector (std::initializer_list<TC> list);
\end{verbatim}
creates \verb"cvector" object and fills it with values provided in the initializer list.
This constructor is available only if your compiler supports initializer lists
(GCC 4.4 and higher, MS Visual Studio 2013 and higher, Apple LLVM 5.0 and higher).
It throws  \GOT{cvmexception}{cvmexception}
in case of memory allocation failure.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf(std::ios::scientific | std::ios::left);
std::cout.precision(3);

cvector v = { tcomplex(1.2, 3.4), tcomplex(3.4, 5.6), 99.99 };
std::cout << v;
\end{Verbatim}
prints
\begin{Verbatim}
(1.200e+000,3.400e+000) (3.400e+000,5.600e+000) (9.999e+001,0.000e+000)
\end{Verbatim}
Also, if your compiler supports user-defined literals (GCC 4.7 and higher, Apple LLVM 5.0 and higher)
you can write
\begin{Verbatim}
cvector v = { 1.2+3.4_i, 3.4+5.6_i, 99.99 };
\end{Verbatim}
\newpage




\subsubsection{cvector (int, TC)}
Constructor%
\pdfdest name {cvector.cvector (int, TC)} fit
\begin{verbatim}
cvector::cvector (int nSize, TC c);
\end{verbatim}
creates  \verb"cvector" object of size equal to \verb"nSize"
and fills it with a value of \verb"c".
It throws  \GOT{cvmexception}{cvmexception}
in case of non-positive size passed or memory allocation failure.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

cvector v (3, std::complex<double>(1.5, -1.));
std::cout << v;
\end{Verbatim}
prints
\begin{Verbatim}
(1.50e+00,-1.00e+00) (1.50e+00,-1.00e+00) (1.50e+00,-1.00e+00)
\end{Verbatim}
\newpage



\subsubsection{cvector (TC*,int,int)}
Constructor%
\pdfdest name {cvector.cvector (TC*,int,int)} fit
\begin{verbatim}
cvector::cvector (TC* pD, int nSize, int nIncr = 1);
\end{verbatim}
creates  \verb"cvector" object of size equal to \verb"nSize".
Unlike others, this constructor \textit{does not allocate memory}.
It just shares memory with an array pointed to by \verb"pD" with
 distance between elements equal to \verb"nIncr".
It throws  \GOT{cvmexception}{cvmexception}
in case of non-positive size passed.
See also \GOT{cvector}{cvector}, \GOT{cvector (const TC*,int,int)}{cvector.cvector (const TC*,int,int)}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
cvector v1 ((std::complex<double>*) a, 2, 2);

std::cout << v1;
v1(2) = std::complex<double> (9.99, 9.99);
std::cout << v1 << std::endl;

for (int i = 0; i < 6; i++) {
    std::cout << a[i] << " ";
}
std::cout << std::endl;

cvector v2 ((std::complex<double>*) a, 3);
std::cout << v2;
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+000,2.00e+000) (5.00e+000,6.00e+000)
(1.00e+000,2.00e+000) (9.99e+000,9.99e+000)

1.00e+000 2.00e+000 3.00e+000 4.00e+000 9.99e+000 9.99e+000
(1.00e+000,2.00e+000) (3.00e+000,4.00e+000) (9.99e+000,9.99e+000)
\end{Verbatim}
\newpage



\subsubsection{cvector (const TC*,int,int)}
Constructor%
\pdfdest name {cvector.cvector (const TC*,int,int)} fit
\begin{verbatim}
cvector::cvector (const TC* pD, int nSize, int nIncr = 1);
\end{verbatim}
creates  \verb"cvector" object of size equal to \verb"nSize"
and copies \verb"nSize" elements of
 array \verb"pD" to it using increment \verb"nIncr" ($1$ by default).
The object created has an increment set to $1$.
It throws  \GOT{cvmexception}{cvmexception}
in case of non-positive size passed.
See also \GOT{cvector}{cvector}, \GOT{cvector (TC*,int,int)}{cvector.cvector (TC*,int,int)}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

const double a[] = {1., 2., 3., 4., 5., 6., 7., 8.};
cvector v1 ((const std::complex<double>*) a, 2, 2);

std::cout << v1;
v1(2) = std::complex<double> (9.99, 9.99);
std::cout << v1 << std::endl;

for (int i = 0; i < 6; i++) {
    std::cout << a[i] << " ";
}
std::cout << std::endl;

cvector v2 ((std::complex<double>*) a, 3);
std::cout << v2;
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+000,2.00e+000) (5.00e+000,6.00e+000)
(1.00e+000,2.00e+000) (9.99e+000,9.99e+000)

1.00e+000 2.00e+000 3.00e+000 4.00e+000 5.00e+000 6.00e+000
(1.00e+000,2.00e+000) (3.00e+000,4.00e+000) (5.00e+000,6.00e+000)
\end{Verbatim}
\newpage




\subsubsection{cvector (const cvector\&)}
Copy constructor%
\pdfdest name {cvector.cvector (const cvector&)} fit
\begin{verbatim}
cvector::cvector (const cvector& v);
\end{verbatim}
creates  \verb"cvector" object of size equal to size of
vector \verb"v" and sets every element of created vector to be equal to
appropriate element of \verb"v".
It throws  \GOT{cvmexception}{cvmexception}
in case of memory allocation failure.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9., 10.};
const cvector v ((std::complex<double>*) a, 3, 2);
cvector vc (v);

vc(1) = std::complex<double>(7.77,8.88);
std::cout << vc;
std::cout << v;
\end{Verbatim}
prints
\begin{Verbatim}
(7.77e+00,8.88e+00) (5.00e+00,6.00e+00) (9.00e+00,1.00e+01)
(1.00e+00,2.00e+00) (5.00e+00,6.00e+00) (9.00e+00,1.00e+01)
\end{Verbatim}
\newpage


\subsubsection{cvector (const TR*,const TR*,int,int,int)}
Constructor%
\pdfdest name {cvector.cvector (TR*,TR*,int,int,int)} fit
\begin{verbatim}
cvector::cvector (const TR* pRe, const TR* pIm, int nSize,
                  tint nIncrRe = 1, tint nIncrIm = 1);
\end{verbatim}
creates  \verb"cvector" object
of size equal to \verb"nSize" and copies 
every \verb"nIncrRe"-th element of an array  pointed to by \verb"pRe" 
and 
every \verb"nIncrIm"-th element of an array  pointed to by \verb"pIm"
to real and imaginary part of the object created.
It throws  \GOT{cvmexception}{cvmexception}
in case of non-positive size passed or memory allocation failure.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double re[] = {1., 2., 3., 4., 5.};
double im[] = {5., 4., 3., 2., 1.};
cvector v (re, im, 3, 2);

std::cout << v;
re[0] = 7.77;
std::cout << v;

const double rec[] = {1., 2., 3.};
const double imc[] = {5., 4., 3.};
const cvector vc (rec, imc, 3);
std::cout << vc;
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+00,5.00e+00) (3.00e+00,4.00e+00) (5.00e+00,3.00e+00)
(1.00e+00,5.00e+00) (3.00e+00,4.00e+00) (5.00e+00,3.00e+00)
(1.00e+00,5.00e+00) (2.00e+00,4.00e+00) (3.00e+00,3.00e+00)
\end{Verbatim}
\newpage



\subsubsection{cvector (const rvector\&, const rvector\&)}
Constructor%
\pdfdest name {cvector.cvector (const rvector&, const rvector&)} fit
\begin{verbatim}
cvector::cvector (const rvector& vRe, const rvector& vIm);
\end{verbatim}
creates  \verb"cvector" object
of size equal to \verb"vRe.size()" and \verb"vIm.size()"
and copies vectors \verb"vRe" and \verb"vIm"
to  real and imaginary part of the object created.
It throws  \GOT{cvmexception}{cvmexception}
in case of non-equal sizes of the parameters passed
or memory allocation failure.
See also \GOT{cvector}{cvector} and \GOT{rvector}{rvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

rvector vr(3), vi(3);
vr[1] = 1.;
vr[2] = 2.;
vr[3] = 3.;
vi[1] = 5.;
vi[2] = 4.;
vi[3] = 3.;

const cvector vc(vr, vi);
std::cout << vc;
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+00,5.00e+00) (2.00e+00,4.00e+00) (3.00e+00,3.00e+00)
\end{Verbatim}
\newpage



\subsubsection{cvector (const TR*,int,bool,int)}
Constructor%
\pdfdest name {cvector.cvector (const TR*,int,bool,int)} fit
\begin{verbatim}
cvector::cvector (const TR* pA, int nSize,
                  bool bRealPart = true, int nIncr = 1);
\end{verbatim}
creates  \verb"cvector" object
of size equal to \verb"nSize" and copies every
\verb"nIncr"-th element of an array  pointed to by \verb"pA"
to  real (if \verb"bRealPart" is \verb"true")
or imaginary (if \verb"bRealPart" is \verb"false")
part of the object created.
Constructor throws  \GOT{cvmexception}{cvmexception}
in case of non-positive size passed or memory allocation failure.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

const double a[] = {1., 2., 3., 4., 5.};
cvector v1 (a, 3, false, 2);
cvector v2 (a, 2);

std::cout << v1 << v2;
\end{Verbatim}
prints
\begin{Verbatim}
(0.00e+00,1.00e+00) (0.00e+00,3.00e+00) (0.00e+00,5.00e+00)
(1.00e+00,0.00e+00) (2.00e+00,0.00e+00)
\end{Verbatim}
\newpage



\subsubsection{cvector (const rvector\&,bool)}
Constructor%
\pdfdest name {cvector.cvector (const rvector&,bool)} fit
\begin{verbatim}
explicit cvector::cvector (const rvector& v, bool bRealPart = true);
\end{verbatim}
creates  \verb"cvector" object
of size equal to \verb"v.size()" and copies every
element of a vector \verb"v"
to  real (if \verb"bRealPart" is \verb"true")
or imaginary (if \verb"bRealPart" is \verb"false")
part of the object created.
Constructor throws  \GOT{cvmexception}{cvmexception}
in case of memory allocation failure.
See also \GOT{cvector}{cvector} and \GOT{rvector}{rvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

rvector vr (3);
vr(1) = 1.;
vr(2) = 2.;
vr(3) = 3.;

cvector v1 (vr);
cvector v2 (vr, false);
std::cout << v1 << v2;
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+00,0.00e+00) (2.00e+00,0.00e+00) (3.00e+00,0.00e+00)
(0.00e+00,1.00e+00) (0.00e+00,2.00e+00) (0.00e+00,3.00e+00)
\end{Verbatim}
\newpage


\subsubsection{real}
Function%
\pdfdest name {cvector.real} fit
\begin{verbatim}
rvector cvector::real ();
\end{verbatim}
creates  \GOT{rvector}{rvector} object
of size equal to  size of a calling vector
sharing  memory with its real part.
In other words, the vector returned is  \emph{l-value}.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

cvector vc(3);
vc.set(std::complex<double>(1.,1.));
std::cout << vc << vc.real();
vc.real()(1) = 7.77;
std::cout << vc;
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+00,1.00e+00) (1.00e+00,1.00e+00) (1.00e+00,1.00e+00)
1.00e+00 1.00e+00 1.00e+00
(7.77e+00,1.00e+00) (1.00e+00,1.00e+00) (1.00e+00,1.00e+00)
\end{Verbatim}
\newpage



\subsubsection{imag}
function%
\pdfdest name {cvector.imag} fit
\begin{verbatim}
rvector cvector::imag ();
\end{verbatim}
creates  \GOT{rvector}{rvector} object
of size equal to  size of a calling vector
sharing  memory with its imaginary part.
In other words, the vector returned is  \emph{l-value}.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

cvector vc(3);
vc.set(std::complex<double>(1.,1.));
std::cout << vc << vc.imag();
vc.imag()(1) = 7.77;
std::cout << vc;
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+00,1.00e+00) (1.00e+00,1.00e+00) (1.00e+00,1.00e+00)
1.00e+00 1.00e+00 1.00e+00
(1.00e+00,7.77e+00) (1.00e+00,1.00e+00) (1.00e+00,1.00e+00)
\end{Verbatim}
\newpage



\subsubsection{operator = (const cvector\&)}
Operator%
\pdfdest name {cvector.operator = (const cvector&)} fit
\begin{verbatim}
cvector& cvector::operator = (const cvector& v) throw (cvmexception);
\end{verbatim}
sets every element of a calling vector to be equal to
appropriate element of a vector \verb"v"
and returns a reference to
the vector changed.
It throws  \GOT{cvmexception}{cvmexception}
in case of different vector sizes.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

try {
    cvector v(3);
    cvector vc(3);
    v(1) = std::complex<double>(1.,2.);

    vc = v;
    std::cout << vc;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+00,2.00e+00) (0.00e+00,0.00e+00) (0.00e+00,0.00e+00)
\end{Verbatim}
\newpage



\subsubsection{assign(const TC*, int)}
Function%
\pdfdest name {cvector.assign (const TC*, int)} fit
\begin{verbatim}
cvector& cvector::assign (const TC* p, int nIncr = 1);
\end{verbatim}
sets every element of a calling vector to be equal to
every \verb"nIncr"-th element of an array  pointed to by parameter \verb"p"
and returns a reference to the vector changed.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

const double a[] = {1., 2., 3., 4., 5., 6., 7.};
cvector v1(3);
cvector v2(2);

v1.assign((const std::complex<double>*) a);
v2.assign((const std::complex<double>*) a, 2);
std::cout << v1;
std::cout << v2;
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+00,2.00e+00) (3.00e+00,4.00e+00) (5.00e+00,6.00e+00)
(1.00e+00,2.00e+00) (5.00e+00,6.00e+00)
\end{Verbatim}
\newpage




\subsubsection{assign(int, const TC*, int)}
Function%
\pdfdest name {cvector.assign (int, const TC*, int)} fit
\begin{verbatim}
cvector& cvector::assign (int n, const TC* p, int nIncr = 1);
\end{verbatim}
sets every element of a calling vector, starting from \Based \verb"n"-th one,
to be equal to
every \verb"nIncr"-th element of an array  pointed to by parameter \verb"p"
and returns a reference to the vector changed.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;

const double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9., 10.};
cvector v1(4);
cvector v2(4);

v1.assign(3, (const std::complex<double>*) a);
v2.assign(2, (const std::complex<double>*) a, 2);
std::cout << v1;
std::cout << v2;
\end{Verbatim}
prints
\begin{Verbatim}
(0,0) (0,0) (1,2) (3,4)
(0,0) (1,2) (5,6) (9,10)
\end{Verbatim}
\newpage



\subsubsection{assign(int, const TR*, int, int)}
Function%
\pdfdest name {cvector.assign (int, const TC*, int, int)} fit
\begin{verbatim}
cvector& cvector::assign (int n, const TC* p, int nSize, tint nIncr);
\end{verbatim}
sets every element of a calling vector, starting from \Based \verb"n"-th one,
up to \verb"nSize" total,
to be equal to
every \verb"nIncr"-th element of an array  pointed to by parameter \verb"p"
and returns a reference to the vector changed.
If \verb"n + nSize" goes beyond vector boundaries assignment stops at the last element.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
const double a[] = {1., 2., 3., 4., 5., 6., 7., 8., 9., 10.};
cvector v1(4);

v1.assign(2, (const std::complex<double>*) a, 2, 3);
std::cout << v1;
\end{Verbatim}
prints
\begin{Verbatim}
(0,0) (1,2) (7,8) (0,0)
\end{Verbatim}
\newpage



\subsubsection{assign (int, const cvector\&)}
Function%
\pdfdest name {cvector.assign (int, const cvector&)} fit
\begin{verbatim}
cvector& cvector::assign (int n, const cvector& v) throw (cvmexception);
\end{verbatim}
sets every element of a calling vector's sub-vector beginning with
\Based index \verb"n" to a vector \verb"v" and returns 
reference to the vector changed. Function throws 
\GOT{cvmexception}{cvmexception} if \verb"n" is not
positive or \verb"v.size()+n-1" is greater than  calling vector's
size. See also \GOT{cvector}{cvector}. Example:
\begin{Verbatim}
using namespace cvm;

cvector v1(5);
cvector v2(2);
v1.set(std::complex<double>(1.,1.));
v2.set(std::complex<double>(2.,2.));
v1.assign(3, v2);
std::cout << v1;
\end{Verbatim}
prints
\begin{Verbatim}
(1,1) (1,1) (2,2) (2,2) (1,1)
\end{Verbatim}
\newpage



\subsubsection{set(TC)}
Function%
\pdfdest name {cvector.set (TC)} fit
\begin{verbatim}
cvector& cvector::set (TC x);
\end{verbatim}
sets every element of a calling vector to be equal to
parameter \verb"x"
and returns a reference to the vector changed.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

cvector v(3);
v.set(std::complex<double>(3.,1.));
std::cout << v;
\end{Verbatim}
prints
\begin{Verbatim}
(3.00e+00,1.00e+00) (3.00e+00,1.00e+00) (3.00e+00,1.00e+00)
\end{Verbatim}
\newpage



\subsubsection{assign\_real}
Function%
\pdfdest name {cvector.assignreal} fit
\begin{verbatim}
cvector& cvector::assign_real (const rvector& vRe) throw (cvmexception);
\end{verbatim}
sets real part of every element of a calling vector to be equal to
appropriate element of a vector \verb"vRe"
and returns a reference to
the vector changed.
Function throws  \GOT{cvmexception}{cvmexception}
in case of different sizes of the operands.
See also \GOT{cvector}{cvector} and \GOT{rvector}{rvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

rvector v(3);
cvector vc(3);
v(1) = 1.; v(2) = 2.; v(3) = 3.;

vc.assign_real(v);
std::cout << vc;
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+00,0.00e+00) (2.00e+00,0.00e+00) (3.00e+00,0.00e+00)
\end{Verbatim}
\newpage


\subsubsection{assign\_imag}
Function%
\pdfdest name {cvector.assignimag} fit
\begin{verbatim}
cvector& cvector::assign_imag (const rvector& vIm) throw (cvmexception);
\end{verbatim}
sets imaginary part of every element of a calling vector to be equal to
appropriate element of a vector \verb"vIm"
and returns a reference to
the vector changed.
Function throws  \GOT{cvmexception}{cvmexception}
in case of different sizes of the operands.
See also \GOT{cvector}{cvector} and \GOT{rvector}{rvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

rvector v(3);
cvector vc(3);
v(1) = 1.; v(2) = 2.; v(3) = 3.;

vc.assign_imag(v);
std::cout << vc;
\end{Verbatim}
prints
\begin{Verbatim}
(0.00e+00,1.00e+00) (0.00e+00,2.00e+00) (0.00e+00,3.00e+00)
\end{Verbatim}
\newpage


\subsubsection{set\_real}
Function%
\pdfdest name {cvector.setreal} fit
\begin{verbatim}
cvector& cvector::set_real (TR x);
\end{verbatim}
sets real part of every element of a calling vector to be equal to
parameter \verb"x"
and returns a reference to the vector changed.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

cvector v(3);
v.set_real(1.);
std::cout << v;
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+00,0.00e+00) (1.00e+00,0.00e+00) (1.00e+00,0.00e+00)
\end{Verbatim}
\newpage



\subsubsection{set\_imag}
Function%
\pdfdest name {cvector.setimag} fit
\begin{verbatim}
cvector& cvector::set_imag (TR x);
\end{verbatim}
sets imaginary part of every element of a calling vector to be equal to
parameter \verb"x"
and returns a reference to the vector changed.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

cvector v(3);
v.set_imag(1.);
std::cout << v;
\end{Verbatim}
prints
\begin{Verbatim}
(0.00e+00,1.00e+00) (0.00e+00,1.00e+00) (0.00e+00,1.00e+00)
\end{Verbatim}
\newpage


\subsubsection{resize}
Function%
\pdfdest name {cvector.resize} fit
\begin{verbatim}
cvector& cvector::resize (int nNewSize) throw (cvmexception);
\end{verbatim}
changes  size of a calling vector to be equal to
\verb"nNewSize" and returns a reference to
the vector changed.
In case of increasing of its size, the vector
is filled up with zeroes.
Function throws  \GOT{cvmexception}{cvmexception}
in case of negative size passed or memory allocation failure.
See also \GOT{basic\_array::resize}{basicarray.resize} and
\GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;

try {
    double a[] = {1., 2., 3., 4.};
    rvector v (a, 3);
    std::cout << v;
    v.resize(2);
    std::cout << v;
    v.resize(4);
    std::cout << v;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(1,2) (3,4) (5,6)
(1,2) (3,4)
(1,2) (3,4) (0,0) (0,0)
\end{Verbatim}
\newpage


\subsubsection{operator ==}
Operator%
\pdfdest name {cvector.operator ==} fit
\begin{verbatim}
bool cvector::operator == (const cvector& v) const;
\end{verbatim}
compares  calling vector with a vector \verb"v"
and returns \verb"true" if they have the same sizes
and their appropriate elements differ by not more than the
\GO{smallest normalized positive number}{Utilities.cvmMachMin}.
Returns \verb"false" otherwise.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;

double a[] = {1., 2., 3., 4.};
cvector v1 ((std::complex<double>*)a, 2);
cvector v2 (2);

v2(1) = std::complex<double>(1.,2.);
v2(2) = std::complex<double>(3.,4.);

std::cout << (v1 == v2) << std::endl;
\end{Verbatim}
prints
\begin{Verbatim}
1
\end{Verbatim}
\newpage



\subsubsection{operator !=}
Operator%
\pdfdest name {cvector.operator !=} fit
\begin{verbatim}
bool cvector::operator != (const cvector& v) const;
\end{verbatim}
compares  calling vector with a vector \verb"v"
and returns \verb"true" if they have different sizes
or some of their appropriate elements
differ by more than the
\GO{smallest normalized positive number}{Utilities.cvmMachMin}.
Returns \verb"false" otherwise.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;

double a[] = {1., 2., 3., 4.};
cvector v1 ((std::complex<double>*)a, 2);
cvector v2 (2);

std::cout << (v1 != v2) << std::endl;
\end{Verbatim}
prints
\begin{Verbatim}
1
\end{Verbatim}
\newpage



\subsubsection{operator <{}<}
Operator%
\pdfdest name {cvector.operator <<} fit
\begin{verbatim}
cvector& cvector::operator << (const cvector& v) throw (cvmexception);
\end{verbatim}
destroys  calling vector, creates a new one as a copy of \verb"v"
and returns a reference to
the vector changed.
See also \GOT{cvector}{cvector}.
Operator throws  \GOT{cvmexception}{cvmexception}
in case of memory allocation failure.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

try {
    cvector v(2);
    cvector vc(3);
    v(1) = std::complex<double> (1.,2.);
    v(2) = std::complex<double> (3.,4.);
    std::cout << v << vc << std::endl;

    vc << v;
    std::cout << vc;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+000,2.00e+000) (3.00e+000,4.00e+000)
(0.00e+000,0.00e+000) (0.00e+000,0.00e+000) (0.00e+000,0.00e+000)

(1.00e+000,2.00e+000) (3.00e+000,4.00e+000)
\end{Verbatim}
\newpage



\subsubsection{operator +}
Operator%
\pdfdest name {cvector.operator +} fit
\begin{verbatim}
cvector cvector::operator + (const cvector& v) const
throw (cvmexception);
\end{verbatim}
creates an object of type \verb"cvector" as a sum of
a calling  vector and a vector \verb"v".
Operator throws \GOT{cvmex\-ception}{cvmexception}
in case of different sizes of the operands
or memory allocation failure.
See also \GOT{cvector}{cvector}, \GOT{cvector::sum}{cvector.sum}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

try {
    cvector va(3);
    cvector vb(3);
    va.set(std::complex<double>(1.,1.));
    vb.set(std::complex<double>(2.,2.));

    std::cout << va + vb;
    std::cout << va + va;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(3.00e+000,3.00e+000) (3.00e+000,3.00e+000) (3.00e+000,3.00e+000)
(2.00e+000,2.00e+000) (2.00e+000,2.00e+000) (2.00e+000,2.00e+000)
\end{Verbatim}
\newpage


\subsubsection{operator -}
Operator%
\pdfdest name {cvector.operator -} fit
\begin{verbatim}
cvector cvector::operator - (const cvector& v) const
throw (cvmexception);
\end{verbatim}
creates an object of type \verb"cvector" as a difference of
a calling  vector and a vector \verb"v".
It throws  \GOT{cvmexception}{cvmexception}
in case of different sizes of the operands
or memory allocation failure.
See also \GOT{cvector::diff}{cvector.diff}, \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

try {
    cvector va(3);
    cvector vb(3);
    va.set(std::complex<double> (1.,1.));
    vb.set(std::complex<double> (2.,2.));

    std::cout << va - vb;
    std::cout << va - va;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(-1.00e+000,-1.00e+000) (-1.00e+000,-1.00e+000) (-1.00e+000,-1.00e+000)
(0.00e+000,0.00e+000) (0.00e+000,0.00e+000) (0.00e+000,0.00e+000)
\end{Verbatim}
\newpage


\subsubsection{sum}
Function%
\pdfdest name {cvector.sum} fit
\begin{verbatim}
cvector& cvector::sum (const cvector& v1, const cvector& v2)
throw (cvmexception);
\end{verbatim}
assigns the result of addition of
vectors \verb"v1" and \verb"v2"  to a calling vector
and returns a reference to
the vector changed.
It throws  \GOT{cvmexception}{cvmexception}
in case of different sizes of the operands.
See also \GOT{cvector::operator +~}{cvector.operator +},
\GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

try {
    cvector va(3);
    cvector vb(3);
    cvector v(3);
    va.set(std::complex<double> (1.,1.));
    vb.set(std::complex<double> (2.,2.));

    std::cout << v.sum(va, vb);
    std::cout << v.sum(v, va);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(3.00e+000,3.00e+000) (3.00e+000,3.00e+000) (3.00e+000,3.00e+000)
(4.00e+000,4.00e+000) (4.00e+000,4.00e+000) (4.00e+000,4.00e+000)
\end{Verbatim}
\newpage


\subsubsection{diff}
Function%
\pdfdest name {cvector.diff} fit
\begin{verbatim}
cvector& cvector::diff (const cvector& v1, const cvector& v2)
throw (cvmexception);
\end{verbatim}
assigns the result of subtraction of
vectors \verb"v1" and \verb"v2" to a calling vector
and returns a reference to
the vector changed.
It throws  \GOT{cvmexception}{cvmexception}
in case of different sizes of the operands.
See also \GOT{cvector::operator -~}{cvector.operator -},
\GOT{rvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

try {
    cvector va(3);
    cvector vb(3);
    cvector v(3);
    va.set(std::complex<double> (1.,1.));
    vb.set(std::complex<double> (2.,2.));

    std::cout << v.diff(va, vb);
    std::cout << v.diff(v, va);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(-1.00e+000,-1.00e+000) (-1.00e+000,-1.00e+000) (-1.00e+000,-1.00e+000)
(-2.00e+000,-2.00e+000) (-2.00e+000,-2.00e+000) (-2.00e+000,-2.00e+000)
\end{Verbatim}
\newpage



\subsubsection{operator +=}
Operator%
\pdfdest name {cvector.operator +=} fit
\begin{verbatim}
cvector& cvector::operator += (const cvector& v) throw (cvmexception);
\end{verbatim}
adds vector \verb"v" to a calling vector 
and returns a reference to
the vector changed.
It throws  \GOT{cvmexception}{cvmexception}
in case of different sizes of the operands.
See also \GOT{cvector::operator +~}{cvector.operator +},
\GOT{cvector::sum}{cvector.sum},
\GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

try {
    cvector v1(3);
    cvector v2(3);
    v1.set(std::complex<double> (1.,1.));
    v2.set(std::complex<double> (2.,2.));

    v1 += v2;
    std::cout << v1;

    // well, you can do this too, but temporary object would be created
    v2 += v2;
    std::cout << v2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(3.00e+000,3.00e+000) (3.00e+000,3.00e+000) (3.00e+000,3.00e+000)
(4.00e+000,4.00e+000) (4.00e+000,4.00e+000) (4.00e+000,4.00e+000)
\end{Verbatim}
\newpage



\subsubsection{operator -=}
Operator%
\pdfdest name {cvector.operator -=} fit
\begin{verbatim}
cvector& cvector::operator -= (const cvector& v) throw (cvmexception);
\end{verbatim}
subtracts vector \verb"v" from  calling vector  
and returns a reference to
the vector changed.
It throws  \GOT{cvmexception}{cvmexception}
in case of different sizes of the operands.
See also 
\GOT{cvector::diff}{cvector.diff},
\GOT{cvector::operator -~}{cvector.operator -},
\GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

try {
    cvector v1(3);
    cvector v2(3);
    v1.set(std::complex<double> (1.,1.));
    v2.set(std::complex<double> (2.,2.));

    v1 -= v2;
    std::cout << v1;

    // well, you can do this too, but temporary object would be created
    v2 -= v2;
    std::cout << v2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(-1.00e+000,-1.00e+000) (-1.00e+000,-1.00e+000) (-1.00e+000,-1.00e+000)
(0.00e+000,0.00e+000) (0.00e+000,0.00e+000) (0.00e+000,0.00e+000)
\end{Verbatim}
\newpage



\subsubsection{operator - ()}
Operator%
\pdfdest name {cvector.operator - ()} fit
\begin{verbatim}
cvector cvector::operator - () const throw (cvmexception);
\end{verbatim}
creates an object of type \verb"cvector" as
a calling  vector multiplied by -1.
It can throw \GOT{cvmexception}{cvmexception}
in case of memory allocation failure.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4.};
const cvector v ((std::complex<double>*) a, 2);

std::cout << - v;
\end{Verbatim}
prints
\begin{Verbatim}
(-1.00e+000,-2.00e+000) (-3.00e+000,-4.00e+000)
\end{Verbatim}
\newpage



\subsubsection{operator * (TR)}
Operator%
\pdfdest name {cvector.operator * (TR)} fit
\begin{verbatim}
cvector cvector::operator * (TR d) const;
\end{verbatim}
creates an object of type \verb"cvector" as a product of
a calling  vector and  number \verb"d".
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4.};
const cvector v ((std::complex<double>*) a, 2);

std::cout << v * 5.;
\end{Verbatim}
prints
\begin{Verbatim}
(5.00e+000,1.00e+001) (1.50e+001,2.00e+001)
\end{Verbatim}
\newpage



\subsubsection{operator / (TR)}
Operator%
\pdfdest name {cvector.operator / (TR)} fit
\begin{verbatim}
cvector cvector::operator / (TR d) const throw (cvmexception);
\end{verbatim}
creates an object of type \verb"cvector" as a quotient of
a calling  vector and  number \verb"d". Operator throws
 \GOT{cvmexception}{cvmexception}
if \verb"d" has  absolute value equal or less
than the
\GO{smallest normalized positive number}{Utilities.cvmMachMin}.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4.};
const cvector v ((std::complex<double>*) a, 2);

std::cout << v / 4.;
\end{Verbatim}
prints
\begin{Verbatim}
(2.50e-001,5.00e-001) (7.50e-001,1.00e+000)
\end{Verbatim}
\newpage



\subsubsection{operator * (TC)}
Operator%
\pdfdest name {cvector.operator * (TC)} fit
\begin{verbatim}
cvector cvector::operator * (TC c) const;
\end{verbatim}
creates an object of type \verb"cvector" as a product of
a calling  vector and  complex number \verb"c".
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4.};
const cvector v ((std::complex<double>*) a, 2);

std::cout << v * std::complex<double>(1.,1.);
\end{Verbatim}
prints
\begin{Verbatim}
(-1.00e+000,3.00e+000) (-1.00e+000,7.00e+000)
\end{Verbatim}
\newpage




\subsubsection{operator / (TC)}
Operator%
\pdfdest name {cvector.operator / (TC)} fit
\begin{verbatim}
cvector cvector::operator / (TC c) const
throw (cvmexception);
\end{verbatim}
creates an object of type \verb"cvector" as a quotient of
a calling  vector and  complex number \verb"c".
Operator throws
 \GOT{cvmexception}{cvmexception}
if \verb"c" has  absolute value equal or less
than the
\GO{smallest normalized positive number}{Utilities.cvmMachMin}.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4.};
const cvector v ((std::complex<double>*) a, 2);

std::cout << v / std::complex<double>(1.,1.);
\end{Verbatim}
prints
\begin{Verbatim}
(1.50e+000,5.00e-001) (3.50e+000,5.00e-001)
\end{Verbatim}
\newpage



\subsubsection{operator *= (TR)}
Operator%
\pdfdest name {cvector.operator *= (TR)} fit
\begin{verbatim}
cvector& cvector::operator *= (TR d);
\end{verbatim}
multiplies  calling vector by real number \verb"d"
and returns a reference to
the vector changed.
See also \GOT{cvector::operator *~}{cvector.operator * (TR)},
\GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4.};
cvector v ((std::complex<double>*) a, 2);

std::cout << (v *= 2.);
\end{Verbatim}
prints
\begin{Verbatim}
(2.00e+000,4.00e+000) (6.00e+000,8.00e+000)
\end{Verbatim}
\newpage



\subsubsection{operator /= (TR)}
Operator%
\pdfdest name {cvector.operator /= (TR)} fit
\begin{verbatim}
cvector& cvector::operator /= (TR d) throw (cvmexception);
\end{verbatim}
divides  calling vector by real number \verb"d"
and returns a reference to
the vector changed.
It throws  \GOT{cvmexception}{cvmexception}
if \verb"d" has  absolute value equal or less
than the
\GO{smallest normalized positive number}{Utilities.cvmMachMin}.
See also \GOT{cvector::operator /~}{cvector.operator / (TR)},
\GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4.};
cvector v ((std::complex<double>*) a, 2);

std::cout << (v /= 2.);
\end{Verbatim}
prints
\begin{Verbatim}
(5.00e-001,1.00e+000) (1.50e+000,2.00e+000)
\end{Verbatim}
\newpage



\subsubsection{operator *= (TC)}
Operator%
\pdfdest name {cvector.operator *= (TC)} fit
\begin{verbatim}
cvector& cvector::operator *= (TC c);
\end{verbatim}
multiplies  calling vector by complex number \verb"c"
and returns a reference to
the vector changed.
See also \GOT{cvector::operator *~}{cvector.operator * (TC)},
\GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4.};
cvector v ((std::complex<double>*) a, 2);

v *= std::complex<double>(1.,1.);
std::cout << v;
\end{Verbatim}
prints
\begin{Verbatim}
(-1.00e+000,3.00e+000) (-1.00e+000,7.00e+000)
\end{Verbatim}
\newpage



\subsubsection{operator /= (TC)}
Operator%
\pdfdest name {cvector.operator /= (TC)} fit
\begin{verbatim}
cvector& cvector::operator /= (TC c) throw (cvmexception);
\end{verbatim}
divides  calling vector by complex number \verb"c"
and returns a reference to
the vector changed.
It throws  \GOT{cvmexception}{cvmexception}
if \verb"c" has  absolute value equal or less
than the
\GO{smallest normalized positive number}{Utilities.cvmMachMin}.
See also \GOT{cvector::operator /~}{cvector.operator / (TC)},
\GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4.};
cvector v ((std::complex<double>*) a, 2);

v /= std::complex<double>(1.,1.);
std::cout << v;
\end{Verbatim}
prints
\begin{Verbatim}
(1.50e+000,5.00e-001) (3.50e+000,5.00e-001)
\end{Verbatim}
\newpage



\subsubsection{normalize}
Function%
\pdfdest name {cvector.normalize} fit
\begin{verbatim}
cvector& cvector::normalize ();
\end{verbatim}
normalizes  calling vector so its \GO{Euclidean norm}{Array.norm}
becomes equal to $1$ if it was greater than the
\GO{smallest normalized positive number}{Utilities.cvmMachMin}
before the call (otherwise it does nothing).
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4.};
cvector v ((std::complex<double>*) a, 2);

std::cout << v.normalize();
std::cout << v.norm() << std::endl;
\end{Verbatim}
prints
\begin{Verbatim}
(1.83e-01,3.65e-01) (5.48e-01,7.30e-01)
1.00e+00
\end{Verbatim}
\newpage



\subsubsection{conjugation}
Operator and functions%
\pdfdest name {cvector.conjugation} fit
\begin{verbatim}
cvector  cvector::operator ~ () const throw (cvmexception);
cvector& cvector::conj (const cvector& v) throw (cvmexception);
cvector& cvector::conj ();
\end{verbatim}
implement complex conjugation.
First operator creates an object of type \verb"cvector" as
 complex conjugated calling vector
(it throws 
\GOT{cvmexception}{cvmexception}
in case of memory allocation failure).
Second function sets calling vector to be equal to vector
\verb"v" conjugated
(it throws 
\GOT{cvmexception}{cvmexception}
in case of different sizes of the operands),
third one makes it to be equal to
conjugated itself.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);
double a[] = {1., 2., 3., 4.};
const cvector v ((std::complex<double>*) a, 2);
cvector vc(2);

std::cout << ~v;
std::cout << vc.conj(v);
std::cout << vc.conj();
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+00,-2.00e+00) (3.00e+00,-4.00e+00)
(1.00e+00,-2.00e+00) (3.00e+00,-4.00e+00)
(1.00e+00,2.00e+00) (3.00e+00,4.00e+00)
\end{Verbatim}
\newpage


\subsubsection{operator * (const cvector\&)}
Operator%
\pdfdest name {cvector.operator * (const cvector&)} fit
\begin{verbatim}
TC cvector::operator * (const cvector& v) const throw (cvmexception);
\end{verbatim}
returns  scalar product of a calling vector and a vector \verb"v".
Operator throws 
\GOT{cvmexception}{cvmexception}
if the operands have different sizes.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4.};
double b[] = {1., -1., 1., 2.};
const cvector v1((std::complex<double>*) a, 2);
const cvector v2((std::complex<double>*) b, 2);

std::cout << v1 * v2 << std::endl;
\end{Verbatim}
prints
\begin{Verbatim}
(-2.00e+00,1.10e+01)
\end{Verbatim}
\newpage



\subsubsection{operator \%}
Operator%
\pdfdest name {cvector.operator pcent} fit
\begin{verbatim}
TC cvector::operator % (const cvector& v) const throw (cvmexception);
\end{verbatim}
returns  scalar product of  complex conjugated
a calling  vector and a vector \verb"v".
Operator throws 
\GOT{cvmexception}{cvmexception}
if the operands have different sizes.
See also \GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 4.};
double b[] = {1., -1., 1., 2.};
const cvector v1((std::complex<double>*) a, 2);
const cvector v2((std::complex<double>*) b, 2);

std::cout << v1 % v2 << std::endl;
std::cout << ~v1 * v2 << std::endl;
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+01,-1.00e+00)
(1.00e+01,-1.00e+00)
\end{Verbatim}
\newpage



\subsubsection{operator * (const cmatrix\&)}
Operator%
\pdfdest name {cvector.operator * (const cmatrix&)} fit
\begin{verbatim}
cvector cvector::operator * (const cmatrix& m) const
throw (cvmexception);
\end{verbatim}
creates an object of type \verb"cvector" as a product of
a calling vector and a matrix \verb"m".
Operator throws 
\GOT{cvmexception}{cvmexception}
if the calling vector's size
is differ from  number of rows of a matrix \verb"m"'.
See also \GOT{cvector::mult (const cvector\&, const cmatrix\&)}
{cvector.mult (const cvector&, const cmatrix&)},
\GOT{cvector}{cvector}, \GOT{cmatrix}{cmatrix}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

double a[] = {1., 2., 3., 3., 2., 1.};
double b[] = {1., -1., 1., 2., -2., 1.,
              3., -2., 1., 2., -1., 3.};
const cvector v((std::complex<double>*) a, 3);
const cmatrix m((std::complex<double>*) b, 3, 2);

std::cout << v << m << std::endl << v * m;
\end{Verbatim}
prints
\begin{Verbatim}
(1.00e+00,2.00e+00) (3.00e+00,3.00e+00) (2.00e+00,1.00e+00)
(1.00e+00,-1.00e+00) (3.00e+00,-2.00e+00)
(1.00e+00,2.00e+00) (1.00e+00,2.00e+00)
(-2.00e+00,1.00e+00) (-1.00e+00,3.00e+00)

(-5.00e+00,1.00e+01) (-1.00e+00,1.80e+01)
\end{Verbatim}
\newpage


\subsubsection{mult (const cvector\&, const cmatrix\&)}
Function%
\pdfdest name {cvector.mult (const cvector&, const cmatrix&)} fit
\begin{verbatim}
cvector& cvector::mult (const cvector& v, const cmatrix& m)
throw (cvmexception);
\end{verbatim}
sets  calling vector to be equal to  product of  vector
\verb"v" and a matrix \verb"m"
and returns a reference to
the object changed.
Function throws 
\GOT{cvmexception}{cvmexception}
if case of inappropriate sizes of the operands.
See also
\GOT{cvector::mult (const cmatrix\&, const cvector\&)}
{cvector.mult (const cmatrix&, const cvector&)},
\GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);
try {
    double a[] = {1., 2., 3., 1., 2., 3.};
    double b[] = {1., -1., 1., -1., 1., -1.,
                  2., -1., 2., -1., 2., -1.};
    const cvector v ((std::complex<double>*) a, 3);
    const cmatrix m ((std::complex<double>*) b, 3, 2);
    const scmatrix sm ((std::complex<double>*) b, 2);
    cvector vm (2);

    std::cout << vm.mult(v, m) << std::endl;
    std::cout << sm << std::endl;
    std::cout << vm.mult(vm, sm);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(1.20e+01,0.00e+00) (1.80e+01,6.00e+00)

(1.00e+00,-1.00e+00) (1.00e+00,-1.00e+00)
(1.00e+00,-1.00e+00) (2.00e+00,-1.00e+00)

(3.60e+01,-2.40e+01) (5.40e+01,-1.80e+01)
\end{Verbatim}
\newpage


\subsubsection{mult (const cmatrix\&, const cvector\&)}
Function%
\pdfdest name {cvector.mult (const cmatrix&, const cvector&)} fit
\begin{verbatim}
cvector& cvector::mult (const cmatrix& m, const cvector& v)
throw (cvmexception);
\end{verbatim}
sets  calling vector to be equal to  product of 
matrix \verb"m" and a vector \verb"v"
and returns a reference to
the object changed.
Function throws 
\GOT{cvmexception}{cvmexception}
if case of inappropriate sizes of the operands.
See also
\GOT{cvector::mult (const cvector\&, const cmatrix\&)}
{cvector.mult (const cvector&, const cmatrix&)},
\GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);
try {
    double a[] = {1., 2., 3., 1., 2., 3.};
    double b[] = {1., -1., 1., -1., 1., -1.,
                2., -1., 2., -1., 2., -1.};
    const cvector v ((std::complex<double>*) a, 3);
    const cmatrix m ((std::complex<double>*) b, 2, 3);
    const scmatrix sm ((std::complex<double>*) b, 2);
    cvector vm (2);

    std::cout << vm.mult(m, v) << std::endl;
    std::cout << sm << std::endl;;
    std::cout << vm.mult(vm, sm);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(1.40e+01,3.00e+00) (1.70e+01,4.00e+00)

(1.00e+00,-1.00e+00) (1.00e+00,-1.00e+00)
(1.00e+00,-1.00e+00) (2.00e+00,-1.00e+00)

(3.80e+01,-2.40e+01) (5.50e+01,-2.00e+01)
\end{Verbatim}
\newpage



\subsubsection{rank1update\_u}
Function%
\pdfdest name {cvector.rank1update_u} fit
\begin{verbatim}
cmatrix cvector::rank1update_u (const cvector& v) const;
\end{verbatim}
creates an object of type \GOT{cmatrix}{cmatrix}
as  rank-1 update (unconjugated) of
a calling vector and a vector \verb"v".
The rank-1 update (unconjugated)
of  vector-column $x$ of  size $m$ and
 vector-row $y$ of  size $n$ is defined as $m\times n$ matrix
\begin{equation*}
\begin{pmatrix}
x_1 y_1 & x_1 y_2 & \cdots & x_1 y_n \\
x_2 y_1 & x_2 y_2 & \cdots & x_2 y_n \\
\hdotsfor{4} \\
x_m y_1 & x_m y_2 & \cdots & x_m y_n
\end{pmatrix} =
\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_m
\end{pmatrix}
\begin{pmatrix}
y_1 & y_2 & \cdots & y_n
\end{pmatrix}
\end{equation*}
See also \GOT{cvector}{cvector}, \GOT{cmatrix}{cmatrix}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);
double a[] = {1., 2., 3., -2., -1., 1.};
double b[] = {4., 5., 3., 2.};
cvector v1((std::complex<double>*) a, 3);
cvector v2((std::complex<double>*) b, 2);

std::cout << v1.rank1update_u (v2);
\end{Verbatim}
prints
\begin{Verbatim}
(-6.00e+00,1.30e+01) (-1.00e+00,8.00e+00)
(2.20e+01,7.00e+00) (1.30e+01,0.00e+00)
(-9.00e+00,-1.00e+00) (-5.00e+00,1.00e+00)
\end{Verbatim}
\newpage



\subsubsection{rank1update\_c}
Function%
\pdfdest name {cvector.rank1update_c} fit
\begin{verbatim}
cmatrix cvector::rank1update_c (const cvector& v) const;
\end{verbatim}
creates an object of type \GOT{cmatrix}{cmatrix}
as  rank-1 update (conjugated) of
a calling vector and  complex conjugated vector \verb"v".
The rank-1 update (conjugated)
operation of  vector-column $x$ of  size $m$ and
 complex conjugated
vector-column $y$ of  size $n$ is defined as $m\times n$ matrix
\begin{equation*}
\begin{pmatrix}
x_1 y_1^* & x_1 y_2^* & \cdots & x_1 y_n^* \\
x_2 y_1^* & x_2 y_2^* & \cdots & x_2 y_n^* \\
\hdotsfor{4} \\
x_m y_1^* & x_m y_2^* & \cdots & x_m y_n^*
\end{pmatrix} =
\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_m
\end{pmatrix}
\conj\begin{pmatrix}
y_1 \\ y_2 \\ \vdots \\ y_n
\end{pmatrix} =
\begin{pmatrix}
x_1 \\
x_2 \\
\vdots \\
x_m
\end{pmatrix}
\begin{pmatrix}
y_1^* & y_2^* & \hdots & y_n^*
\end{pmatrix},
\end{equation*}
where $y_i^*$ is \hbox{$i$-th} complex conjugated element of $y$.
See also \GOT{cvector}{cvector}, \GOT{cmatrix}{cmatrix}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);
double a[] = {1., 2., 3., -2., -1., 1.};
double b[] = {4., 5., 3., 2.};
cvector v1((std::complex<double>*) a, 3);
cvector v2((std::complex<double>*) b, 2);

std::cout << v1.rank1update_c (v2) << std::endl;
std::cout << v1.rank1update_u (~v2);
\end{Verbatim}
prints
\begin{Verbatim}
(1.40e+01,3.00e+00) (7.00e+00,4.00e+00)
(2.00e+00,-2.30e+01) (5.00e+00,-1.20e+01)
(1.00e+00,9.00e+00) (-1.00e+00,5.00e+00)

(1.40e+01,3.00e+00) (7.00e+00,4.00e+00)
(2.00e+00,-2.30e+01) (5.00e+00,-1.20e+01)
(1.00e+00,9.00e+00) (-1.00e+00,5.00e+00)
\end{Verbatim}
\newpage




\subsubsection{solve}
Functions%
\pdfdest name {cvector.solve} fit
\begin{verbatim}
cvector&
cvector::solve (const scmatrix& mA,
                const cvector& vB, TR& dErr) throw (cvmexception);
cvector&
cvector::solve (const scmatrix& mA,
                const cvector& vB) throw (cvmexception);
\end{verbatim}
set  calling vector to be equal to  solution $x$ of linear equation
$A*x=b$ where parameter \verb"mA" is  square complex matrix $A$
and parameter \verb"vB" is  complex vector $b$.
Every function returns a reference to the vector changed.
The first version also sets output parameter \verb"dErr" to be equal
to  norm of computation error.
These functions throw \GOT{cvmexception}{cvmexception}
in case of inappropriate sizes
of the objects or when the matrix $A$ is close to singular.
See also  \GOT{operator \% (scmatrix)}{cvector.operator percent (scmatrix)}, 
\GOT{cvector}{cvector}, \GOT{scmatrix}{scmatrix}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);
    double dErr = 0.;

    std::cout << vx.solve (ma, vb, dErr);
    std::cout << dErr << std::endl;
    std::cout << ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(3.5200000e+00,6.4000000e-01) (2.2400000e+00,-1.3200000e+00)
3.2788531e-15
(-7.7715612e-16,4.4408921e-16) (0.0000000e+00,0.0000000e+00)
\end{Verbatim}
\newpage



\subsubsection{solve\_tran}
Functions%
\pdfdest name {cvector.solvetran} fit
\begin{verbatim}
cvector& cvector::solve_tran (const scmatrix& mA,
                              const cvector& vB, TR& dErr)
                              throw (cvmexception);
cvector& cvector::solve_tran (const scmatrix& mA,
                              const cvector& vB)
                              throw (cvmexception);
\end{verbatim}
set calling vector to be equal to solution $x$ of linear equation
$A^T*b=b$ (which is equivalent to $x*A=b$) 
where parameter \verb"mA" is  square complex matrix $A$
and parameter \verb"vB" is  complex vector $b$.
Every function returns a reference to the vector changed.
The first version also sets output parameter \verb"dErr" to be equal
to the norm of computation error.
These functions throw \GOT{cvmexception}{cvmexception}
in case of inappropriate sizes
of the objects or when the matrix $A$ is close to singular.
See also \GOT{operator / (scmatrix)}{cvector.operator / (scmatrix)}, 
\GOT{cvector::solve}{cvector.solve}, \GOT{cvector::solve\_conj}{cvector.solveconj},
\GOT{cvector}{cvector}, \GOT{scmatrix}{scmatrix}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::showpos);
std::cout.precision (7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);
    double dErr = 0.;

    std::cout << vx.solve_tran (ma, vb, dErr);
    std::cout << dErr << std::endl;
    std::cout << vx * ma - vb;
    std::cout << !ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(+1.6000000e-001,-8.8000000e-001) (+1.5600000e+000,-8.0000000e-002)
+3.7480513e-015
(+0.0000000e+000,+0.0000000e+000) (+0.0000000e+000,+4.4408921e-016)
(+0.0000000e+000,+0.0000000e+000) (+0.0000000e+000,+4.4408921e-016)
\end{Verbatim}
\newpage




\subsubsection{solve\_conj}
Functions%
\pdfdest name {cvector.solveconj} fit
\begin{verbatim}
cvector& cvector::solve_conj (const scmatrix& mA,
                              const cvector& vB, TR& dErr)
                              throw (cvmexception);
cvector& cvector::solve_conj (const scmatrix& mA,
                              const cvector& vB)
                              throw (cvmexception);
\end{verbatim}
set calling vector to be equal to solution $x$ of linear equation
$A^H*x=b$ (here $A^H$ is conjugated $A$)
where parameter \verb"mA" is  square complex matrix $A$
and parameter \verb"vB" is  complex vector $b$.
Every function returns a reference to the vector changed.
The first version also sets output parameter \verb"dErr" to be equal
to the norm of computation error.
These functions throw \GOT{cvmexception}{cvmexception}
in case of inappropriate sizes
of the objects or when the matrix $A$ is close to singular.
See also \GOT{cvector::solve}{cvector.solve}, \GOT{cvector::solve\_tran}{cvector.solvetran}, 
\GOT{cvector}{cvector}, \GOT{scmatrix}{scmatrix},
\GOT{scmatrix::operator \TildaT}{scmatrix.conj} .
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::showpos);
std::cout.precision (7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);
    double dErr = 0.;

    std::cout << vx.solve_conj (ma, vb, dErr);
    std::cout << dErr << std::endl;
    std::cout << ~ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(+2.3200000e+000,+3.7600000e+000) (+2.1200000e+000,+1.6000000e-001)
+2.1932508e-015
(+0.0000000e+000,-4.4408921e-016) (-8.8817842e-016,-8.8817842e-016)
\end{Verbatim}
\newpage



\subsubsection{operator / (const scmatrix\&)}
Operator%
\pdfdest name {cvector.operator / (scmatrix)} fit
\begin{verbatim}
cvector operator / (const scmatrix& mA) const throw (cvmexception);
\end{verbatim}
returns solution $x$ of linear equation
$A^T*x=b$ (which is equivalent to $x*A=b$) 
where parameter \verb"mA" is  square complex matrix $A$
and calling vector is $b$.
This operator throws exception 
of type \GOT{cvmexception}{cvmexception}
in case of inappropriate sizes
of the objects or when the matrix $A$ is close to singular.
See also \GOT{cvector::solve\_tran}{cvector.solvetran}, \GOT{cvector}{cvector}, \GOT{scmatrix}{scmatrix}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::showpos);
std::cout.precision (7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);

    vx = vb / ma;

    std::cout << vx * ma - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(+0.0000000e+000,+0.0000000e+000) (+0.0000000e+000,+4.4408921e-016)
\end{Verbatim}
\newpage


\subsubsection{operator \% (const scmatrix\&)}
Operator%
\pdfdest name {cvector.operator percent (scmatrix)} fit
\begin{verbatim}
cvector operator % (const scmatrix& mA) const throw (cvmexception);
\end{verbatim}
returns solution $x$ of linear equation
$A*x=b$ where parameter \verb"mA" is  square complex matrix $A$
and calling vector is $b$.
This operator throws exception 
of type \GOT{cvmexception}{cvmexception}
in case of inappropriate sizes
of the objects or when the matrix $A$ is close to singular.
See also \GOT{cvector::solve}{cvector.solve}, \GOT{cvector}{cvector}, \GOT{scmatrix}{scmatrix}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::showpos);
std::cout.precision (7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b[] = {1., 2., 5., -3.};
    scmatrix ma((std::complex<double>*) m, 2);
    cvector vb((std::complex<double>*) b, 2);
    cvector vx(2);

    vx = vb % ma;

    std::cout << ma * vx - vb;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(-6.6613381e-016,+4.4408921e-016) (+0.0000000e+000,+0.0000000e+000)
\end{Verbatim}
\newpage




\subsubsection{solve\_lu}
Functions%
\pdfdest name {cvector.solvelu} fit
\begin{verbatim}
cvector&
cvector::solve_lu (const scmatrix& mA, const scmatrix& mLU,
                   const int* pPivots, const cvector& vB, TR& dErr)
                   throw (cvmexception);
cvector&
cvector::solve_lu (const scmatrix& mA, const scmatrix& mLU,
                   const int* pPivots, const cvector& vB)
                   throw (cvmexception);
\end{verbatim}
set  calling vector to be equal to  solution $x$ of linear equation
$A*x=b$ where parameter \verb"mA" is  square matrix $A$,
parameter \verb"mLU" is \GO{$LU$ factorization}{scmatrix.low_up}
of the matrix $A$, parameter \verb"pPivots" is  array of pivot numbers
created while factorizing the matrix $A$
and parameter \verb"vB" is  vector $b$.
Every function returns a reference to the vector changed.
The first version also sets output parameter \verb"dErr" to be equal
to  norm of computation error.
These functions are useful when you need to solve few linear equations
of kind $Ax=b$ with the same matrix $A$ and different vectors $b$.
In such case you save on matrix $A$ factorization since it's needed to be
performed just one time.
These functions throw \GOT{cvmexception}{cvmexception}
in case of inappropriate sizes
of the objects or when the matrix $A$ is close to singular.
See also \GOT{cvector}{cvector}, \GOT{scmatrix}{scmatrix}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (7);

try {
    double m[] = {1., -1., 1., 2., -2., 1., 3., -3.};
    double b1[] = {1., 2., 5., -3.};
    double b2[] = {3., -1., 1., 7.};
    scmatrix ma((std::complex<double>*) m, 2);
    scmatrix mLU(2);
    cvector vb1((std::complex<double>*) b1, 2);
    cvector vb2((std::complex<double>*) b2, 2);
    cvector vx1(2);
    cvector vx2(2);
    iarray nPivots(2);
    double dErr = 0.;

    mLU.low_up(ma, nPivots);
    std::cout << vx1.solve_lu (ma, mLU, nPivots, vb1, dErr);
    std::cout << dErr << std::endl;
    std::cout << vx2.solve_lu (ma, mLU, nPivots, vb2);
    std::cout << ma * vx1 - vb1 << ma * vx2 - vb2;
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(3.5200000e+00,6.4000000e-01) (2.2400000e+00,-1.3200000e+00)
3.2788531e-15
(2.2800000e+00,1.9600000e+00) (3.6000000e-01,5.2000000e-01)
(-7.7715612e-16,4.4408921e-16) (0.0000000e+00,0.0000000e+00)
(-8.8817842e-16,0.0000000e+00) (-2.2204460e-16,0.0000000e+00)
\end{Verbatim}
\newpage



\subsubsection{gels}
Function%
\pdfdest name {cvector.gels} fit
\begin{verbatim}
cvector& cvector::gels (bool conjugate, 
                        const cmatrix& mA, const cvector& mB,
                        TC& cErr) throw (cvmexception);
\end{verbatim}
This function solves overdetermined or underdetermined linear system
\begin{equation*}
A*x=b
\end{equation*}
for $m\times n$ matrix $A$ (or its conjugate) where 
$b$ is a vector of length $k$ 
and $k=m$ in non-transposed case and $k=n$ otherwise.
The algorithm uses  QR or LQ factorization of $A$.
It is assumed that $A$ has full rank, infinity returned otherwise.
Internally  function uses \verb"?GELS" LAPACK routines. 
If $m>n$ and \verb"conjugate=false" or $m<n$ and \verb"conjugate=true", then 
the system is overdetermined, thus the algorithm tries to find the least squares solution $x$
of the problem
\begin{equation*}
\|A*x-b\|_2\to\min\quad\text{or}\quad\|A^H*x-b\|_2\to\min\
\end{equation*}
respectively. Complex number \verb"cErr" returns residuals.
The system is underdetermined otherwise, and the algorithm finds its minimum norm solution.
In this case \verb"cErr" is set to zero. In both cases the solution computed
satisfies $x=\pinv(A)*b$, but this algorithm is faster than pseudo inversion.
%Matrix $A$ is passed as an argument \verb"mA".
Function sets calling object to be the solution and returns a reference to it.
It throws
 \GOT{cvmexception}{cvmexception}
in case of inappropriate sizes of the operands.
See also \GOT{cvector}{cvector}, \GOT{cmatrix::gels}{cmatrix.gels}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::showpos);
std::cout.precision (7);
cvm::cmatrix a(7, 5);
cvm::cvector b(7), bt(5);
tcomplex cErr, cErrc;
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
bt.randomize_real(-10., 10.);
bt.randomize_imag(-10., 10.);

cvm::cvector x(5);
x.gels(false, a, b, cErr);
cvm::cvector xt(7);
xt.gels(true, a, bt, cErrc);

std::cout << (a.pinv()*b - x).norm() << std::endl;
std::cout << cErr << std::endl;
std::cout << (~a.pinv()*bt - xt).norm() << std::endl;
std::cout << cErrc << std::endl;
\end{Verbatim}
prints
\begin{Verbatim}
+1.0444134e-015
(-3.2469414e+001,+5.8375852e+000)
+1.9786436e-015
(+0.0000000e+000,+0.0000000e+000)
\end{Verbatim}
\newpage




\subsubsection{gelsy}
Function%
\pdfdest name {cvector.gelsy} fit
\begin{verbatim}
cvector& cvector::gelsy (const cmatrix& mA, const cvector& mB, int& rank,
                         TR tol = cvmMachSp()) throw (cvmexception);
\end{verbatim}
These functions 
compute minimum-norm solution to  linear
least squares problem 
\begin{equation*}
\|A*x-b\|_2\to\min
\end{equation*}
using  complete orthogonal factorization of $m\times n$ matrix $A$.
Here $b$ is a vector of length $m$.
Matrix $A$ may be rank-deficient, function returns its effective rank in \verb"rank"
output parameter using \verb"tol" tolerance.
Internally  function uses \verb"?GELSY" LAPACK routines, see more details
about the algorithm in those routines' documentation.
Matrix $A$ is passed as  argument \verb"mA".
Function sets calling object to be the solution and returns a reference to it.
It throws
 \GOT{cvmexception}{cvmexception}
in case of inappropriate sizes of the operands.
See also \GOT{cvector}{cvector}, 
\GOT{cvector::gelss}{cvector.gelss}, \GOT{cvector::gelsd}{cvector.gelsd}, 
\GOT{cmatrix::gelsy}{cmatrix.gelsy}.
Example:
\begin{Verbatim}
using namespace cvm;

cmatrix a(4, 5);
cvector b(4);
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
cvector x(5);
tint rank;

x.gelsy(a, b, rank);
std::cout << (a*x - b).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\end{Verbatim}
prints
\begin{Verbatim}
+6.0116296e-015
+4 +4
\end{Verbatim}
\newpage



\subsubsection{gelss}
Function%
\pdfdest name {cvector.gelss} fit
\begin{verbatim}
cvector& cvector::gelss (const cmatrix& mA, const cvector& mB, int& rank,
                         rvector& sv, TR tol = cvmMachSp())
                         throw (cvmexception);
\end{verbatim}
computes  minimum-norm solution to  linear
least squares problem 
\begin{equation*}
\|A*x-b\|_2\to\min
\end{equation*}
using the singular value decomposition of $m\times n$ matrix $A$.
Here $b$ is a vector of length $m$.
Matrix $A$ may be rank-deficient, function returns its effective rank in \verb"rank"
output parameter using \verb"tol" tolerance.
This function also computes
singular values of $A$ in decreasing order and returns them in \verb"sv" output parameter
having $\min(m,n)$ size.
Internally  function uses \verb"?GELSS" LAPACK routines, see more details
about the algorithm in that routine's documentation.
Matrix $A$ is passed as  argument \verb"mA".
Function sets calling object to be the solution and returns a reference to it.
It throws
 \GOT{cvmexception}{cvmexception}
in case of inappropriate sizes of the operands.
See also \GOT{cvector}{cvector}, 
\GOT{cvector::gelsy}{cvector.gelsy}, \GOT{cvector::gelsd}{cvector.gelsd}, 
\GOT{cmatrix::gelss}{cmatrix.gelss}.
Example:
\begin{Verbatim}
using namespace cvm;

cvm::cmatrix a(4, 5);
cvm::cvector b(4);
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
cvm::rvector sv(4);
cvm::cvector x(5);
tint rank;

x.gelss(a, b, sv, rank);
std::cout << (a*x - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\end{Verbatim}
prints
\begin{Verbatim}
+9.4127010e-015
+4.4408921e-015
+4 +4
\end{Verbatim}
\newpage



\subsubsection{gelsd}
Function%
\pdfdest name {cvector.gelsd} fit
\begin{verbatim}
cvector& cvector::gelsd (const cmatrix& mA, const cvector& mB, int& rank,
                         rvector& sv, TR tol = cvmMachSp())
                         throw (cvmexception);
\end{verbatim}
computes  minimum-norm solution to  linear
least squares problem 
\begin{equation*}
\|A*x-b\|_2\to\min
\end{equation*}
using the singular value decomposition of $m\times n$ matrix $A$
and  divide and conquer method.
Here $b$ is a vector of length $m$.
Matrix $A$ may be rank-deficient, function returns its effective rank in \verb"rank"
output parameter using \verb"tol" tolerance.
This function also computes
singular values of $A$ in decreasing order and returns them in \verb"sv" output parameter
having $\min(m,n)$ size.
Internally  function uses \verb"?GELSD" LAPACK routines, see more details
about the algorithm in that routine's documentation.
Matrix $A$ is passed as  argument \verb"mA".
Function sets calling object to be the solution and returns a reference to it.
It throws
 \GOT{cvmexception}{cvmexception}
in case of inappropriate sizes of the operands.
See also \GOT{cvector}{cvector}, 
\GOT{cvector::gelsy}{cvector.gelsy}, \GOT{cvector::gelss}{cvector.gelss}, 
\GOT{cmatrix::gelsd}{cmatrix.gelsd}.
Example:
\begin{Verbatim}
using namespace cvm;

cvm::cmatrix a(4, 5);
cvm::cvector b(4);
a.randomize_real(-10., 10.);
a.randomize_imag(-10., 10.);
b.randomize_real(-10., 10.);
b.randomize_imag(-10., 10.);
cvm::rvector sv(4);
cvm::cvector x(5);
tint rank;

x.gelsd(a, b, sv, rank);
std::cout << (a*x - b).norm() << std::endl;
std::cout << (sv - a.svd()).norm() << std::endl;
std::cout << rank << " " << a.rank() << std::endl;
\end{Verbatim}
prints
\begin{Verbatim}
+1.3491837e-014
+5.3290705e-015
+4 +4
\end{Verbatim}
\newpage





\subsubsection{eig}
Functions%
\pdfdest name {cvector.eig} fit
\begin{verbatim}
cvector&
cvector::eig (const srmatrix& mArg) throw (cvmexception);
cvector&
cvector::eig (const scmatrix& mArg) throw (cvmexception);

cvector&
cvector::eig (const srmatrix& mArg, scmatrix& mEigVect, 
              bool bRightVect = true) throw (cvmexception);
cvector&
cvector::eig (const scmatrix& mArg, scmatrix& mEigVect,
              bool bRightVect = true) throw (cvmexception);
\end{verbatim}
solve  nonsymmetric eigenvalue problem and
set  calling vector to be equal to eigenvalues
of a square matrix \verb"mArg".
The nonsymmetric eigenvalue problem is defined
as follows: given a nonsymmetric
(or non-Hermitian) matrix $A$, find the eigenvalues $\lambda$
and the corresponding
eigenvectors $z$ that satisfy the equation
\begin{equation*}
Az = \lambda z.
\end{equation*}
Some eigenvalues may be complex even for real matrix $A$.
Moreover, if real nonsymmetric matrix has a complex eigenvalue $a+bi$
corresponding to an eigenvector $z$, then $a-bi$ is also an eigenvalue.
The eigenvalue $a-bi$ corresponds to the eigenvector whose elements
are complex conjugate to the elements of $z$.
The third and fourth versions of  functions
set output parameter \verb"mEigVect" to be equal
to  square matrix containing eigenvectors as columns.
They also compute "left" eigenvectors if parameter \c bRightVect is set to \c false.
Left eigencectors satisfy
\begin{equation*}
z^HA = \lambda z^H.
\end{equation*}
All functions
return  reference to the vector they change and throw
 \GOT{cvmexception}{cvmexception}
in case of inappropriate calling object sizes
or in case of convergence error.
See also
\GOT{cvector}{cvector}, \GOT{rvector::eig}{rvector.eig},
\GOT{scmatrix}{scmatrix}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::showpos);
std::cout.precision (2);

try {
    srmatrix m(3);
    scmatrix me(3);
    cvector vl(3);

    m(1,1) = 0.1;  m(1,2) = 0.2;  m(1,3) = 0.1;
    m(2,1) = 0.11; m(2,2) = 2.9;  m(2,3) = -8.4;
    m(3,1) = 0.;   m(3,2) = 2.91; m(3,3) = 8.2;
    scmatrix mc(m);

    std::cout << vl.eig (m, me) << std::endl;
    std::cout << mc * me(1) - me(1) * vl(1);
    std::cout << mc * me(2) - me(2) * vl(2);
    std::cout << mc * me(3) - me(3) * vl(3) << std::endl;

    std::cout << vl.eig (m, me, false) << std::endl;
    std::cout << ~(me(1)) * mc - ~(me(1)) * vl(1);
    std::cout << ~(me(2)) * mc - ~(me(2)) * vl(2);
    std::cout << ~(me(3)) * mc - ~(me(3)) * vl(3);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(+9.69e-002,+0.00e+000) (+5.55e+000,+4.17e+000) (+5.55e+000,-4.17e+000)

(+2.78e-017,+0.00e+000) (+7.24e-017,+0.00e+000) (+4.23e-017,+0.00e+000)
(-2.22e-016,-1.94e-016) (-7.11e-015,-4.88e-015) (+0.00e+000,+1.78e-015)
(-2.22e-016,+1.94e-016) (-7.11e-015,+4.88e-015) (+0.00e+000,-1.78e-015)

(+9.69e-002,+0.00e+000) (+5.55e+000,+4.17e+000) (+5.55e+000,-4.17e+000)

(+0.00e+000,+0.00e+000) (+4.19e-017,+0.00e+000) (+1.13e-017,+0.00e+000)
(+0.00e+000,-4.16e-017) (+2.22e-016,-1.78e-015) (-8.88e-016,+2.44e-015)
(+0.00e+000,+4.16e-017) (+2.22e-016,+1.78e-015) (-8.88e-016,-2.44e-015)
\end{Verbatim}
\newpage


\subsubsection{geneig}
Functions%
\pdfdest name {cvector.geneig} fit
\begin{verbatim}
cvector& 
cvector::geneig (const srmatrix& mA, const srmatrix& mB, rvector& vBeta)
                 throw(cvmexception);
cvector& 
cvector::geneig (const srmatrix& mA, const srmatrix& mB, rvector& vBeta,
                 scmatrix& mEigVectLeft, scmatrix& mEigVectRight) 
                 throw(cvmexception);
cvector& 
cvector::geneig (const srmatrix& mA, const srmatrix& mB, rvector& vBeta,
                 scmatrix& mEigVect, bool bRightVect = true)
                 throw(cvmexception);

cvector& 
cvector::geneig (const scmatrix& mA, const scmatrix& mB, cvector& vBeta)
                 throw(cvmexception);
cvector& 
cvector::geneig (const scmatrix& mA, const scmatrix& mB, cvector& vBeta,
                 scmatrix& mEigVectLeft, scmatrix& mEigVectRight)
                 throw(cvmexception);
cvector& 
cvector::geneig (const scmatrix& mA, const scmatrix& mB, cvector& vBeta,
                 scmatrix& mEigVect, bool bRightVect = true)
                 throw(cvmexception);
\end{verbatim}
solve generalized eigenvalue problem and
set  calling vector to be equal to generalized eigenvalues
of a square matrices \verb"mA" and  \verb"mB".
A generalized eigenvalue for a pair of matrices $(A,B)$ is a scalar $\lambda$ or a ratio $\alpha / \beta = \lambda$, 
such that $A - \lambda B$ is singular. It is usually represented as the pair $(\alpha, \beta)$, 
as there is a reasonable interpretation for $\beta =0$ and even for both being zero.
The right generalized eigenvector $v_j$ corresponding to the generalized eigenvalue $\lambda_j$ of $(A,B)$ satisfies
\begin{equation*}
A v_j = \lambda_j B v_j.
\end{equation*}
The left generalized eigenvector $u_j$ corresponding to the generalized eigenvalue $\lambda_j$ of $(A,B)$ satisfies
\begin{equation*}
u_j^H A = \lambda_j u_j^H B.
\end{equation*}

All functions
return  reference to the vector they change and throw
 \GOT{cvmexception}{cvmexception}
in case of inappropriate calling object sizes
or in case of convergence error.
See also
\GOT{cvector}{cvector}, \GOT{cvector::eig}{cvector.eig},
\GOT{scmatrix}{scmatrix}.
Example (real matrices):
\begin{Verbatim}
using namespace cvm;
try {
    srmatrix a(5), b(5);
    a.randomize(-10., 10.);
    b.randomize(-10., 10.);
    cvector alpha(5);
    rvector beta(5);
    scmatrix eigVectLeft(5), eigVectRight(5);
    int i;

    alpha.geneig(a, b, beta, eigVectLeft, eigVectRight);
    for (i = 1; i <= 5; ++i) {
        std::cout << (scmatrix(a) -
            alpha[i] / beta[i] * scmatrix(b)).svd();
    }
    for (i = 1; i <= 5; ++i) {
        std::cout << (~(eigVectLeft(i)) * scmatrix(a) -
            (alpha[i] / beta[i]) * ~(eigVectLeft(i)) *
            scmatrix(b)).norm() << std::endl;
    }
    for (i = 1; i <= 5; ++i) {
        std::cout << (scmatrix(a) * eigVectRight(i) -
            (alpha[i] / beta[i]) * scmatrix(b) *
            eigVectRight(i)).norm() << std::endl;
    }

    alpha.geneig(a, b, beta, eigVectLeft, false);
    for (i = 1; i <= 5; ++i) {
        std::cout << (~(eigVectLeft(i)) * scmatrix(a) -
            (alpha[i] / beta[i]) * ~(eigVectLeft(i)) *
            scmatrix(b)).norm() << std::endl;
    }

    alpha.geneig(a, b, beta, eigVectRight);
    for (i = 1; i <= 5; ++i) {
        std::cout << (scmatrix(a) * eigVectRight(i) -
            (alpha[i] / beta[i]) * scmatrix(b) *
            eigVectRight(i)).norm() << std::endl;
    }
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
31.328 23.9648 18.6695 7.95943 1.3636e-015
31.328 23.9648 18.6695 7.95943 3.17647e-015
26.3359 20.9384 12.8015 8.20644 1.58238e-015
38.886 22.9187 21.6982 8.51899 4.17944e-015
26.3947 16.1351 13.8545 7.6506 2.99015e-015
2.32204e-014
2.16331e-014
1.53681e-014
1.23709e-014
5.32213e-015
1.25076e-014
1.33762e-014
2.10381e-014
1.99396e-014
1.22447e-014
2.32204e-014
2.16331e-014
1.53681e-014
1.23709e-014
5.32213e-015
1.25076e-014
1.33762e-014
2.10381e-014
1.99396e-014
1.22447e-014
\end{Verbatim}

Example (complex matrices):
\begin{Verbatim}
using namespace cvm;
try {
    scmatrix a(5);
    scbmatrix b(5, 2, 1);
    a.randomize_real(-10., 10.);
    a.randomize_imag(-10., 10.);
    b.randomize_real(-10., 10.);
    b.randomize_imag(-10., 10.);
    cvector alpha(5);
    cvector beta(5);
    scmatrix eigVectLeft(5), eigVectRight(5);
    int i;

    alpha.geneig(a, b, beta, eigVectLeft, eigVectRight);
    for (i = 1; i <= 5; ++i) {
        std::cout << (a - alpha[i] / beta[i] * b).svd();
    }
    for (i = 1; i <= 5; ++i) {
        std::cout << (~(eigVectLeft(i)) * a -
            (alpha[i] / beta[i]) * ~(eigVectLeft(i)) * b).norm()
            << std::endl;
    }
    for (i = 1; i <= 5; ++i) {
        std::cout << (a * eigVectRight(i) -
            (alpha[i] / beta[i]) * b * eigVectRight(i)).norm()
            << std::endl;
    }

    alpha.geneig(a, b, beta, eigVectLeft, false);
    for (i = 1; i <= 5; ++i) {
        std::cout << (~(eigVectLeft(i)) * a -
            (alpha[i] / beta[i]) * ~(eigVectLeft(i)) * b).norm()
            << std::endl;
    }

    alpha.geneig(a, b, beta, eigVectRight);
    for (i = 1; i <= 5; ++i) {
        std::cout << (a * eigVectRight(i) -
            (alpha[i] / beta[i]) * b * eigVectRight(i)).norm()
            << std::endl;
    }
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
67.7195 51.2625 39.0367 13.472 1.34998e-015
46.2033 28.5441 20.5831 16.045 1.30494e-014
35.9992 22.556 16.2677 9.76767 8.3086e-016
37.362 22.8235 16.7452 6.18941 7.78931e-015
48.1894 33.972 19.4611 9.67851 8.82633e-015
3.15084e-014
3.18446e-014
1.79087e-014
1.32967e-014
1.55926e-014
2.81603e-014
1.82293e-014
2.18339e-014
2.17468e-014
2.38458e-014
3.15084e-014
3.18446e-014
1.79087e-014
1.32967e-014
1.55926e-014
2.81603e-014
1.82293e-014
2.18339e-014
2.17468e-014
2.38458e-014
\end{Verbatim}
\newpage




\subsubsection{gemv}
Function%
\pdfdest name {cvector.gemv} fit
\begin{verbatim}
cvector& cvector::gemv (bool bLeft, const cmatrix& m, TC dAlpha,
                        const cvector& v, TC dBeta) throw (cvmexception);
\end{verbatim}
calls one of \verb"?GEMV" routines of the
\URL{BLAS library}{http://www.netlib.org/blas}
performing  matrix-vector operation defined as
\begin{equation*}
c=\alpha\,M\cdot v + \beta\,c\quad\text{or}\quad c=\alpha\,v\cdot M + \beta\, c,
\end{equation*}
where $\alpha$ and $\beta$ are complex numbers
(parameters \verb"dAlpha" and \verb"dBeta"),
$M$ is  complex matrix (parameter \verb"m")
and $v$ and $c$ are complex vectors (parameter \verb"v"
and calling vector respectively).
First operation is performed if \verb"bLeft" passed
is \verb"false" and second one otherwise.
Function
returns a reference to the vector changed and throws
 \GOT{cvmexception}{cvmexception}
in case of inappropriate calling object sizes.
See also
\GOT{cvector}{cvector},
\GOT{cmatrix}{cmatrix}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

try {
    std::complex<double> alpha = std::complex<double>(1.3,-0.7);
    std::complex<double> beta  = std::complex<double>(0.15,-1.09);
    cmatrix m(3,2);
    cvector c(3);
    cvector v(2);
    m.randomize_real(-1., 2.); m.randomize_imag(0., 1.);
    v.randomize_real(-1., 3.); v.randomize_imag(2., 4.);
    c.randomize_real(0., 2.); c.randomize_imag(3., 7.);
    std::cout << m * v * alpha + c * beta;
    std::cout << c.gemv(false, m, alpha, v, beta);
    std::cout << c * m * alpha + v * beta;
    std::cout << v.gemv(true, m, alpha, c, beta);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(2.71e-01,2.44e+00) (2.20e+01,7.16e+00) (-7.89e-01,2.45e+00)
(2.71e-01,2.44e+00) (2.20e+01,7.16e+00) (-7.89e-01,2.45e+00)
(5.92e+01,-1.47e+01) (3.54e+01,-3.14e+00)
(5.92e+01,-1.47e+01) (3.54e+01,-3.14e+00)
\end{Verbatim}
\newpage



\subsubsection{gbmv}
Function%
\pdfdest name {cvector.gbmv} fit
\begin{verbatim}
cvector& cvector::gbmv (bool bLeft, const scbmatrix& m, TC dAlpha,
                        const cvector& v, TC dBeta) throw (cvmexception);
\end{verbatim}
calls one of \verb"?GBMV" routines of the
\URL{BLAS library}{http://www.netlib.org/blas}
performing  matrix-vector operation defined as
\begin{equation*}
c=\alpha\,M\cdot v + \beta\,c\quad\text{or}\quad c=\alpha\,v\cdot M + \beta\, c,
\end{equation*}
where $\alpha$ and $\beta$ are complex numbers
(parameters \verb"dAlpha" and \verb"dBeta"),
$M$ is  complex band matrix (parameter \verb"m")
and $v$ and $c$ are complex vectors (parameter \verb"v"
and calling vector respectively).
First operation is performed if \verb"bLeft" passed
is \verb"false" and second one otherwise.
Function
returns a reference to the vector changed and throws
 \GOT{cvmexception}{cvmexception}
in case of inappropriate calling object sizes.
See also
\GOT{cvector}{cvector},
\GOT{scbmatrix}{scbmatrix}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

try {
    std::complex<double> alpha = std::complex<double>(1.3,-0.7);
    std::complex<double> beta  = std::complex<double>(0.15,-1.09);
    scbmatrix m(3,1,0);
    cvector c(3);
    cvector v(3);
    m.randomize_real(-1., 2.); m.randomize_imag(0., 1.);
    v.randomize_real(-1., 3.); v.randomize_imag(2., 4.);
    c.randomize_real(0., 2.); c.randomize_imag(3., 7.);
    std::cout << m * v * alpha + c * beta;
    std::cout << c.gbmv(false, m, alpha, v, beta);
    std::cout << c * m * alpha + v * beta;
    std::cout << v.gbmv(true, m, alpha, c, beta);
}
catch (std::exception& e) {
    std::cout << "Exception " << e.what () << std::endl;
}
\end{Verbatim}
prints
\begin{Verbatim}
(3.73e+00,7.96e-01) (6.89e+00,1.07e+01) (2.16e+00,3.28e+00)
(3.73e+00,7.96e-01) (6.89e+00,1.07e+01) (2.16e+00,3.28e+00)
(3.11e+01,2.51e+01) (-4.93e+00,1.34e+01) (1.70e+00,3.93e+00)
(3.11e+01,2.51e+01) (-4.93e+00,1.34e+01) (1.70e+00,3.93e+00)
\end{Verbatim}
\newpage





\subsubsection{randomize\_real}
Function%
\pdfdest name {cvector.randomizereal} fit
\begin{verbatim}
cvector& cvector::randomize_real (TR dFrom, TR dTo);
\end{verbatim}
fills  real part of a calling vector with
pseudo-random numbers distributed between
\verb"dFrom" and \verb"dTo".
Function
returns a reference to the vector changed.
See also
\GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

cvector v(3);
v.randomize_real(-2.,3.);
std::cout << v;
\end{Verbatim}
prints
\begin{Verbatim}
(-4.93e-01,0.00e+00) (1.37e+00,0.00e+00) (-1.49e-01,0.00e+00)
\end{Verbatim}
\newpage


\subsubsection{randomize\_imag}
Function%
\pdfdest name {cvector.randomizeimag} fit
\begin{verbatim}
cvector& cvector::randomize_imag (TR dFrom, TR dTo);
\end{verbatim}
fills  imaginary part of a calling vector with
pseudo-random numbers distributed between
\verb"dFrom" and \verb"dTo".
Function
returns a reference to the vector changed.
See also
\GOT{cvector}{cvector}.
Example:
\begin{Verbatim}
using namespace cvm;
std::cout.setf (std::ios::scientific | std::ios::left);
std::cout.precision (2);

cvector v(3);
v.randomize_imag(-2.,3.);
std::cout << v;
\end{Verbatim}
prints
\begin{Verbatim}
(0.00e+00,-4.37e-01) (0.00e+00,-1.59e+00) (0.00e+00,2.42e+00)
\end{Verbatim}
\newpage
